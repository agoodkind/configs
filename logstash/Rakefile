# frozen_string_literal: true

require 'rspec/core/rake_task'
require 'rubocop/rake_task'
require 'fileutils'
require 'dotenv'
require_relative '../lib/rake_common'

# Load .env from current directory and parent directory
Dotenv.load('.env', '../.env')

# Include common helpers
# rubocop:disable Style/MixinUsage
extend RakeCommon
# rubocop:enable Style/MixinUsage

##
# Logstash Filterlog Parser Rakefile
#
# This Rakefile provides comprehensive deployment and management tasks for
# a custom Logstash Ruby filter and pipeline configurations. It supports
# local and remote (SSH) deployments.
#
# @author Alex Goodkind
# @version 1.0

# Configuration
RUBY_DIR = 'ruby'
CONF_DIR = 'conf'
LOGSTASH_RUBY_DIR = '/etc/logstash/ruby'
LOGSTASH_CONF_DIR = '/etc/logstash/conf.d'
LOGSTASH_USER = ENV.fetch('LOGSTASH_USER', 'logstash')
LOGSTASH_GROUP = ENV.fetch('LOGSTASH_GROUP', 'logstash')
SYSLOG_PORT = ENV.fetch('SYSLOG_PORT', '5140').to_i
LOGSTASH_HOST = ENV.fetch('LOGSTASH_HOST', nil)

##
# Check if remote SSH deployment is enabled
#
# @return [Boolean] true if LOGSTASH_HOST is set
def remote_enabled?
  !LOGSTASH_HOST.nil? && !LOGSTASH_HOST.empty?
end

##
# Execute a command based on deployment mode (local or remote SSH)
#
# Routes command execution to the appropriate handler based on environment
# variables.
#
# @param cmd [String] the command to execute
# @return [void]
# @raise [RuntimeError] if command execution fails
def run_cmd(cmd)
  if remote_enabled?
    remote_cmd(cmd)
  elsif dry_run?
    puts "[DRY-RUN] #{cmd}".yellow
  else
    sh cmd
  end
end

##
# Execute a command on a remote host via SSH
#
# @param cmd [String] the command to execute on the remote host
# @return [void]
# @raise [RuntimeError] if SSH command fails
def remote_cmd(cmd)
  full_cmd = "ssh #{LOGSTASH_HOST} '#{cmd}'"
  if dry_run?
    puts "[DRY-RUN] #{full_cmd}".yellow
  else
    sh full_cmd
  end
end

# Default task
task default: %i[format lint test]

##
# Display help information for all available rake tasks
#
# Shows organized list of development, deployment, and diagnostic tasks
# with usage examples.
desc 'Show available tasks'
task :help do
  puts 'Logstash Filterlog Parser'.blue
  puts ''
  puts 'Development:'.green
  puts '  rake install       - Install dependencies'
  puts '  rake test          - Run tests'
  puts '  rake lint          - Run linter'
  puts '  rake format        - Auto-format code'
  puts '  rake dev           - Run format, lint, and test'
  puts ''
  puts 'Deployment:'.green
  puts '  rake deploy        - Deploy to Logstash'
  puts '  rake dry_run       - Show what deploy would do'
  puts '  rake backup        - Backup current configs'
  puts '  rake check         - Validate config'
  puts '  rake restart       - Restart Logstash'
  puts '  rake full_deploy   - Complete deployment pipeline'
  puts ''
  puts 'Diagnostics:'.green
  puts '  rake diagnose      - Check for common issues'
  puts '  rake status        - Show Logstash status'
  puts '  rake logs          - Tail Logstash logs'
  puts '  rake check_port    - Check if port 5140 is in use'
  puts ''
  puts 'Examples:'.yellow
  puts '  DRY_RUN=1 rake deploy                    - Dry-run deployment'
  puts '  LOGSTASH_HOST=root@host rake deploy     - Deploy to remote host'
  puts '  LOGSTASH_HOST=root@host rake restart    - Restart Logstash on remote host'
  puts '  rake dev && rake deploy && rake restart'
end

##
# Configure and run RSpec tests
#
# Runs all test files matching the pattern spec/**/*_spec.rb with
# colored documentation output.
RSpec::Core::RakeTask.new(:test) do |t|
  t.pattern = 'spec/**/*_spec.rb'
  t.rspec_opts = ['--format', 'documentation', '--color']
end

##
# Configure and run RuboCop linter
#
# Runs RuboCop with cop names displayed and fails on any violations.
RuboCop::RakeTask.new(:lint) do |t|
  t.options = ['--display-cop-names']
  t.fail_on_error = true
end

##
# Configure and run RuboCop auto-formatter
#
# Runs RuboCop with auto-correct to automatically fix style violations.
# Does not fail on errors to allow fixing of problematic code.
RuboCop::RakeTask.new(:format) do |t|
  t.options = ['--autocorrect-all']
  t.fail_on_error = false
end

##
# Run complete development workflow
#
# Executes format, lint, and test tasks in sequence. Useful for
# pre-deployment validation.
desc 'Run format, lint, and test'
task dev: %i[format lint test] do
  puts '✅ All development checks passed'.green
end

##
# Run diagnostic checks on Logstash configuration
#
# Performs comprehensive checks including:
# - Duplicate input port configurations
# - Port 5140 usage status
# - List of deployed config files
# - Ruby filter syntax validation
desc 'Check for common configuration issues'
task diagnose: %i[check_port check_configs] do
  puts '▶️ Running diagnostics...'.blue
  puts ''

  # Check for duplicate inputs
  puts 'Checking for duplicate input configurations:'.yellow
  run_cmd('grep -r "port.*5140" /etc/logstash/conf.d/ || ' \
          'echo "  ✅ No duplicates found"')
  puts ''

  # Check for syntax errors (locally)
  puts 'Checking Ruby filter syntax (local):'.yellow
  ruby_files = Dir.glob(File.join(RUBY_DIR, '*.rb'))
  if ruby_files.empty?
    puts '  ⚠️️ No Ruby files found'.yellow
  else
    ruby_files.each do |file|
      sh "ruby -c #{file}", verbose: false
      puts "  ✅ #{File.basename(file)}".green
    rescue StandardError
      puts "  ❌ #{File.basename(file)} has syntax errors".red
    end
  end
  puts ''

  puts '✅ Diagnostics complete'.green
end

##
# Check if syslog port 5140 is in use
#
# Uses 'ss' command to check if UDP port 5140 is currently bound.
desc 'Check if port 5140 is in use'
task :check_port do
  puts '▶️ Checking port 5140...'.blue
  run_cmd("ss -lunp | grep :#{SYSLOG_PORT} || " \
          "echo '✅ Port #{SYSLOG_PORT} is available'")
end

##
# Display Logstash service status
#
# Shows systemd service status for the Logstash daemon.
desc 'Show Logstash service status'
task :status do
  run_cmd('systemctl status logstash --no-pager')
end

##
# Tail Logstash service logs in real-time
#
# Monitors journalctl logs for the Logstash service. Press Ctrl+C to stop.
# Handles local and remote SSH deployments.
desc 'Tail Logstash logs'
task :logs do
  puts 'Monitoring Logstash logs (Ctrl+C to stop)...'.blue
  if remote_enabled?
    sh('bash', '-c',
       "ssh #{LOGSTASH_HOST} 'journalctl -u logstash -f'")
  else
    run_cmd('sudo journalctl -u logstash -f')
  end
end

##
# Create timestamped backups of current Logstash configuration
#
# Backs up both config files and Ruby filters to timestamped directories.
# Backup format: /etc/logstash/conf.d.backup.YYYYMMDD-HHMMSS
desc 'Backup current Logstash configs'
task :backup do
  puts '▶️ Creating backups...'.blue
  timestamp = Time.now.strftime('%Y%m%d-%H%M%S')
  conf_backup_dir = "#{LOGSTASH_CONF_DIR}.backup.#{timestamp}"
  ruby_backup_dir = "#{LOGSTASH_RUBY_DIR}.backup.#{timestamp}"

  # Create single backup command that does everything
  backup_cmd = <<~SCRIPT
    if [ -d #{LOGSTASH_CONF_DIR} ] && [ "$(ls -A #{LOGSTASH_CONF_DIR}/*.conf 2>/dev/null)" ]; then
      cp -r #{LOGSTASH_CONF_DIR} #{conf_backup_dir}
      echo "CONFIG_BACKUP_OK"
    else
      echo "CONFIG_BACKUP_SKIP"
    fi
    if [ -d #{LOGSTASH_RUBY_DIR} ] && [ "$(ls -A #{LOGSTASH_RUBY_DIR}/*.rb 2>/dev/null)" ]; then
      cp -r #{LOGSTASH_RUBY_DIR} #{ruby_backup_dir}
      echo "RUBY_BACKUP_OK"
    else
      echo "RUBY_BACKUP_SKIP"
    fi
  SCRIPT

  if dry_run?
    puts '[DRY-RUN] Backup directories'.yellow
    output = "CONFIG_BACKUP_OK\nRUBY_BACKUP_OK"
  elsif remote_enabled?
    output = `ssh #{LOGSTASH_HOST} 'bash -c "#{backup_cmd.gsub('"', '\"')}"'`
  else
    output = `#{backup_cmd}`
  end

  puts "✅ Config backup created: #{conf_backup_dir}".green if output.include?('CONFIG_BACKUP_OK')
  puts '⚠️️ No configs to backup'.yellow if output.include?('CONFIG_BACKUP_SKIP')
  puts "✅ Ruby backup created: #{ruby_backup_dir}".green if output.include?('RUBY_BACKUP_OK')
  puts '⚠️️ No Ruby filters to backup'.yellow if output.include?('RUBY_BACKUP_SKIP')
end

##
# Deploy Ruby filter scripts to Logstash
#
# Copies Ruby filter files from ruby/ directory to /etc/logstash/ruby/
# and sets appropriate ownership and permissions.
desc 'Deploy Ruby filters'
task :deploy_ruby do
  puts '▶️ Deploying Ruby filters...'.blue
  deploy_files(RUBY_DIR, LOGSTASH_RUBY_DIR, '*.rb')
end

##
# Deploy Logstash pipeline configuration files
#
# Copies config files from conf/ directory to /etc/logstash/conf.d/
# and sets appropriate ownership and permissions.
desc 'Deploy Logstash configs'
task :deploy_conf do
  return unless Dir.exist?(CONF_DIR)

  puts '▶️ Deploying Logstash configs...'.blue
  deploy_files(CONF_DIR, LOGSTASH_CONF_DIR, '*.logstash.conf')
end

##
# Deploy files with all setup in single batch
#
# @param source_dir [String] source directory containing files
# @param dest_dir [String] destination directory path
# @param pattern [String] glob pattern for file matching (e.g., '*.rb')
# @return [void]
def deploy_files(source_dir, dest_dir, pattern)
  files = Dir.glob(File.join(source_dir, pattern))

  if files.empty?
    puts "  No #{pattern} files to deploy".yellow
    return
  end

  puts "  Deploying #{files.length} #{pattern} file(s)...".blue unless verbose?
  files.each { |file| puts "    #{File.basename(file)}" } if verbose?

  if remote_enabled?
    deploy_files_remote_batch(files, dest_dir, pattern)
  else
    deploy_files_local_batch(files, dest_dir, pattern)
  end
end

##
# Deploy files to remote host in single operation
#
# @param files [Array<String>] array of file paths to copy
# @param dest_dir [String] destination directory path
# @param pattern [String] file pattern for cleanup
# @return [void]
def deploy_files_remote_batch(files, dest_dir, pattern)
  deploy_files_to_host(
    files,
    LOGSTASH_HOST,
    dest_dir,
    pattern,
    owner: "#{LOGSTASH_USER}:#{LOGSTASH_GROUP}",
    mode: '755'
  )
end

##
# Deploy files locally in single operation
#
# @param files [Array<String>] array of file paths to copy
# @param dest_dir [String] destination directory path
# @param pattern [String] file pattern for cleanup
# @return [void]
def deploy_files_local_batch(files, dest_dir, pattern)
  file_list = files.join(' ')
  sh "sudo mkdir -p #{dest_dir} && sudo rm -rf #{dest_dir}/#{pattern}"
  sh "sudo cp #{file_list} #{dest_dir}/"
  sh "sudo chmod 755 #{dest_dir} && sudo chmod 755 #{dest_dir}/#{pattern}"
  sh "sudo chown -R #{LOGSTASH_USER}:#{LOGSTASH_GROUP} #{dest_dir}"
end

##
# Main deployment task
#
# Executes complete deployment workflow:
# 1. Backup existing configs
# 2. Deploy Ruby filters
# 3. Deploy configuration files
#
# After completion, suggests running diagnose, check, and restart tasks.
desc 'Deploy to Logstash'
task deploy: %i[backup deploy_ruby deploy_conf] do
  puts ''
  puts '✅ Deployment completed'.green
  puts ''
  puts 'Next steps:'.yellow
  puts '  1. rake diagnose  - Check for issues'
  puts '  2. rake check     - Validate configuration'
  puts '  3. rake restart   - Apply changes'
end

##
# Preview deployment without making changes
#
# Runs deployment in dry-run mode by setting DRY_RUN=1 environment variable.
# Shows all commands that would be executed without actually running them.
desc 'Preview deployment without making changes'
task :dry_run do
  puts 'Running deployment in dry-run mode...'.yellow
  ENV['DRY_RUN'] = '1'
  Rake::Task[:deploy].invoke
end

##
# Validate Logstash configuration
#
# Lists deployed config files to verify deployment.
desc 'Validate Logstash configuration'
task :check_configs do
  puts '▶️ Checking deployed configuration files...'.blue
  run_cmd("ls -lh #{LOGSTASH_CONF_DIR}/*.conf")

  puts ''
  puts '✅ Configuration files deployed'.green
  puts ''
  puts 'Validation will occur on restart'.yellow
end

##
# Restart Logstash service
#
# Performs graceful restart of Logstash:
# 1. Stops the service
# 2. Waits for port release
# 3. Starts the service
# 4. Waits for startup
# 5. Verifies service is active
desc 'Restart Logstash service'
task :restart do
  puts '▶️ Stopping Logstash...'.blue
  run_cmd('systemctl stop logstash')

  # Wait for port to be released
  sleep 2

  puts '▶️ Starting Logstash...'.blue
  run_cmd('systemctl start logstash')

  # Wait for service to start
  sleep 3

  puts '▶️ Checking status...'.blue
  run_cmd('systemctl is-active logstash')

  puts '✅ Logstash restarted'.green
  puts ''
  puts 'Monitor logs:'.yellow
  puts '  rake logs'
end

##
# Complete deployment pipeline
#
# Runs full deployment workflow in sequence:
# 1. Format code
# 2. Lint code
# 3. Run tests
# 4. Backup existing configs
# 5. Deploy files
# 6. Run diagnostics
# 7. Validate configuration
#
# Does not automatically restart - suggests manual restart as final step.
desc 'Complete deployment pipeline ' \
     '(format, lint, test, backup, deploy, check)'
task full_deploy: %i[format lint test backup deploy diagnose restart] do
  puts ''
  puts '✅ Full deployment pipeline completed'.green
  puts ''
  puts 'Final step:'.yellow
  puts '  rake restart'
end

##
# Remove temporary files and build artifacts
#
# Cleans up:
# - .bundle directory
# - vendor/bundle directory
# - Vim swap files (.swp, .swo)
# - Backup files (~)
# - macOS .DS_Store files
desc 'Remove temporary files'
task :clean do
  puts '▶️ Cleaning temporary files...'.blue
  FileUtils.rm_rf('.bundle')
  FileUtils.rm_rf('vendor/bundle')

  ['.swp', '.swo', '~', '.DS_Store'].each do |ext|
    Dir.glob("**/*#{ext}").each { |f| FileUtils.rm_f(f) }
  end

  puts '✅ Cleanup completed'.green
end

##
# Install Ruby dependencies
#
# Runs 'bundle install' to install all gems specified in Gemfile.
desc 'Install Ruby dependencies'
task :install do
  puts '▶️ Installing dependencies...'.blue
  sh 'bundle install'
  puts '✅ Dependencies installed'.green
end

##
# Check for duplicate syslog input configurations
#
# Scans deployed config files for multiple instances of port 5140
# configuration, which would cause conflicts. Suggests fixes if
# duplicates are found.
desc 'Fix duplicate input configuration'
task :fix_duplicates do
  puts '▶️ Checking for duplicate input configurations...'.blue

  # For remote, use grep to find duplicates
  if remote_enabled?
    puts 'Scanning remote config files for port 5140...'.yellow
    begin
      # Use grep to find files with port 5140, count them
      result = `ssh #{LOGSTASH_HOST} 'grep -l "port.*5140" " \
               "#{LOGSTASH_CONF_DIR}/*.conf 2>/dev/null' 2>&1`
      duplicate_files = result.split("\n")

      if duplicate_files.length > 1
        puts "⚠️️ Found #{duplicate_files.length} files with port 5140:".yellow
        duplicate_files.each { |f| puts "  - #{f}" }
        puts ''
        puts 'To fix: Keep only one input file or use different ports'.yellow
      else
        puts '✅ No duplicates found'.green
      end
    rescue StandardError => e
      puts "⚠️️ Could not check for duplicates: #{e.message}".yellow
    end
  else
    # Local check
    duplicate_files = []
    Dir.glob("#{LOGSTASH_CONF_DIR}/*.conf").each do |file|
      duplicate_files << file if File.read(file).match?(/port\s*=>\s*5140/)
    end

    if duplicate_files.length > 1
      puts "⚠️️ Found #{duplicate_files.length} files with port 5140:".yellow
      duplicate_files.each { |f| puts "  - #{f}" }
      puts ''
      puts 'To fix: Keep only one input file or use different ports'.yellow
    else
      puts '✅ No duplicates found'.green
    end
  end
end
