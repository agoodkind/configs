#!/usr/bin/env bash
# Generated by Ansible - DO NOT EDIT MANUALLY
#
# MWAN Watchdog - Auto-rollback monitor for MWAN deployments
#
# Monitors internet connectivity after MWAN config deploys and automatically
# rolls back to last-known-good snapshot if connectivity fails.
#
# Continuous monitoring with automatic rollback during deploy windows.
#

set -euo pipefail

# Source environment (provided by systemd or standalone)
if [[ -r /etc/mwan-watchdog/watchdog.env ]]; then
    # shellcheck disable=SC1091
    . /etc/mwan-watchdog/watchdog.env
fi

# Configuration (from environment file)
readonly MWAN_VMID="${MWAN_VMID:-113}"
readonly DEPLOY_WINDOW_MINUTES="${DEPLOY_WINDOW_MINUTES:-30}"
readonly CONNECTIVITY_TIMEOUT_SECONDS="${CONNECTIVITY_TIMEOUT_SECONDS:-60}"
readonly ISP_TEST_PINGS="${ISP_TEST_PINGS:-10}"
readonly ISP_TEST_THRESHOLD="${ISP_TEST_THRESHOLD:-3}"
readonly LOG_FILE="${LOG_FILE:-/var/log/mwan-watchdog.log}"
readonly ROLLBACK_STATE_FILE="${ROLLBACK_STATE_FILE:-/var/run/mwan-rollback.state}"
readonly ALERT_EMAIL="${ALERT_EMAIL:-root@localhost}"
readonly FALLBACK_IFACE="${FALLBACK_IFACE:-enmbrains0}"

# Log function
log() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [mwan-watchdog] $*" | tee -a "$LOG_FILE"
}

# Error log function
error() {
    echo "$(date '+%Y-%m-%d %H:%M:%S') [mwan-watchdog] ERROR: $*" >&2
    echo "$(date '+%Y-%m-%d %H:%M:%S') [mwan-watchdog] ERROR: $*" >> "$LOG_FILE"
}

# Check if recent deploy happened
# Returns: 0 and sets DEPLOY_TS if recent, 1 if none/old
check_recent_deploy() {
    log "Checking for recent deploy..."

    # Read deploy timestamp via QEMU guest agent (network-independent)
    local deploy_ts result
    result=$(qm guest exec "$MWAN_VMID" -- cat /var/run/mwan-last-deploy 2>/dev/null || echo '{"exitcode": 1}')
    deploy_ts=$(echo "$result" | jq -r '."out-data"' 2>/dev/null | tr -d '\n' || echo "")

    # Handle missing file or invalid data
    if [[ -z "$deploy_ts" ]] || [[ "$deploy_ts" == "null" ]] || ! [[ "$deploy_ts" =~ ^[0-9]+$ ]]; then
        log "No valid deploy timestamp found - monitoring only (no rollback)"
        return 1
    fi

    local now age_minutes
    now=$(date +%s)
    age_minutes=$(((now - deploy_ts) / 60))

    if [[ "$age_minutes" -gt "$DEPLOY_WINDOW_MINUTES" ]]; then
        log "Deploy timestamp is $age_minutes minutes old (>$DEPLOY_WINDOW_MINUTES) - outside window, monitoring only"
        return 1
    fi

    log "Recent deploy detected ($age_minutes minutes ago) - rollback enabled"
    DEPLOY_TS="$deploy_ts"
    return 0
}

# Test connectivity from inside MWAN VM (for logging/diagnosis)
test_mwan_vm_connectivity() {
    log "Testing connectivity from MWAN VM..."

    # Test IPv6
    local result
    result=$(qm guest exec "$MWAN_VMID" -- ping6 -c 2 -W 3 2606:4700:4700::1111 2>/dev/null | jq -r '.exitcode' || echo 1)
    if [[ "$result" == "0" ]]; then
        log "MWAN VM: IPv6 OK"
        return 0
    fi

    # Test IPv4
    result=$(qm guest exec "$MWAN_VMID" -- ping -c 2 -W 3 1.1.1.1 2>/dev/null | jq -r '.exitcode' || echo 1)
    if [[ "$result" == "0" ]]; then
        log "MWAN VM: IPv4 OK"
        return 0
    fi

    log "MWAN VM: connectivity FAILED"
    return 1
}

# Test main connectivity (via normal route through MWAN)
# Falls back to qm guest exec if direct access fails
test_main_connectivity() {
    log "Testing main connectivity..."

    # Try IPv6 first (preferred), then IPv4
    if ping6 -c 2 -W 3 2606:4700:4700::1111 >/dev/null 2>&1; then
        log "Main connectivity (Proxmox): IPv6 OK"
        test_mwan_vm_connectivity  # Also test from inside VM for logs
        return 0
    elif ping -c 2 -W 3 1.1.1.1 >/dev/null 2>&1; then
        log "Main connectivity (Proxmox): IPv4 OK"
        test_mwan_vm_connectivity  # Also test from inside VM for logs
        return 0
    else
        log "Main connectivity (Proxmox): FAILED - testing from VM..."
        # Fallback: test from inside VM using qm guest exec
        if test_mwan_vm_connectivity; then
            log "MWAN VM has connectivity but Proxmox cannot reach internet through it"
            return 1  # Still report failure since routing through MWAN is broken
        fi
        log "Main connectivity: FAILED (both Proxmox and MWAN VM)"
        return 1
    fi
}

# Test ISP connectivity via fallback interface (isolated from MWAN)
test_isp_via_fallback() {
    local iface="$FALLBACK_IFACE"
    log "Testing ISP connectivity via $iface interface..."

    # Ping test: 10 pings, success if 3+ respond (30% threshold handles packet loss)
    check_ping() {
        local target="$1"
        local received
        received=$(ping6 -c "$ISP_TEST_PINGS" -W 2 -I "$iface" "$target" 2>/dev/null | grep -c 'bytes from' || echo 0)
        [[ "$received" -ge "$ISP_TEST_THRESHOLD" ]]
    }

    # Curl test: HTTP request via mbrains (backup if ICMP blocked)
    check_curl() {
        local url="$1"
        local code
        code=$(curl -6 --interface "$iface" --connect-timeout 5 --max-time 10 -s -o /dev/null -w '%{http_code}' "$url" 2>/dev/null || echo 0)
        # Any 2xx or 3xx response = success
        [[ "$code" -ge 200 ]] && [[ "$code" -lt 400 ]]
    }

    # Try multiple methods - any one passing = ISP is up
    if check_ping "2606:4700:4700::1111"; then
        log "ISP connectivity: UP (ping6 Cloudflare)"
        return 0
    elif check_ping "2001:4860:4860::8888"; then
        log "ISP connectivity: UP (ping6 Google)"
        return 0
    elif check_curl "https://cloudflare.com"; then
        log "ISP connectivity: UP (curl Cloudflare)"
        return 0
    elif check_curl "https://google.com"; then
        log "ISP connectivity: UP (curl Google)"
        return 0
    else
        log "ISP connectivity: DOWN or UNREACHABLE"
        return 1
    fi
}

# Check if rollback already happened for this deploy cycle
check_rollback_already_done() {
    local deploy_ts="$1"

    if [[ ! -f "$ROLLBACK_STATE_FILE" ]]; then
        log "No rollback state file - rollback not done yet"
        return 1
    fi

    local state_deploy_ts rollback_done
    state_deploy_ts=$(grep '^deploy_timestamp=' "$ROLLBACK_STATE_FILE" | cut -d'=' -f2 || echo "")
    rollback_done=$(grep '^rollback_done=' "$ROLLBACK_STATE_FILE" | cut -d'=' -f2 || echo "false")

    if [[ "$state_deploy_ts" != "$deploy_ts" ]]; then
        log "Rollback state is for different deploy cycle - reset needed"
        return 1
    fi

    if [[ "$rollback_done" == "true" ]]; then
        log "Rollback already done for this deploy cycle"
        return 0
    fi

    log "Rollback not yet done for this deploy cycle"
    return 1
}

# Check if last-known-good snapshot exists
check_last_known_good_exists() {
    if qm listsnapshot "$MWAN_VMID" | grep -q 'last-known-good'; then
        log "last-known-good snapshot exists"
        return 0
    else
        log "last-known-good snapshot NOT found"
        return 1
    fi
}

# Perform rollback to last-known-good
perform_rollback() {
    local deploy_ts="$1"

    log "INITIATING ROLLBACK TO LAST-KNOWN-GOOD"

    # Stop VM gracefully
    log "Stopping MWAN VM..."
    qm stop "$MWAN_VMID" --timeout 30

    # Rollback to last-known-good
    log "Rolling back to last-known-good snapshot..."
    qm rollback "$MWAN_VMID" last-known-good

    # Start VM
    log "Starting MWAN VM..."
    qm start "$MWAN_VMID"

    # Send email notification
    log "Sending rollback notification email..."
    /opt/scripts/send-email --http \
        -t "$ALERT_EMAIL" \
        -s "MWAN Auto-Rollback Triggered" \
        -m "Rolled back to last-known-good snapshot at $(date)
Reason: Deploy broke connectivity
Deploy timestamp: $deploy_ts" \
        -k "$SMTP2GO_API_KEY" || error "Failed to send email"

    # Mark rollback complete (prevent re-rollback)
    log "Marking rollback complete..."
    cat > "$ROLLBACK_STATE_FILE" <<EOF
deploy_timestamp=$deploy_ts
rollback_done=true
rollback_timestamp=$(date +%s)
EOF

    log "ROLLBACK COMPLETE"
}

# Send connectivity alert email
send_alert_email() {
    local reason="$1"
    log "Sending connectivity alert email..."
    /opt/scripts/send-email --http \
        -t "$ALERT_EMAIL" \
        -s "MWAN Connectivity Alert" \
        -m "MWAN connectivity issue detected at $(date)
Reason: $reason
No recent deploy - manual intervention required" \
        -k "$SMTP2GO_API_KEY" || error "Failed to send email"
}

# Main logic
main() {
    log "Starting MWAN watchdog - continuous monitoring mode"

    # Check for recent deploy (determines if rollback is enabled)
    DEPLOY_TS=""
    local rollback_enabled=false
    if check_recent_deploy; then
        rollback_enabled=true
        log "Rollback enabled for this monitoring session (deploy_ts=$DEPLOY_TS)"
    else
        log "Rollback disabled - will alert only on connectivity issues"
    fi

    # Step 1: Test main connectivity
    local main_down_start=0
    local consecutive_failures=0

    while true; do
        if test_main_connectivity; then
            if [[ $consecutive_failures -gt 0 ]]; then
                log "Main connectivity restored after $consecutive_failures failures"
            fi
            consecutive_failures=0
            main_down_start=0
            sleep 30  # Check every 30s when healthy
            continue
        fi

        # Main connectivity failed
        ((consecutive_failures++))
        if [[ $main_down_start -eq 0 ]]; then
            main_down_start=$(date +%s)
            log "Main connectivity failed - starting $CONNECTIVITY_TIMEOUT_SECONDS second timeout"
        fi

        local down_duration=$(( $(date +%s) - main_down_start ))
        if [[ $down_duration -lt $CONNECTIVITY_TIMEOUT_SECONDS ]]; then
            log "Main connectivity still down (${down_duration}s / ${CONNECTIVITY_TIMEOUT_SECONDS}s timeout)"
            sleep 10
            continue
        fi

        # Step 2: Main connectivity failed for timeout period - check ISP
        log "Main connectivity failed for ${CONNECTIVITY_TIMEOUT_SECONDS}s - checking ISP via $FALLBACK_IFACE..."

        if ! test_isp_via_fallback; then
            log "ISP is also down via $FALLBACK_IFACE - real outage, not rolling back"
            sleep 60  # Wait longer during real outages
            continue
        fi

        # Step 3: ISP is up, main is down - check what to do
        log "ISP is up but main connectivity is down - determining action..."

        if [[ "$rollback_enabled" == "false" ]]; then
            log "No recent deploy - sending alert email instead of rollback"
            send_alert_email "Main connectivity down but ISP up"
            sleep 300  # Wait 5 minutes before re-alerting
            continue
        fi

        # Rollback mode - check rollback conditions
        log "Recent deploy detected - checking rollback conditions..."

        if check_rollback_already_done "$DEPLOY_TS"; then
            log "Rollback already done for this deploy cycle - skipping"
            sleep 60
            continue
        fi

        if ! check_last_known_good_exists; then
            log "No last-known-good snapshot exists - cannot rollback, sending alert"
            send_alert_email "Cannot rollback - no last-known-good snapshot"
            sleep 60
            continue
        fi

        # All conditions met - perform rollback
        perform_rollback "$DEPLOY_TS"

        # After rollback, disable rollback mode and continue monitoring
        rollback_enabled=false
        sleep 120
    done
}

# Run main function
main "$@"
