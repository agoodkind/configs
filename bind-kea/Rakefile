# frozen_string_literal: true

require 'dotenv'
require 'fileutils'
require 'json'
require 'base64'
require 'shellwords'
require_relative '../lib/rake_common'

# Load .env from current directory and parent directory
Dotenv.load('.env', '../.env')

# Include common helpers
# rubocop:disable Style/MixinUsage
extend RakeCommon
# rubocop:enable Style/MixinUsage

KEA_HOST = ENV.fetch('KEA_HOST', nil)
ROUTER_USER = ENV.fetch('ROUTER_USER', 'agoodkind')
ROUTER_HOST = ENV.fetch('ROUTER_HOST', '10.250.0.1')
CONFIG_FILE = 'kea/kea-dhcp-ddns.conf'
DEST_PATH = '/etc/kea/kea-dhcp-ddns.conf'

##
# Execute command on Kea host and return output
#
# @param args [Array] command and arguments
# @return [String] command output
def ssh_kea(*)
  ssh_exec(KEA_HOST, *)
end

##
# Execute command on Kea host with error handling
#
# @param args [Array] command and arguments
# @return [void]
def ssh_kea_sh(*)
  ssh_exec_sh(KEA_HOST, *)
end

##
# Execute command on router and return output
#
# @param args [Array] command and arguments
# @return [String] command output
def ssh_router(*)
  ssh_exec("#{ROUTER_USER}@#{ROUTER_HOST}", *)
end

##
# Execute command on router with error handling
#
# @param args [Array] command and arguments
# @return [void]
def ssh_router_sh(*)
  ssh_exec_sh("#{ROUTER_USER}@#{ROUTER_HOST}", *)
end

##
# Create temp file path on remote host
#
# @return [String] path to temp file
def create_temp_file
  '/tmp/kea-dhcp-ddns.conf.new'
end

##
# Push configuration file to Kea host
#
# @param temp_file [String] destination path on Kea host
# @return [void]
def push_to_kea(temp_file)
  deploy_file_to_host(CONFIG_FILE, KEA_HOST, temp_file, owner: '_kea:_kea', mode: '640')
end

##
# Test configuration file on Kea host
#
# @param temp_file [String] path to config file on Kea host
# @return [void]
def test_config(temp_file)
  if verbose?
    ssh_kea_sh('sudo', '-u', '_kea', '/sbin/kea-dhcp-ddns', '-t', temp_file)
  else
    output = ssh_kea('sudo', '-u', '_kea', '/sbin/kea-dhcp-ddns', '-t', temp_file)
    puts "   #{output.split("\n").last}" if output.include?('success')
  end
end

##
# Backup existing config and install new one
#
# @param temp_file [String] path to new config file on Kea host
# @param timestamp [String] timestamp for backup filename
# @return [void]
def backup_and_install(temp_file, timestamp)
  begin
    ssh_kea_sh('sudo', 'test', '-f', DEST_PATH)
    ssh_kea_sh('sudo', 'cp', DEST_PATH, "#{DEST_PATH}.backup.#{timestamp}")
  rescue StandardError
    # File doesn't exist, skip backup
  end

  ssh_kea_sh('sudo', 'mv', temp_file, DEST_PATH)
  ssh_kea_sh('sudo', 'chown', '_kea:_kea', DEST_PATH)
  ssh_kea_sh('sudo', 'chmod', '640', DEST_PATH)
end

##
# Restart kea-dhcp-ddns service
#
# @return [void]
def restart_kea
  ssh_kea_sh('sudo', 'systemctl', 'restart', 'isc-kea-dhcp-ddns-server')
end

##
# Upload config file to router home directory
#
# @param config_file [String] local config file path
# @return [void]
def router_upload(config_file)
  scp_to_host(config_file, "#{ROUTER_USER}@#{ROUTER_HOST}", '~/')
end

##
# Test config file on router
#
# @param binary [String] full path to kea binary
# @param config_file [String] config file name in home directory
# @return [void]
def router_test(binary, config_file)
  ssh_router_sh('sudo', binary, '-t', "$HOME/#{config_file}")
end

##
# Backup and install config on router
#
# @param config_file [String] config file name
# @param dest_path [String] destination path
# @return [void]
def router_install(config_file, dest_path)
  timestamp = Time.now.strftime('%Y%m%d_%H%M%S')

  # Backup existing file if it exists
  begin
    ssh_router_sh('sudo', 'test', '-f', dest_path)
    ssh_router_sh('sudo', 'cp', dest_path, "#{dest_path}.backup.#{timestamp}")
  rescue StandardError
    # File doesn't exist, skip backup
  end

  # Install new file
  ssh_router_sh('sudo', 'mv', "$HOME/#{config_file}", dest_path)
  ssh_router_sh('sudo', 'chown', 'root:wheel', dest_path)
  ssh_router_sh('sudo', 'chmod', '640', dest_path)
end

KEA_CTRL_URL = 'http://127.0.0.1:8000/'

##
# Call Kea Control Agent on the router (via SSH) and return parsed JSON.
#
# @param payload [Hash] Kea control agent JSON payload
# @return [Array<Hash>] response array from Kea control agent
def kea_api(payload)
  json = JSON.generate(payload)
  b64 = Base64.strict_encode64(json)

  pipeline = "echo #{b64.shellescape} | base64 -d | " \
             "curl -sS -X POST -H 'Content-Type: application/json' --data-binary @- #{KEA_CTRL_URL.shellescape}"

  # IMPORTANT: ssh concatenates arguments with spaces.  We must pass the whole
  # pipeline as a single remote argument to keep it intact for /bin/sh -lc.
  raw = ssh_router("sudo /bin/sh -lc #{pipeline.shellescape}")

  JSON.parse(raw)
end

def kea_ok?(resp)
  resp.is_a?(Array) && resp[0].is_a?(Hash) && resp[0]['result'] == 0
end

def kea_leases(resp)
  return [] unless kea_ok?(resp)

  leases = resp.dig(0, 'arguments', 'leases')
  leases.is_a?(Array) ? leases : []
end

def kea_single_lease(resp)
  return nil unless kea_ok?(resp)

  lease = resp[0]['arguments']
  lease.is_a?(Hash) ? lease : nil
end

def load_reservations4(subnet_id)
  data = JSON.parse(File.read('kea/kea-dhcp4.conf'))
  subnet = data.fetch('Dhcp4').fetch('subnet4').find { |s| s['id'] == subnet_id }
  raise "subnet4 id=#{subnet_id} not found" if subnet.nil?

  (subnet['reservations'] || []).map do |r|
    {
      hwaddr: (r['hw-address'] || '').downcase,
      ip: r['ip-address'],
      hostname: r['hostname']
    }
  end
end

def load_reservations6(subnet_id)
  data = JSON.parse(File.read('kea/kea-dhcp6.conf'))
  subnet = data.fetch('Dhcp6').fetch('subnet6').find { |s| s['id'] == subnet_id }
  raise "subnet6 id=#{subnet_id} not found" if subnet.nil?

  (subnet['reservations'] || []).map do |r|
    ips = r['ip-addresses'] || []
    {
      duid: (r['duid'] || '').downcase,
      ip: ips[0],
      hostname: r['hostname']
    }
  end
end

namespace :router do
  desc 'Push kea-dhcp4.conf to router'
  task :push_dhcp4 do
    puts '‚ñ∂Ô∏è  Uploading DHCP4 config...'
    router_upload('kea/kea-dhcp4.conf')
    puts '‚úÖ Config uploaded'
  end

  desc 'Test kea-dhcp4.conf on router'
  task :test_dhcp4 do
    puts '‚ñ∂Ô∏è  Testing DHCP4 config...'
    router_test('/usr/local/sbin/kea-dhcp4', 'kea-dhcp4.conf')
    puts '‚úÖ Configuration valid'
  end

  desc 'Install kea-dhcp4.conf on router'
  task :install_dhcp4 do
    puts '‚ñ∂Ô∏è  Installing DHCP4 config...'
    router_install('kea-dhcp4.conf', '/usr/local/etc/kea/kea-dhcp4.conf')
    puts '‚úÖ Configuration installed'
  end

  desc 'Deploy kea-dhcp4.conf to router'
  task deploy_dhcp4: %i[push_dhcp4 test_dhcp4 install_dhcp4 restart]

  desc 'Push kea-dhcp6.conf to router'
  task :push_dhcp6 do
    puts '‚ñ∂Ô∏è  Uploading DHCP6 config...'
    router_upload('kea/kea-dhcp6.conf')
    puts '‚úÖ Config uploaded'
  end

  desc 'Test kea-dhcp6.conf on router'
  task :test_dhcp6 do
    puts '‚ñ∂Ô∏è  Testing DHCP6 config...'
    router_test('/usr/local/sbin/kea-dhcp6', 'kea-dhcp6.conf')
    puts '‚úÖ Configuration valid'
  end

  desc 'Install kea-dhcp6.conf on router'
  task :install_dhcp6 do
    puts '‚ñ∂Ô∏è  Installing DHCP6 config...'
    router_install('kea-dhcp6.conf', '/usr/local/etc/kea/kea-dhcp6.conf')
    puts '‚úÖ Configuration installed'
  end

  desc 'Deploy kea-dhcp6.conf to router'
  task deploy_dhcp6: %i[push_dhcp6 test_dhcp6 install_dhcp6 restart]

  desc 'Restart Kea DHCP services on router'
  task :restart do
    puts '‚ñ∂Ô∏è  Restarting Kea services...'
    ssh_router_sh('sudo', 'configctl', 'kea', 'restart')
    puts '‚úÖ Services restarted'
  end

  desc 'Deploy all Kea configs to router'
  task deploy: %i[deploy_dhcp4 deploy_dhcp6 restart] do
    puts ''
    puts '‚úÖ Router deployment complete'
  end
end

namespace :lease do
  desc 'Delete DHCPv4 lease by IP on router (example: rake lease:delete4_by_ip[10.250.0.24])'
  task :delete4_by_ip, [:ip] do |_t, args|
    ip = args[:ip].to_s.strip
    raise 'ip is required' if ip.empty?

    resp = kea_api(
      'command' => 'lease4-del',
      'service' => ['dhcp4'],
      'arguments' => { 'ip-address' => ip }
    )
    puts JSON.pretty_generate(resp)
  end

  desc 'Delete DHCPv6 lease by IP on router (example: rake lease:delete6_by_ip[3d06:bad:b01::28])'
  task :delete6_by_ip, [:ip] do |_t, args|
    ip = args[:ip].to_s.strip
    raise 'ip is required' if ip.empty?

    resp = kea_api(
      'command' => 'lease6-del',
      'service' => ['dhcp6'],
      'arguments' => { 'ip-address' => ip }
    )
    puts JSON.pretty_generate(resp)
  end

  desc 'Enforce DHCPv4+DHCPv6 reservations by deleting conflicting leases (default subnet id: 10)'
  task :enforce_reservations, [:subnet_id] do |_t, args|
    subnet_id = (args[:subnet_id] || '10').to_i

    puts "‚ñ∂Ô∏è  Enforcing reservations for subnet id #{subnet_id} (v4 + v6)"

    # DHCPv4
    r4 = load_reservations4(subnet_id)
    by_hw = r4.to_h { |r| [r[:hwaddr], r] }
    by_ip = r4.to_h { |r| [r[:ip], r] }

    # 1) Remove extra leases per hwaddr that aren't the reserved IP.
    by_hw.each_value do |r|
      next if r[:hwaddr].to_s.empty? || r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease4-get-by-hw-address',
        'service' => ['dhcp4'],
        'arguments' => { 'hw-address' => r[:hwaddr] }
      )
      kea_leases(resp).each do |lease|
        ip = lease['ip-address']
        next if ip == r[:ip]

        puts "üßπ DHCP4: deleting extra lease #{ip} for #{r[:hostname]} (#{r[:hwaddr]})"
        kea_api(
          'command' => 'lease4-del',
          'service' => ['dhcp4'],
          'arguments' => { 'ip-address' => ip }
        )
      end
    end

    # 2) Ensure reserved IP isn't held by the wrong hwaddr.
    by_ip.each_value do |r|
      next if r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease4-get',
        'service' => ['dhcp4'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
      lease = kea_single_lease(resp)
      next if lease.nil?

      got = lease['hw-address'].to_s.downcase
      next if got.empty? || got == r[:hwaddr]

      puts "üßπ DHCP4: deleting conflicting lease #{r[:ip]} held by #{got} (wanted #{r[:hwaddr]} #{r[:hostname]})"
      kea_api(
        'command' => 'lease4-del',
        'service' => ['dhcp4'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
    end

    # DHCPv6
    r6 = load_reservations6(subnet_id)
    by_duid = r6.to_h { |r| [r[:duid], r] }
    by_ip6 = r6.to_h { |r| [r[:ip], r] }

    # 1) Remove extra leases per DUID that aren't the reserved IP.
    by_duid.each_value do |r|
      next if r[:duid].to_s.empty? || r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease6-get-by-duid',
        'service' => ['dhcp6'],
        'arguments' => { 'duid' => r[:duid] }
      )
      kea_leases(resp).each do |lease|
        ip = lease['ip-address']
        next if ip == r[:ip]

        puts "üßπ DHCP6: deleting extra lease #{ip} for #{r[:hostname]} (#{r[:duid]})"
        kea_api(
          'command' => 'lease6-del',
          'service' => ['dhcp6'],
          'arguments' => { 'ip-address' => ip }
        )
      end
    end

    # 2) Ensure reserved IP isn't held by the wrong DUID.
    by_ip6.each_value do |r|
      next if r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease6-get',
        'service' => ['dhcp6'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
      lease = kea_single_lease(resp)
      next if lease.nil?

      got = lease['duid'].to_s.downcase
      next if got.empty? || got == r[:duid]

      puts "üßπ DHCP6: deleting conflicting lease #{r[:ip]} held by #{got} (wanted #{r[:duid]} #{r[:hostname]})"
      kea_api(
        'command' => 'lease6-del',
        'service' => ['dhcp6'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
    end

    puts '‚úÖ Reservation enforcement completed'
    puts 'Next: renew clients (e.g. restart networkd or networkctl renew eth0) on affected containers.'
  end
end

namespace :bind do
  desc 'List all DNS records'
  task :list_records do
    puts '‚ñ∂Ô∏è  Fetching DNS records...'
    puts ''

    # Dump current zone data
    ssh_kea_sh('sudo', 'rndc', 'dumpdb', '-all') if verbose?
    sleep 1 # Wait for dump to complete

    # Read the dump file directly
    raw_records = ssh_kea('sudo', 'cat', '/var/cache/bind/named_dump.db')

    if raw_records.empty?
      puts '   No records found or dump file does not exist'
    else
      # Parse and filter records in Ruby
      useful_types = %w[A AAAA CNAME TXT NS SOA PTR DHCID]
      records_list = []

      raw_records.split("\n").each do |line|
        # Skip comments, empty lines, and $DATE lines
        next if line.start_with?(';', '$') || line.strip.empty?

        parts = line.split
        next if parts.length < 4

        domain = parts[0]
        ttl = parts[1].to_i
        record_type = parts[3]
        value = parts[4..].join(' ')

        # Filter: only show useful record types, skip RRSIG and root servers
        next unless useful_types.include?(record_type)
        next if line.include?('RRSIG') || line.include?('root-servers')

        records_list << { domain: domain, ttl: ttl, type: record_type, value: value }
      end

      # Print table header
      puts "‚îå#{'‚îÄ' * 52}‚î¨#{'‚îÄ' * 10}‚î¨#{'‚îÄ' * 8}‚î¨#{'‚îÄ' * 50}‚îê"
      printf "‚îÇ %-50s ‚îÇ %-8s ‚îÇ %-6s ‚îÇ %-48s ‚îÇ\n", 'Domain', 'TTL', 'Type', 'Value'
      puts "‚îú#{'‚îÄ' * 52}‚îº#{'‚îÄ' * 10}‚îº#{'‚îÄ' * 8}‚îº#{'‚îÄ' * 50}‚î§"

      # Print records
      current_domain = nil
      records_list.each do |record|
        # Convert TTL to human readable
        ttl_human = if record[:ttl] >= 86_400
                      "#{record[:ttl] / 86_400}d"
                    elsif record[:ttl] >= 3600
                      "#{record[:ttl] / 3600}h"
                    elsif record[:ttl] >= 60
                      "#{record[:ttl] / 60}m"
                    else
                      "#{record[:ttl]}s"
                    end

        # Add separator between different domains
        puts "‚îú#{'‚îÄ' * 52}‚îº#{'‚îÄ' * 10}‚îº#{'‚îÄ' * 8}‚îº#{'‚îÄ' * 50}‚î§" if current_domain && current_domain != record[:domain]

        # Truncate long values
        display_value = record[:value].length > 48 ? "#{record[:value][0..44]}..." : record[:value]

        domain_display = record[:domain] == current_domain ? '' : record[:domain]
        current_domain = record[:domain]

        printf "‚îÇ %-50s ‚îÇ %-8s ‚îÇ %-6s ‚îÇ %-48s ‚îÇ\n", domain_display, ttl_human, record[:type], display_value
      end

      # Print table footer
      puts "‚îî#{'‚îÄ' * 52}‚î¥#{'‚îÄ' * 10}‚î¥#{'‚îÄ' * 8}‚î¥#{'‚îÄ' * 50}‚îò"
    end

    puts ''
    puts '‚úÖ Records listed'
  end

  desc 'Show BIND status'
  task :status do
    puts '‚ñ∂Ô∏è  Checking BIND status...'
    ssh_kea_sh('sudo', 'rndc', 'status')
    puts '‚úÖ Status retrieved'
  end
end

namespace :kea do
  desc 'Push kea-dhcp-ddns.conf to Kea host'
  task :push do
    temp_file = create_temp_file
    puts '‚ñ∂Ô∏è  Pushing config to Kea host...'
    puts "   Target: #{temp_file}" if verbose?
    push_to_kea(temp_file)
    puts '‚úÖ Config pushed'
  end

  desc 'Test kea-dhcp-ddns.conf on Kea host'
  task :test do
    temp_file = create_temp_file
    puts '‚ñ∂Ô∏è  Testing configuration...'
    puts "   File: #{temp_file}" if verbose?
    test_config(temp_file)
    puts '‚úÖ Configuration valid'
  end

  desc 'Backup and install kea-dhcp-ddns.conf'
  task :install do
    temp_file = create_temp_file
    timestamp = Time.now.strftime('%Y%m%d_%H%M%S')
    puts '‚ñ∂Ô∏è  Backing up and installing...'
    puts "   Backup: #{DEST_PATH}.backup.#{timestamp}" if verbose?
    backup_and_install(temp_file, timestamp)
    puts '‚úÖ Configuration installed'
  end

  desc 'Restart kea-dhcp-ddns service'
  task :restart do
    puts '‚ñ∂Ô∏è  Restarting service...'
    restart_kea
    puts '‚úÖ Service restarted'
  end

  desc 'Deploy kea-dhcp-ddns.conf to Kea host'
  task deploy: %i[push test install restart] do
    puts ''
    puts '‚úÖ Deployment complete'
  end
end

namespace :lease do
  ##
  # Execute kea-ctrl-agent command on router
  #
  # @param command [String] command name (e.g., "lease4-del")
  # @param arguments [Hash] command arguments
  # @return [Hash] parsed JSON response
  def kea_ctrl_command(command, arguments = {})
    payload = {
      command: command,
      service: ['dhcp4'],
      arguments: arguments
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    JSON.parse(output)
  rescue JSON::ParserError, StandardError => e
    puts "   Error: #{e.message}" if verbose?
    { 'result' => 1, 'text' => e.message }
  end

  desc 'Delete IPv4 lease by IP address'
  task :delete_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:delete_by_ip[10.250.0.10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting lease for IP #{ip_address}..."
    result = kea_ctrl_command('lease4-del', { 'ip-address' => ip_address })
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv4 lease by MAC address'
  task :delete_by_mac, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:delete_by_mac[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting lease for MAC #{mac_address} in subnet #{subnet_id}..."
    result = kea_ctrl_command('lease4-del', {
                                'subnet-id' => subnet_id.to_i,
                                'identifier-type' => 'hw-address',
                                'identifier' => mac_address
                              })
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv4 lease by client-id'
  task :delete_by_client_id, [:client_id, :subnet_id] do |_t, args|
    client_id = args[:client_id]
    subnet_id = args[:subnet_id] || '10'

    if client_id.nil? || client_id.empty?
      puts '‚ùå Error: Client ID required'
      puts '   Usage: rake lease:delete_by_client_id[ff:b2:86:34:f1:00:02:00:00:ab:11:ca:fb:28:d4:fd:77:a5:93,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting lease for client-id #{client_id} in subnet #{subnet_id}..."
    result = kea_ctrl_command('lease4-del', {
                                'subnet-id' => subnet_id.to_i,
                                'identifier-type' => 'client-id',
                                'identifier' => client_id
                              })
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Get IPv4 lease by IP address'
  task :get_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:get_by_ip[10.250.0.10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Getting lease for IP #{ip_address}..."
    result = kea_ctrl_command('lease4-get', { 'ip-address' => ip_address })
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      lease = result['arguments']['leases'].first
      if lease
        puts '‚úÖ Lease found:'
        puts "   IP: #{lease['ip-address']}"
        puts "   MAC: #{lease['hw-address']}"
        puts "   Client-ID: #{lease['client-id'] || '(none)'}"
        puts "   Hostname: #{lease['hostname'] || '(none)'}"
        puts "   State: #{lease['state']}"
        puts "   Valid lifetime: #{lease['valid-lft']}s"
      else
        puts '‚ö†Ô∏è  No lease found'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'List all active IPv4 leases for a MAC address'
  task :list_by_mac, [:mac_address] do |_t, args|
    mac_address = args[:mac_address]
    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:list_by_mac[bc:24:11:1d:2c:0f]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Listing leases for MAC #{mac_address}..."
    result = kea_ctrl_command('lease4-get-all', {})
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select { |l| l['hw-address']&.downcase == mac_address.downcase }
      if leases.empty?
        puts "‚ö†Ô∏è  No leases found for MAC #{mac_address}"
      else
        puts "‚úÖ Found #{leases.length} lease(s):"
        leases.each do |lease|
          puts "   IP: #{lease['ip-address']}, State: #{lease['state']}, Client-ID: #{lease['client-id'] || '(none)'}"
        end
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Clean up conflicting leases for a MAC address (keeps only active lease)'
  task :cleanup_conflicts, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:cleanup_conflicts[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Cleaning up conflicting leases for MAC #{mac_address}..."
    result = kea_ctrl_command('lease4-get-all', {})
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['hw-address']&.downcase == mac_address.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "‚úÖ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "‚ö†Ô∏è  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']}..."
          del_result = kea_ctrl_command('lease4-del', { 'ip-address' => lease['ip-address'] })
          if del_result['result'] == 0
            puts "   ‚úÖ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ‚ö†Ô∏è  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '‚úÖ Cleanup complete'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv6 lease by IP address'
  task :delete6_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:delete6_by_ip[3d06:bad:b01::66]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting IPv6 lease for IP #{ip_address}..."
    payload = {
      command: 'lease6-del',
      service: ['dhcp6'],
      arguments: { 'ip-address' => ip_address }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Delete IPv6 lease by DUID'
  task :delete6_by_duid, [:duid, :subnet_id, :iaid] do |_t, args|
    duid = args[:duid]
    subnet_id = args[:subnet_id] || '10'
    iaid = args[:iaid] || '0'

    if duid.nil? || duid.empty?
      puts '‚ùå Error: DUID required'
      puts '   Usage: rake lease:delete6_by_duid[00:02:00:00:ab:11:87:e8:a6:25:af:c9:82:df,10,0]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting IPv6 lease for DUID #{duid} in subnet #{subnet_id}..."
    payload = {
      command: 'lease6-del',
      service: ['dhcp6'],
      arguments: {
        'subnet-id' => subnet_id.to_i,
        'identifier-type' => 'duid',
        'identifier' => duid,
        'iaid' => iaid.to_i
      }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Get IPv6 lease by IP address'
  task :get6_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:get6_by_ip[3d06:bad:b01::c]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Getting IPv6 lease for IP #{ip_address}..."
    payload = {
      command: 'lease6-get',
      service: ['dhcp6'],
      arguments: { 'ip-address' => ip_address }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      lease = result['arguments']['leases'].first
      if lease
        puts '‚úÖ Lease found:'
        puts "   IP: #{lease['ip-address']}"
        puts "   DUID: #{lease['duid']}"
        puts "   MAC: #{lease['hw-address'] || '(none)'}"
        puts "   Hostname: #{lease['hostname'] || '(none)'}"
        puts "   State: #{lease['state']}"
        puts "   IAID: #{lease['iaid']}"
      else
        puts '‚ö†Ô∏è  No lease found'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Clean up conflicting IPv6 leases for a DUID (keeps only active lease)'
  task :cleanup6_conflicts, [:duid, :subnet_id] do |_t, args|
    duid = args[:duid]
    subnet_id = args[:subnet_id] || '10'

    if duid.nil? || duid.empty?
      puts '‚ùå Error: DUID required'
      puts '   Usage: rake lease:cleanup6_conflicts[00:02:00:00:ab:11:87:e8:a6:25:af:c9:82:df,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Cleaning up conflicting IPv6 leases for DUID #{duid}..."
    payload = {
      command: 'lease6-get-all',
      service: ['dhcp6'],
      arguments: {}
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['duid']&.downcase == duid.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "‚úÖ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "‚ö†Ô∏è  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']}..."
          del_payload = {
            command: 'lease6-del',
            service: ['dhcp6'],
            arguments: { 'ip-address' => lease['ip-address'] }
          }.to_json
          del_output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                                  '-H', 'Content-Type: application/json',
                                  '-d', del_payload,
                                  'http://localhost:8080/api/servers/localhost/leases')
          del_result = JSON.parse(del_output)
          if del_result['result'] == 0
            puts "   ‚úÖ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ‚ö†Ô∏è  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '‚úÖ Cleanup complete'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Clean up conflicting IPv6 leases for a MAC address (keeps only active lease)'
  task :cleanup6_by_mac, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:cleanup6_by_mac[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Cleaning up conflicting IPv6 leases for MAC #{mac_address}..."
    payload = {
      command: 'lease6-get-all',
      service: ['dhcp6'],
      arguments: {}
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['hw-address']&.downcase == mac_address.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "‚úÖ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "‚ö†Ô∏è  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']} (DUID: #{lease['duid']})..."
          del_payload = {
            command: 'lease6-del',
            service: ['dhcp6'],
            arguments: { 'ip-address' => lease['ip-address'] }
          }.to_json
          del_output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                                  '-H', 'Content-Type: application/json',
                                  '-d', del_payload,
                                  'http://localhost:8080/api/servers/localhost/leases')
          del_result = JSON.parse(del_output)
          if del_result['result'] == 0
            puts "   ‚úÖ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ‚ö†Ô∏è  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '‚úÖ Cleanup complete'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end
end

desc 'Show available tasks'
task :help do
  puts 'Available tasks:'
  puts ''
  system('rake --tasks')
end

desc 'Default task - show available tasks'
task default: 'help'
