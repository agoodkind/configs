# frozen_string_literal: true

require 'dotenv'
require 'fileutils'
require_relative '../lib/rake_common'

# Load .env from current directory and parent directory
Dotenv.load('.env', '../.env')

# Include common helpers
# rubocop:disable Style/MixinUsage
extend RakeCommon
# rubocop:enable Style/MixinUsage

KEA_HOST = ENV.fetch('KEA_HOST', nil)
ROUTER_USER = ENV.fetch('ROUTER_USER', 'agoodkind')
ROUTER_HOST = ENV.fetch('ROUTER_HOST', '10.250.0.1')
CONFIG_FILE = 'kea/kea-dhcp-ddns.conf'
DEST_PATH = '/etc/kea/kea-dhcp-ddns.conf'

##
# Execute command on Kea host and return output
#
# @param args [Array] command and arguments
# @return [String] command output
def ssh_kea(*)
  ssh_exec(KEA_HOST, *)
end

##
# Execute command on Kea host with error handling
#
# @param args [Array] command and arguments
# @return [void]
def ssh_kea_sh(*)
  ssh_exec_sh(KEA_HOST, *)
end

##
# Execute command on router and return output
#
# @param args [Array] command and arguments
# @return [String] command output
def ssh_router(*)
  ssh_exec("#{ROUTER_USER}@#{ROUTER_HOST}", *)
end

##
# Execute command on router with error handling
#
# @param args [Array] command and arguments
# @return [void]
def ssh_router_sh(*)
  ssh_exec_sh("#{ROUTER_USER}@#{ROUTER_HOST}", *)
end

##
# Create temp file path on remote host
#
# @return [String] path to temp file
def create_temp_file
  '/tmp/kea-dhcp-ddns.conf.new'
end

##
# Push configuration file to Kea host
#
# @param temp_file [String] destination path on Kea host
# @return [void]
def push_to_kea(temp_file)
  deploy_file_to_host(CONFIG_FILE, KEA_HOST, temp_file, owner: '_kea:_kea', mode: '640')
end

##
# Test configuration file on Kea host
#
# @param temp_file [String] path to config file on Kea host
# @return [void]
def test_config(temp_file)
  if verbose?
    ssh_kea_sh('sudo', '-u', '_kea', '/sbin/kea-dhcp-ddns', '-t', temp_file)
  else
    output = ssh_kea('sudo', '-u', '_kea', '/sbin/kea-dhcp-ddns', '-t', temp_file)
    puts "   #{output.split("\n").last}" if output.include?('success')
  end
end

##
# Backup existing config and install new one
#
# @param temp_file [String] path to new config file on Kea host
# @param timestamp [String] timestamp for backup filename
# @return [void]
def backup_and_install(temp_file, timestamp)
  begin
    ssh_kea_sh('sudo', 'test', '-f', DEST_PATH)
    ssh_kea_sh('sudo', 'cp', DEST_PATH, "#{DEST_PATH}.backup.#{timestamp}")
  rescue StandardError
    # File doesn't exist, skip backup
  end

  ssh_kea_sh('sudo', 'mv', temp_file, DEST_PATH)
  ssh_kea_sh('sudo', 'chown', '_kea:_kea', DEST_PATH)
  ssh_kea_sh('sudo', 'chmod', '640', DEST_PATH)
end

##
# Restart kea-dhcp-ddns service
#
# @return [void]
def restart_kea
  ssh_kea_sh('sudo', 'systemctl', 'restart', 'isc-kea-dhcp-ddns-server')
end

##
# Upload config file to router home directory
#
# @param config_file [String] local config file path
# @return [void]
def router_upload(config_file)
  scp_to_host(config_file, "#{ROUTER_USER}@#{ROUTER_HOST}", '~/')
end

##
# Test config file on router
#
# @param binary [String] full path to kea binary
# @param config_file [String] config file name in home directory
# @return [void]
def router_test(binary, config_file)
  ssh_router_sh('sudo', binary, '-t', "$HOME/#{config_file}")
end

##
# Backup and install config on router
#
# @param config_file [String] config file name
# @param dest_path [String] destination path
# @return [void]
def router_install(config_file, dest_path)
  timestamp = Time.now.strftime('%Y%m%d_%H%M%S')

  # Backup existing file if it exists
  begin
    ssh_router_sh('sudo', 'test', '-f', dest_path)
    ssh_router_sh('sudo', 'cp', dest_path, "#{dest_path}.backup.#{timestamp}")
  rescue StandardError
    # File doesn't exist, skip backup
  end

  # Install new file
  ssh_router_sh('sudo', 'mv', "$HOME/#{config_file}", dest_path)
  ssh_router_sh('sudo', 'chown', 'root:wheel', dest_path)
  ssh_router_sh('sudo', 'chmod', '640', dest_path)
end

namespace :router do
  desc 'Push kea-dhcp4.conf to router'
  task :push_dhcp4 do
    puts '▶️  Uploading DHCP4 config...'
    router_upload('kea/kea-dhcp4.conf')
    puts '✅ Config uploaded'
  end

  desc 'Test kea-dhcp4.conf on router'
  task :test_dhcp4 do
    puts '▶️  Testing DHCP4 config...'
    router_test('/usr/local/sbin/kea-dhcp4', 'kea-dhcp4.conf')
    puts '✅ Configuration valid'
  end

  desc 'Install kea-dhcp4.conf on router'
  task :install_dhcp4 do
    puts '▶️  Installing DHCP4 config...'
    router_install('kea-dhcp4.conf', '/usr/local/etc/kea/kea-dhcp4.conf')
    puts '✅ Configuration installed'
  end

  desc 'Deploy kea-dhcp4.conf to router'
  task deploy_dhcp4: %i[push_dhcp4 test_dhcp4 install_dhcp4 restart]

  desc 'Push kea-dhcp6.conf to router'
  task :push_dhcp6 do
    puts '▶️  Uploading DHCP6 config...'
    router_upload('kea/kea-dhcp6.conf')
    puts '✅ Config uploaded'
  end

  desc 'Test kea-dhcp6.conf on router'
  task :test_dhcp6 do
    puts '▶️  Testing DHCP6 config...'
    router_test('/usr/local/sbin/kea-dhcp6', 'kea-dhcp6.conf')
    puts '✅ Configuration valid'
  end

  desc 'Install kea-dhcp6.conf on router'
  task :install_dhcp6 do
    puts '▶️  Installing DHCP6 config...'
    router_install('kea-dhcp6.conf', '/usr/local/etc/kea/kea-dhcp6.conf')
    puts '✅ Configuration installed'
  end

  desc 'Deploy kea-dhcp6.conf to router'
  task deploy_dhcp6: %i[push_dhcp6 test_dhcp6 install_dhcp6 restart]

  desc 'Restart Kea DHCP services on router'
  task :restart do
    puts '▶️  Restarting Kea services...'
    ssh_router_sh('sudo', 'configctl', 'kea', 'restart')
    puts '✅ Services restarted'
  end

  desc 'Deploy all Kea configs to router'
  task deploy: %i[deploy_dhcp4 deploy_dhcp6 restart] do
    puts ''
    puts '✅ Router deployment complete'
  end
end

namespace :bind do
  desc 'List all DNS records'
  task :list_records do
    puts '▶️  Fetching DNS records...'
    puts ''

    # Dump current zone data
    ssh_kea_sh('sudo', 'rndc', 'dumpdb', '-all') if verbose?
    sleep 1 # Wait for dump to complete

    # Read the dump file directly
    raw_records = ssh_kea('sudo', 'cat', '/var/cache/bind/named_dump.db')

    if raw_records.empty?
      puts '   No records found or dump file does not exist'
    else
      # Parse and filter records in Ruby
      useful_types = %w[A AAAA CNAME TXT NS SOA PTR DHCID]
      records_list = []

      raw_records.split("\n").each do |line|
        # Skip comments, empty lines, and $DATE lines
        next if line.start_with?(';', '$') || line.strip.empty?

        parts = line.split
        next if parts.length < 4

        domain = parts[0]
        ttl = parts[1].to_i
        record_type = parts[3]
        value = parts[4..].join(' ')

        # Filter: only show useful record types, skip RRSIG and root servers
        next unless useful_types.include?(record_type)
        next if line.include?('RRSIG') || line.include?('root-servers')

        records_list << { domain: domain, ttl: ttl, type: record_type, value: value }
      end

      # Print table header
      puts "┌#{'─' * 52}┬#{'─' * 10}┬#{'─' * 8}┬#{'─' * 50}┐"
      printf "│ %-50s │ %-8s │ %-6s │ %-48s │\n", 'Domain', 'TTL', 'Type', 'Value'
      puts "├#{'─' * 52}┼#{'─' * 10}┼#{'─' * 8}┼#{'─' * 50}┤"

      # Print records
      current_domain = nil
      records_list.each do |record|
        # Convert TTL to human readable
        ttl_human = if record[:ttl] >= 86_400
                      "#{record[:ttl] / 86_400}d"
                    elsif record[:ttl] >= 3600
                      "#{record[:ttl] / 3600}h"
                    elsif record[:ttl] >= 60
                      "#{record[:ttl] / 60}m"
                    else
                      "#{record[:ttl]}s"
                    end

        # Add separator between different domains
        puts "├#{'─' * 52}┼#{'─' * 10}┼#{'─' * 8}┼#{'─' * 50}┤" if current_domain && current_domain != record[:domain]

        # Truncate long values
        display_value = record[:value].length > 48 ? "#{record[:value][0..44]}..." : record[:value]

        domain_display = record[:domain] == current_domain ? '' : record[:domain]
        current_domain = record[:domain]

        printf "│ %-50s │ %-8s │ %-6s │ %-48s │\n", domain_display, ttl_human, record[:type], display_value
      end

      # Print table footer
      puts "└#{'─' * 52}┴#{'─' * 10}┴#{'─' * 8}┴#{'─' * 50}┘"
    end

    puts ''
    puts '✅ Records listed'
  end

  desc 'Show BIND status'
  task :status do
    puts '▶️  Checking BIND status...'
    ssh_kea_sh('sudo', 'rndc', 'status')
    puts '✅ Status retrieved'
  end
end

namespace :kea do
  desc 'Push kea-dhcp-ddns.conf to Kea host'
  task :push do
    temp_file = create_temp_file
    puts '▶️  Pushing config to Kea host...'
    puts "   Target: #{temp_file}" if verbose?
    push_to_kea(temp_file)
    puts '✅ Config pushed'
  end

  desc 'Test kea-dhcp-ddns.conf on Kea host'
  task :test do
    temp_file = create_temp_file
    puts '▶️  Testing configuration...'
    puts "   File: #{temp_file}" if verbose?
    test_config(temp_file)
    puts '✅ Configuration valid'
  end

  desc 'Backup and install kea-dhcp-ddns.conf'
  task :install do
    temp_file = create_temp_file
    timestamp = Time.now.strftime('%Y%m%d_%H%M%S')
    puts '▶️  Backing up and installing...'
    puts "   Backup: #{DEST_PATH}.backup.#{timestamp}" if verbose?
    backup_and_install(temp_file, timestamp)
    puts '✅ Configuration installed'
  end

  desc 'Restart kea-dhcp-ddns service'
  task :restart do
    puts '▶️  Restarting service...'
    restart_kea
    puts '✅ Service restarted'
  end

  desc 'Deploy kea-dhcp-ddns.conf to Kea host'
  task deploy: %i[push test install restart] do
    puts ''
    puts '✅ Deployment complete'
  end
end

namespace :lease do
  ##
  # Execute kea-ctrl-agent command on router
  #
  # @param command [String] command name (e.g., "lease4-del")
  # @param arguments [Hash] command arguments
  # @return [Hash] parsed JSON response
  def kea_ctrl_command(command, arguments = {})
    payload = {
      command: command,
      service: ['dhcp4'],
      arguments: arguments
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    JSON.parse(output)
  rescue JSON::ParserError, StandardError => e
    puts "   Error: #{e.message}" if verbose?
    { 'result' => 1, 'text' => e.message }
  end

  desc 'Delete IPv4 lease by IP address'
  task :delete_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '❌ Error: IP address required'
      puts '   Usage: rake lease:delete_by_ip[10.250.0.10]'
      exit 1
    end

    puts "▶️  Deleting lease for IP #{ip_address}..."
    result = kea_ctrl_command('lease4-del', { 'ip-address' => ip_address })
    if result['result'] == 0
      puts "✅ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "⚠️  No lease found: #{result['text']}"
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv4 lease by MAC address'
  task :delete_by_mac, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '❌ Error: MAC address required'
      puts '   Usage: rake lease:delete_by_mac[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "▶️  Deleting lease for MAC #{mac_address} in subnet #{subnet_id}..."
    result = kea_ctrl_command('lease4-del', {
                                'subnet-id' => subnet_id.to_i,
                                'identifier-type' => 'hw-address',
                                'identifier' => mac_address
                              })
    if result['result'] == 0
      puts "✅ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "⚠️  No lease found: #{result['text']}"
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv4 lease by client-id'
  task :delete_by_client_id, [:client_id, :subnet_id] do |_t, args|
    client_id = args[:client_id]
    subnet_id = args[:subnet_id] || '10'

    if client_id.nil? || client_id.empty?
      puts '❌ Error: Client ID required'
      puts '   Usage: rake lease:delete_by_client_id[ff:b2:86:34:f1:00:02:00:00:ab:11:ca:fb:28:d4:fd:77:a5:93,10]'
      exit 1
    end

    puts "▶️  Deleting lease for client-id #{client_id} in subnet #{subnet_id}..."
    result = kea_ctrl_command('lease4-del', {
                                'subnet-id' => subnet_id.to_i,
                                'identifier-type' => 'client-id',
                                'identifier' => client_id
                              })
    if result['result'] == 0
      puts "✅ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "⚠️  No lease found: #{result['text']}"
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Get IPv4 lease by IP address'
  task :get_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '❌ Error: IP address required'
      puts '   Usage: rake lease:get_by_ip[10.250.0.10]'
      exit 1
    end

    puts "▶️  Getting lease for IP #{ip_address}..."
    result = kea_ctrl_command('lease4-get', { 'ip-address' => ip_address })
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      lease = result['arguments']['leases'].first
      if lease
        puts '✅ Lease found:'
        puts "   IP: #{lease['ip-address']}"
        puts "   MAC: #{lease['hw-address']}"
        puts "   Client-ID: #{lease['client-id'] || '(none)'}"
        puts "   Hostname: #{lease['hostname'] || '(none)'}"
        puts "   State: #{lease['state']}"
        puts "   Valid lifetime: #{lease['valid-lft']}s"
      else
        puts '⚠️  No lease found'
      end
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  end

  desc 'List all active IPv4 leases for a MAC address'
  task :list_by_mac, [:mac_address] do |_t, args|
    mac_address = args[:mac_address]
    if mac_address.nil? || mac_address.empty?
      puts '❌ Error: MAC address required'
      puts '   Usage: rake lease:list_by_mac[bc:24:11:1d:2c:0f]'
      exit 1
    end

    puts "▶️  Listing leases for MAC #{mac_address}..."
    result = kea_ctrl_command('lease4-get-all', {})
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select { |l| l['hw-address']&.downcase == mac_address.downcase }
      if leases.empty?
        puts "⚠️  No leases found for MAC #{mac_address}"
      else
        puts "✅ Found #{leases.length} lease(s):"
        leases.each do |lease|
          puts "   IP: #{lease['ip-address']}, State: #{lease['state']}, Client-ID: #{lease['client-id'] || '(none)'}"
        end
      end
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Clean up conflicting leases for a MAC address (keeps only active lease)'
  task :cleanup_conflicts, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '❌ Error: MAC address required'
      puts '   Usage: rake lease:cleanup_conflicts[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "▶️  Cleaning up conflicting leases for MAC #{mac_address}..."
    result = kea_ctrl_command('lease4-get-all', {})
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['hw-address']&.downcase == mac_address.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "✅ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "⚠️  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']}..."
          del_result = kea_ctrl_command('lease4-del', { 'ip-address' => lease['ip-address'] })
          if del_result['result'] == 0
            puts "   ✅ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ⚠️  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '✅ Cleanup complete'
      end
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv6 lease by IP address'
  task :delete6_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '❌ Error: IP address required'
      puts '   Usage: rake lease:delete6_by_ip[3d06:bad:b01::66]'
      exit 1
    end

    puts "▶️  Deleting IPv6 lease for IP #{ip_address}..."
    payload = {
      command: 'lease6-del',
      service: ['dhcp6'],
      arguments: { 'ip-address' => ip_address }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0
      puts "✅ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "⚠️  No lease found: #{result['text']}"
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "❌ Error: #{e.message}"
    exit 1
  end

  desc 'Delete IPv6 lease by DUID'
  task :delete6_by_duid, [:duid, :subnet_id, :iaid] do |_t, args|
    duid = args[:duid]
    subnet_id = args[:subnet_id] || '10'
    iaid = args[:iaid] || '0'

    if duid.nil? || duid.empty?
      puts '❌ Error: DUID required'
      puts '   Usage: rake lease:delete6_by_duid[00:02:00:00:ab:11:87:e8:a6:25:af:c9:82:df,10,0]'
      exit 1
    end

    puts "▶️  Deleting IPv6 lease for DUID #{duid} in subnet #{subnet_id}..."
    payload = {
      command: 'lease6-del',
      service: ['dhcp6'],
      arguments: {
        'subnet-id' => subnet_id.to_i,
        'identifier-type' => 'duid',
        'identifier' => duid,
        'iaid' => iaid.to_i
      }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0
      puts "✅ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "⚠️  No lease found: #{result['text']}"
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "❌ Error: #{e.message}"
    exit 1
  end

  desc 'Get IPv6 lease by IP address'
  task :get6_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '❌ Error: IP address required'
      puts '   Usage: rake lease:get6_by_ip[3d06:bad:b01::c]'
      exit 1
    end

    puts "▶️  Getting IPv6 lease for IP #{ip_address}..."
    payload = {
      command: 'lease6-get',
      service: ['dhcp6'],
      arguments: { 'ip-address' => ip_address }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      lease = result['arguments']['leases'].first
      if lease
        puts '✅ Lease found:'
        puts "   IP: #{lease['ip-address']}"
        puts "   DUID: #{lease['duid']}"
        puts "   MAC: #{lease['hw-address'] || '(none)'}"
        puts "   Hostname: #{lease['hostname'] || '(none)'}"
        puts "   State: #{lease['state']}"
        puts "   IAID: #{lease['iaid']}"
      else
        puts '⚠️  No lease found'
      end
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "❌ Error: #{e.message}"
    exit 1
  end

  desc 'Clean up conflicting IPv6 leases for a DUID (keeps only active lease)'
  task :cleanup6_conflicts, [:duid, :subnet_id] do |_t, args|
    duid = args[:duid]
    subnet_id = args[:subnet_id] || '10'

    if duid.nil? || duid.empty?
      puts '❌ Error: DUID required'
      puts '   Usage: rake lease:cleanup6_conflicts[00:02:00:00:ab:11:87:e8:a6:25:af:c9:82:df,10]'
      exit 1
    end

    puts "▶️  Cleaning up conflicting IPv6 leases for DUID #{duid}..."
    payload = {
      command: 'lease6-get-all',
      service: ['dhcp6'],
      arguments: {}
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['duid']&.downcase == duid.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "✅ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "⚠️  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']}..."
          del_payload = {
            command: 'lease6-del',
            service: ['dhcp6'],
            arguments: { 'ip-address' => lease['ip-address'] }
          }.to_json
          del_output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                                  '-H', 'Content-Type: application/json',
                                  '-d', del_payload,
                                  'http://localhost:8080/api/servers/localhost/leases')
          del_result = JSON.parse(del_output)
          if del_result['result'] == 0
            puts "   ✅ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ⚠️  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '✅ Cleanup complete'
      end
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "❌ Error: #{e.message}"
    exit 1
  end

  desc 'Clean up conflicting IPv6 leases for a MAC address (keeps only active lease)'
  task :cleanup6_by_mac, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '❌ Error: MAC address required'
      puts '   Usage: rake lease:cleanup6_by_mac[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "▶️  Cleaning up conflicting IPv6 leases for MAC #{mac_address}..."
    payload = {
      command: 'lease6-get-all',
      service: ['dhcp6'],
      arguments: {}
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        'http://localhost:8080/api/servers/localhost/leases')
    result = JSON.parse(output)
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['hw-address']&.downcase == mac_address.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "✅ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "⚠️  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']} (DUID: #{lease['duid']})..."
          del_payload = {
            command: 'lease6-del',
            service: ['dhcp6'],
            arguments: { 'ip-address' => lease['ip-address'] }
          }.to_json
          del_output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                                  '-H', 'Content-Type: application/json',
                                  '-d', del_payload,
                                  'http://localhost:8080/api/servers/localhost/leases')
          del_result = JSON.parse(del_output)
          if del_result['result'] == 0
            puts "   ✅ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ⚠️  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '✅ Cleanup complete'
      end
    else
      puts "❌ Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "❌ Error: #{e.message}"
    exit 1
  end
end

desc 'Show available tasks'
task :help do
  puts 'Available tasks:'
  puts ''
  system('rake --tasks')
end

desc 'Default task - show available tasks'
task default: 'help'
