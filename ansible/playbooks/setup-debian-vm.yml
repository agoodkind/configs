---
# Reusable playbook for setting up a Debian 13 VM with cloud-init
#
# Required variables (for VM creation):
#   hostname: VM hostname (e.g., mwan.home.goodkind.io)
#
# Optional variables:
#   target_node: Proxmox node (default: vault)
#   vmid: Specific VMID (default: auto-assign)
#   disk_size: Disk size in GB (default: "8")
#   memory: Memory in MB (default: "1024")
#   cores: CPU cores (default: "1")
#   vm_tags: VM tags (default: "vm,debian")
#   network_interfaces: List of bridge names (default: ["vmbr0"])
#   hostpci_devices: List of PCI devices to pass through (default: [])
#   mgmt_ip_config: Cloud-init IP config (default: "ip=dhcp,ip6=auto")
#   dns_domain: DNS search domain
#   dns_servers: DNS server IPs
#
# If hostname is not provided, only the template will be created/verified

- name: Setup Debian cloud image template
  hosts: localhost
  gather_facts: false

  vars:
    target_node: vault
    template_vmid: 9000
    debian_cloud_image: "debian-13-generic-amd64.qcow2"
    debian_cloud_url: "https://cloud.debian.org/images/cloud/trixie/latest/debian-13-generic-amd64.qcow2"
    storage: "local-lvm"
    template_bridge: "vmbr0"
    enable_serial: true
    enable_qemu_agent: true

  tasks:
    - name: Check if Debian cloud image exists on Proxmox
      ansible.builtin.stat:
        path: "/var/lib/vz/template/qemu/{{ debian_cloud_image }}"
      delegate_to: "{{ target_node }}"
      register: image_check

    - name: Create template directory if missing
      ansible.builtin.file:
        path: /var/lib/vz/template/qemu
        state: directory
        mode: '0755'
      delegate_to: "{{ target_node }}"
      when: not image_check.stat.exists

    - name: Download Debian cloud image
      ansible.builtin.get_url:
        url: "{{ debian_cloud_url }}"
        dest: "/var/lib/vz/template/qemu/{{ debian_cloud_image }}"
        mode: '0644'
      delegate_to: "{{ target_node }}"
      when: not image_check.stat.exists

    - name: Check if template VM exists
      ansible.builtin.command: qm status {{ template_vmid }}
      delegate_to: "{{ target_node }}"
      register: template_check
      failed_when: false
      changed_when: false
      # Note: If upgrading existing template to Q35/UEFI, manually delete VM 9000 first:
      #   qm destroy 9000

    - name: Create Debian cloud-init template
      when: template_check.rc != 0
      delegate_to: "{{ target_node }}"
      block:
        - name: Create template VM
          ansible.builtin.command: >
            qm create {{ template_vmid }}
            --name debian-13-cloud-template
            --machine q35
            --bios ovmf
            --memory 512
            --cores 1
            --net0 virtio,bridge={{ template_bridge }}
            --scsihw virtio-scsi-pci
            {% if enable_serial %}--serial0 socket --vga serial0{% endif %}
            --ostype l26
            {% if enable_qemu_agent %}--agent enabled=1{% endif %}
          changed_when: true

        - name: Import cloud image as disk
          ansible.builtin.command: >
            qm importdisk {{ template_vmid }}
            /var/lib/vz/template/qemu/{{ debian_cloud_image }}
            {{ storage }}
          changed_when: true

        - name: Attach imported disk
          ansible.builtin.command: >
            qm set {{ template_vmid }}
            --scsi0 {{ storage }}:vm-{{ template_vmid }}-disk-0
          changed_when: true

        - name: Add EFI disk
          ansible.builtin.command: >
            qm set {{ template_vmid }}
            --efidisk0 {{ storage }}:1,efitype=4m,pre-enrolled-keys=1
          changed_when: true

        - name: Add cloud-init drive
          ansible.builtin.command: >
            qm set {{ template_vmid }}
            --ide2 {{ storage }}:cloudinit
          changed_when: true

        - name: Set boot order
          ansible.builtin.command: >
            qm set {{ template_vmid }}
            --boot order=scsi0
          changed_when: true

        - name: Convert to template
          ansible.builtin.command: qm template {{ template_vmid }}
          changed_when: true

    - name: Set template facts
      ansible.builtin.set_fact:
        debian_template_vmid: "{{ template_vmid }}"

- name: Create Debian VM from template
  hosts: localhost
  gather_facts: false

  vars:
    # Proxmox configuration
    target_node: vault
    template_vmid: 9000
    template_storage: "storage"
    template_bridge: "vmbr0"

    # VM specifications (defaults - caller overrides)
    vmid: ""
    disk_size: "8"
    memory: "1024"
    cores: "1"
    storage: "local-lvm"
    vm_tags: "vm,debian"

    # Network (caller should override)
    network_interfaces: ["vmbr0"]
    hostpci_devices: []

    # Cloud-init (caller should override for static IPs)
    mgmt_ip_config: "ip=dhcp,ip6=auto"
    dns_domain: "home.goodkind.io"
    dns_servers: "3d06:bad:b01::6 10.250.0.6"

    # Serial console & guest agent
    enable_serial: true
    enable_qemu_agent: true

    # SSH keys fetched at runtime from GitHub

  tasks:
    - name: Debug - show all extra vars
      ansible.builtin.debug:
        msg: "hostname={{ hostname | default('NOT SET') }}, all vars={{ vars.keys() | list | sort }}"

    - name: Skip VM creation if hostname not provided
      ansible.builtin.debug:
        msg: "No hostname provided - template-only mode. Pass -e hostname=<fqdn> to create a VM."
      when: hostname is not defined

    - name: End play if no hostname
      ansible.builtin.meta: end_play
      when: hostname is not defined

    - name: Check if VM already exists
      community.proxmox.proxmox_kvm:
        api_host: "{{ proxmox_api_host }}"
        api_user: "{{ proxmox_api_user }}"
        api_token_id: "{{ proxmox_token_id }}"
        api_token_secret: "{{ proxmox_token_secret }}"
        validate_certs: false
        node: "{{ target_node }}"
        name: "{{ hostname }}"
        state: current
      delegate_to: ansible.home.goodkind.io
      register: vm_check
      failed_when: false

    - name: Display VM status
      ansible.builtin.debug:
        msg: "VM {{ hostname }}: {{ 'exists (VMID ' + (vm_check.vmid | string) + ')' if vm_check.vmid is defined else 'will be created' }}"

    - name: VM creation block
      when: vm_check.vmid is not defined
      block:
        - name: Get next available VMID
          ansible.builtin.command: pvesh get /cluster/nextid
          delegate_to: "{{ target_node }}"
          register: next_vmid
          changed_when: false
          when: not vmid

        - name: Set VMID
          ansible.builtin.set_fact:
            new_vmid: "{{ vmid if vmid else next_vmid.stdout | trim }}"

        - name: Clone template to new VM
          ansible.builtin.command: >
            qm clone {{ template_vmid }} {{ new_vmid }}
            --name {{ hostname }}
            --full 1
            --target {{ target_node }}
          delegate_to: "{{ target_node }}"
          changed_when: true

        - name: Resize disk
          ansible.builtin.command: >
            qm resize {{ new_vmid }} scsi0 {{ disk_size }}G
          delegate_to: "{{ target_node }}"
          changed_when: true

        - name: Configure VM resources
          ansible.builtin.command: >
            qm set {{ new_vmid }}
            --memory {{ memory }}
            --cores {{ cores }}
            --cpu host
            --onboot 1
            --tags {{ vm_tags }}
          delegate_to: "{{ target_node }}"
          changed_when: true

        - name: Remove default network interface
          ansible.builtin.command: qm set {{ new_vmid }} --delete net0
          delegate_to: "{{ target_node }}"
          changed_when: true

        - name: Add network interfaces
          ansible.builtin.command: >
            qm set {{ new_vmid }}
            --net{{ idx }} virtio,bridge={{ item }}
          delegate_to: "{{ target_node }}"
          loop: "{{ network_interfaces }}"
          loop_control:
            index_var: idx
          changed_when: true

        - name: Add PCIe passthrough devices
          ansible.builtin.command: >
            qm set {{ new_vmid }}
            --hostpci{{ idx }} {{ item }},pcie=1{{ ',multifunction=on' if idx == 0 else '' }}
          delegate_to: "{{ target_node }}"
          loop: "{{ hostpci_devices | select() | list }}"
          loop_control:
            index_var: idx
          when: hostpci_devices | select() | list | length > 0
          changed_when: true

        - name: Fetch SSH keys from GitHub
          ansible.builtin.uri:
            url: "https://github.com/agoodkind.keys"
            return_content: true
          register: github_keys
          delegate_to: "{{ target_node }}"
          failed_when: false

        - name: Debug SSH keys
          ansible.builtin.debug:
            msg: "GitHub keys: {{ github_keys.content | default('FAILED TO FETCH') | length }} bytes"

        - name: Write SSH keys to temp file
          ansible.builtin.copy:
            content: "{{ github_keys.content | trim }}"
            dest: "/tmp/sshkeys_{{ new_vmid }}.pub"
            mode: '0644'
          delegate_to: "{{ target_node }}"
          when: github_keys.content is defined and github_keys.content | trim | length > 0

        - name: Configure cloud-init with SSH keys
          ansible.builtin.command: >
            qm set {{ new_vmid }}
            --ciuser root
            --sshkeys /tmp/sshkeys_{{ new_vmid }}.pub
            --ipconfig0 {{ mgmt_ip_config }}
            --searchdomain {{ dns_domain }}
            --nameserver '{{ dns_servers }}'
          delegate_to: "{{ target_node }}"
          changed_when: true
          when: github_keys.content is defined and github_keys.content | trim | length > 0

        - name: Configure cloud-init without SSH keys
          ansible.builtin.command: >
            qm set {{ new_vmid }}
            --ciuser root
            --ipconfig0 {{ mgmt_ip_config }}
            --searchdomain {{ dns_domain }}
            --nameserver '{{ dns_servers }}'
          delegate_to: "{{ target_node }}"
          changed_when: true
          when: github_keys.content is not defined or github_keys.content | trim | length == 0

        - name: Create cloud-init user-data for serial console
          ansible.builtin.copy:
            content: |
              #cloud-config
              # Configure serial console for UEFI/GRUB
              write_files:
                - path: /etc/default/grub.d/50-cloudimg-settings.cfg
                  content: |
                    # Cloud-init serial console configuration
                    GRUB_CMDLINE_LINUX_DEFAULT="console=tty0 console=ttyS0,115200"
                    GRUB_TERMINAL="console serial"
                    GRUB_SERIAL_COMMAND="serial --speed=115200 --unit=0 --word=8 --parity=no --stop=1"
                  permissions: '0644'
              runcmd:
                - update-grub
            dest: "/tmp/user-data_{{ new_vmid }}.yml"
            mode: '0644'
          delegate_to: "{{ target_node }}"
          when: enable_serial

        - name: Configure cloud-init custom user-data
          ansible.builtin.command: >
            qm set {{ new_vmid }}
            --cicustom "user=local:snippets/user-data_{{ new_vmid }}.yml"
          delegate_to: "{{ target_node }}"
          changed_when: true
          when: enable_serial
          register: cicustom_result
          failed_when: false

        - name: Copy user-data to snippets directory if cicustom failed
          ansible.builtin.copy:
            src: "/tmp/user-data_{{ new_vmid }}.yml"
            dest: "/var/lib/vz/snippets/user-data_{{ new_vmid }}.yml"
            remote_src: true
            mode: '0644'
          delegate_to: "{{ target_node }}"
          when: enable_serial and cicustom_result.rc != 0

        - name: Retry cicustom after copying to snippets
          ansible.builtin.command: >
            qm set {{ new_vmid }}
            --cicustom "user=local:snippets/user-data_{{ new_vmid }}.yml"
          delegate_to: "{{ target_node }}"
          changed_when: true
          when: enable_serial and cicustom_result.rc != 0

        - name: Clean up SSH keys and user-data temp files
          ansible.builtin.file:
            path: "{{ item }}"
            state: absent
          delegate_to: "{{ target_node }}"
          loop:
            - "/tmp/sshkeys_{{ new_vmid }}.pub"
            - "/tmp/user-data_{{ new_vmid }}.yml"
          failed_when: false

        - name: Regenerate cloud-init image
          ansible.builtin.command: qm cloudinit update {{ new_vmid }}
          delegate_to: "{{ target_node }}"
          changed_when: true

        - name: Start VM
          community.proxmox.proxmox_kvm:
            api_host: "{{ proxmox_api_host }}"
            api_user: "{{ proxmox_api_user }}"
            api_token_id: "{{ proxmox_token_id }}"
            api_token_secret: "{{ proxmox_token_secret }}"
            validate_certs: false
            node: "{{ target_node }}"
            vmid: "{{ new_vmid }}"
            state: started
          delegate_to: ansible.home.goodkind.io

        - name: Wait for VM to be reachable via SSH
          ansible.builtin.wait_for:
            host: "{{ hostname }}"
            port: 22
            timeout: 120
            state: started
          register: ssh_wait
          failed_when: false

        - name: Set facts for subsequent playbooks
          ansible.builtin.set_fact:
            hostname_fact: "{{ hostname }}"
            vm_created_fact: true
            vm_vmid_fact: "{{ new_vmid }}"

        - name: Display result
          ansible.builtin.debug:
            msg:
              - "✅ VM {{ hostname }} created (VMID: {{ new_vmid }})"
              - "{{ '✅ SSH available' if ssh_wait.state is defined and ssh_wait.state == 'started' else '⚠️  SSH not yet available - check DNS/DHCP' }}"
              - ""
              - "Cloud-init configured with:"
              - "  - Root SSH keys from ~/.ssh/id_ed25519.pub + GitHub"
              - "  - DHCP on first interface"
              - ""
              - "Next: Re-run deployment playbook to configure services"

    - name: Set facts if VM already exists
      ansible.builtin.set_fact:
        hostname_fact: "{{ hostname }}"
        vm_created_fact: false
        vm_vmid_fact: "{{ vm_check.vmid }}"
      when: vm_check.vmid is defined
