---
- name: Setup AdGuard container
  ansible.builtin.import_playbook: setup-service-container.yml
  vars:
    container_group: adguard_servers
    group_vars_file: "{{ playbook_dir }}/../inventory/group_vars/adguard_servers.yml"
    hostname_var: adguard_hostname
    target_node: vault
    container_vmid: ""
    disk_size: "8"
    memory: "2048"
    cores: "2"
    container_tags: "lxc,adguard"

- name: Deploy and Configure AdGuard Home
  hosts: adguard_servers
  become: true

  vars:
    adguard_channel: "release"
    repo_root: "{{ playbook_dir | dirname | dirname }}"
    adguard_hostname: "{{ hostvars['localhost']['service_hostname'] }}"

  tasks:
    - name: Create AdGuard user
      ansible.builtin.user:
        name: "{{ adguard_user }}"
        system: true
        shell: /bin/false
        home: "{{ adguard_work_dir }}"
        create_home: false

    - name: Create AdGuard directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        owner: "{{ adguard_user }}"
        group: "{{ adguard_group }}"
        mode: '0750'
      loop:
        - "{{ adguard_work_dir }}"
        - "{{ adguard_data_dir }}"
        - "{{ adguard_work_dir }}/certs"

    - name: Validate Cloudflare token is present when TLS is enabled
      ansible.builtin.assert:
        that:
          - cloudflare_api_token is defined
          - cloudflare_api_token | length > 0
        fail_msg: >-
          cloudflare_api_token is empty. Set CLOUDFLARE_API_KEY in your
          automation environment (same env var used for Traefik).
      when: adguard_tls_enabled | default(false)

    - name: Install certbot + Cloudflare DNS plugin
      ansible.builtin.apt:
        name:
          - certbot
          - python3-certbot-dns-cloudflare
        state: present
        update_cache: true
      when: adguard_tls_enabled | default(false)

    - name: Create Cloudflare credentials file for certbot
      ansible.builtin.copy:
        dest: /etc/letsencrypt/cloudflare.ini
        mode: '0600'
        content: |
          dns_cloudflare_api_token = {{ cloudflare_api_token }}
      when: adguard_tls_enabled | default(false)

    - name: Install AdGuard cert sync hook
      ansible.builtin.template:
        src: "{{ repo_root }}/adguard/scripts/adguard-sync-le-certs.sh.j2"
        dest: /usr/local/sbin/adguard-sync-le-certs
        owner: root
        group: root
        mode: '0755'
      when: adguard_tls_enabled | default(false)

    - name: Obtain/ensure Let's Encrypt certificate for AdGuardHome (DNS-01)
      ansible.builtin.command: >-
        certbot certonly
        --non-interactive
        --agree-tos
        --email {{ adguard_acme_email }}
        --preferred-challenges dns
        --dns-cloudflare
        --dns-cloudflare-credentials /etc/letsencrypt/cloudflare.ini
        --keep-until-expiring
        -d {{ adguard_hostname }}
        --deploy-hook /usr/local/sbin/adguard-sync-le-certs
      args:
        creates: "/etc/letsencrypt/live/{{ adguard_hostname }}/fullchain.pem"
      when: adguard_tls_enabled | default(false)

    - name: Install certbot renew systemd unit
      ansible.builtin.copy:
        src: "{{ repo_root }}/adguard/services/adguard-certbot-renew.service"
        dest: /etc/systemd/system/adguard-certbot-renew.service
        owner: root
        group: root
        mode: '0644'
      notify: Reload systemd
      when: adguard_tls_enabled | default(false)

    - name: Install certbot renew systemd timer
      ansible.builtin.copy:
        src: "{{ repo_root }}/adguard/timers/adguard-certbot-renew.timer"
        dest: /etc/systemd/system/adguard-certbot-renew.timer
        owner: root
        group: root
        mode: '0644'
      notify: Reload systemd
      when: adguard_tls_enabled | default(false)

    - name: Enable and start certbot renewal timer
      ansible.builtin.systemd:
        name: adguard-certbot-renew.timer
        enabled: true
        state: started
        daemon_reload: true
      when: adguard_tls_enabled | default(false)

    - name: Check if AdGuard Home is installed
      ansible.builtin.stat:
        path: /opt/AdGuardHome/AdGuardHome
      register: adguard_binary

    - name: Get installed AdGuard Home version
      ansible.builtin.command: /opt/AdGuardHome/AdGuardHome --version
      register: adguard_installed_version
      when: adguard_binary.stat.exists
      changed_when: false
      failed_when: false

    - name: Parse installed version number
      ansible.builtin.set_fact:
        installed_version: >-
          {{ adguard_installed_version.stdout |
             regex_search('v[0-9]+\\.[0-9]+\\.[0-9]+') | default('', true) }}
      when: adguard_binary.stat.exists and adguard_installed_version.stdout is defined

    # Check available version using AdGuard Home's version.json endpoint
    # Reference: internal/updater/updater.go:DefaultVersionURL() and
    #   internal/updater/check.go
    # URL format:
    #   https://static.adtidy.org/adguardhome/{channel}/version.json
    # The version.json contains: version, announcement,
    #   announcement_url, and download URLs
    - name: Get available version from release channel
      ansible.builtin.uri:
        url: "https://static.adtidy.org/adguardhome/{{ adguard_channel }}/version.json"
        return_content: true
      register: version_info
      changed_when: false
      failed_when: false

    - name: Parse available version from version.json
      ansible.builtin.set_fact:
        available_version: "{{ version_info.json.version | default('') }}"
      when: version_info.json is defined and version_info.json.version is defined

    - name: Determine if installation or update is needed
      ansible.builtin.set_fact:
        needs_install: "{{ not adguard_binary.stat.exists }}"
        needs_update: >-
          {{ adguard_binary.stat.exists and
             installed_version is defined and
             available_version is defined and
             installed_version != available_version }}
      changed_when: false

    - name: Install or update AdGuard Home using official install script
      when: needs_install | default(false) or needs_update | default(false)
      block:
        - name: Download and run AdGuard Home install script (new installation)
          ansible.builtin.shell: |
            set -o pipefail
            curl -s -S -L \
              https://raw.githubusercontent.com/AdguardTeam/AdGuardHome/master/scripts/install.sh \
              | bash -s -- -v -c {{ adguard_channel }} -o /opt
          args:
            executable: /bin/bash
          register: install_result
          changed_when: install_result.rc == 0
          when: needs_install | default(false)

        - name: Download and run AdGuard Home install script (reinstall for update)
          ansible.builtin.shell: |
            set -o pipefail
            curl -s -S -L \
              https://raw.githubusercontent.com/AdguardTeam/AdGuardHome/master/scripts/install.sh \
              | bash -s -- -v -c {{ adguard_channel }} -r -o /opt
          args:
            executable: /bin/bash
          register: install_result
          changed_when: install_result.rc == 0
          when: needs_update | default(false)

        - name: Verify AdGuard Home binary was installed
          ansible.builtin.stat:
            path: /opt/AdGuardHome/AdGuardHome
          register: verify_binary

        - name: Assert AdGuard Home binary exists
          ansible.builtin.assert:
            that:
              - verify_binary.stat.exists
            fail_msg: "AdGuard Home binary was not installed successfully"

    - name: Set CAP_NET_BIND_SERVICE capability for DNS port
      ansible.builtin.command: >-
        setcap cap_net_bind_service=+ep /opt/AdGuardHome/AdGuardHome
      changed_when: false

    - name: Set ownership of AdGuard directories (after install)
      ansible.builtin.file:
        path: "{{ item }}"
        owner: "{{ adguard_user }}"
        group: "{{ adguard_group }}"
        recurse: true
      loop:
        - "{{ adguard_work_dir }}"
        - "{{ adguard_data_dir }}"
      when: adguard_binary.stat.exists

    - name: Build AdGuard self-hostname DNS rewrites (avoid loopback)
      ansible.builtin.set_fact:
        adguard_rewrites_effective: >-
          {{
            (adguard_rewrites | default([]))
            +
            (
              ([{'domain': adguard_hostname, 'answer': ansible_default_ipv4.address, 'enabled': true}]
               if (ansible_default_ipv4 is defined and
                   ansible_default_ipv4.address is defined and
                   ansible_default_ipv4.address != '127.0.0.1')
               else [])
            )
            +
            (
              ([{'domain': adguard_hostname, 'answer': ansible_default_ipv6.address, 'enabled': true}]
               if (ansible_default_ipv6 is defined and
                   ansible_default_ipv6.address is defined and
                   ansible_default_ipv6.address != '::1')
               else [])
            )
          }}

    - name: Check if AdGuardHome config already exists
      ansible.builtin.stat:
        path: "{{ adguard_work_dir }}/AdGuardHome.yaml"
      register: adguard_config_file

    - name: Template AdGuardHome config (first install only)
      ansible.builtin.template:
        src: "{{ repo_root }}/adguard/AdGuardHome.yaml.j2"
        dest: "{{ adguard_work_dir }}/AdGuardHome.yaml"
        owner: "{{ adguard_user }}"
        group: "{{ adguard_group }}"
        mode: '0640'
        backup: true
      notify: Restart AdGuardHome
      when: not (adguard_config_file.stat.exists | default(false))

    - name: Install AdGuardHome config merge helper (yq)
      ansible.builtin.copy:
        src: "{{ repo_root }}/adguard/scripts/adguard-merge-config.sh"
        dest: /usr/local/sbin/adguard-merge-config
        owner: root
        group: root
        mode: '0755'
      when: adguard_config_file.stat.exists | default(false)

    - name: Merge TLS and hostname rewrites into existing AdGuardHome config
      ansible.builtin.command: /usr/local/sbin/adguard-merge-config
      register: adguard_merge_result
      changed_when: adguard_merge_result.stdout is search('changed=1')
      notify: Restart AdGuardHome
      environment:
        ADGUARD_CONFIG_PATH: "{{ adguard_work_dir }}/AdGuardHome.yaml"
        ADGUARD_MANAGED_DOMAIN_LC: "{{ adguard_hostname | lower }}"
        ADGUARD_TLS_JSON: >-
          {{
            {
              'enabled': (adguard_tls_enabled | default(false)),
              'server_name': (adguard_tls_server_name | default(adguard_hostname) | default('')),
              'force_https': (adguard_tls_force_https | default(false)),
              'port_https': (adguard_tls_port_https | default(0)),
              'port_dns_over_tls': (adguard_tls_port_dns_over_tls | default(0)),
              'port_dns_over_quic': (adguard_tls_port_dns_over_quic | default(0)),
              'certificate_path': (adguard_tls_certificate_path | default('')),
              'private_key_path': (adguard_tls_private_key_path | default(''))
            } | to_json
          }}
        ADGUARD_REWRITES_JSON: "{{ adguard_rewrites_effective | default([]) | to_json }}"
      when: adguard_config_file.stat.exists | default(false)

    - name: Create resolved.conf.d directory
      ansible.builtin.file:
        path: /etc/systemd/resolved.conf.d
        state: directory
        mode: '0755'

    - name: Disable systemd-resolved stub listener (free port 53)
      ansible.builtin.copy:
        dest: /etc/systemd/resolved.conf.d/adguard.conf
        content: |
          [Resolve]
          DNS=127.0.0.1
          DNSStubListener=no
        mode: '0644'
      notify: Restart systemd-resolved

    - name: Flush handlers to free port 53 before starting AdGuard
      ansible.builtin.meta: flush_handlers

    - name: Enable AdGuard Home service
      ansible.builtin.systemd:
        name: AdGuardHome
        enabled: true
        daemon_reload: true

    - name: Ensure AdGuard Home service is running
      ansible.builtin.systemd:
        name: AdGuardHome
        state: started

    - name: Flush handlers to ensure AdGuard Home is restarted
      ansible.builtin.meta: flush_handlers

    - name: Wait for AdGuard Home to start
      ansible.builtin.pause:
        seconds: 5

    - name: Verify AdGuard Home service status
      ansible.builtin.systemd:
        name: AdGuardHome
      register: adguard_status

    - name: Display AdGuard Home service status
      ansible.builtin.debug:
        msg: "✓ AdGuard Home service is {{ adguard_status.status.ActiveState }}"

    - name: Check AdGuard Home web interface
      ansible.builtin.uri:
        url: "http://localhost:{{ adguard_port }}"
        follow_redirects: none
        validate_certs: false
        status_code: [200, 301, 302, 308]
        timeout: 5
      register: health_check
      retries: 3
      delay: 2
      until: health_check.status is defined
      failed_when: false

    - name: Report health check result
      ansible.builtin.debug:
        msg: >-
          {% if health_check.status is defined %}
          ✓ AdGuard Home is responding (HTTP {{ health_check.status }})
          {% else %}
          ⚠ AdGuard Home health check returned: {{ health_check.msg }}
          {% endif %}

  handlers:
    - name: Reload systemd
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Restart systemd-resolved
      ansible.builtin.systemd:
        name: systemd-resolved
        state: restarted

    - name: Restart AdGuardHome
      ansible.builtin.systemd:
        name: AdGuardHome
        state: restarted

- name: Summary
  hosts: localhost
  gather_facts: false
  tasks:
    - name: Display completion message
      ansible.builtin.debug:
        msg: >-
          ✅ AdGuard Home deployed successfully on
          {{ hostvars['localhost']['service_hostname'] }}
