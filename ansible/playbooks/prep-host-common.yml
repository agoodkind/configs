---
- name: Prepare Host
  # Common host preparation after we can SSH to the guest.
  #
  # Callers should provide `target_hosts` (group or host pattern). When omitted,
  # defaults to `proxmox_api_targets` (the in-memory group built by prep-guests.yml).
  hosts: "{{ target_hosts | default('proxmox_api_targets') }}"
  gather_facts: false
  vars:
    repo_root: "{{ playbook_dir | dirname | dirname }}"
  tasks:
    - name: Wait for SSH to be ready (after starting)
      ansible.builtin.wait_for_connection:
        timeout: 120
        delay: 2
        sleep: 2

    - name: Gather facts
      ansible.builtin.setup:

    - name: Filter by container/VM ID if specified
      ansible.builtin.meta: end_host
      when:
        - container_id | default('') | length > 0
        - ansible_proxmox_vmid | default('') | string != container_id | string

    - name: Detect if running in LXC container or VM
      ansible.builtin.set_fact:
        is_lxc: "{{ ansible_virtualization_type | default('') == 'lxc' }}"
        is_vm: "{{ ansible_virtualization_type | default('') in ['kvm', 'qemu'] }}"

    - name: Compute effective prep-guests service name and login directory
      ansible.builtin.set_fact:
        prep_ct_service_effective: >-
          {{
            (prep_ct_service | default('') | trim)
            if (prep_ct_service | default('') | trim) | length > 0
            else (
              (prep_ct_target_group | default('') | trim | regex_replace('_servers$',''))
              if (prep_ct_target_group | default('') | trim) | length > 0
              else ''
            )
          }}
        login_dir_effective: "{{ login_dir | default('/root') }}"

    - name: Update Cloudflare DNS records (A and AAAA)
      when:
        - cloudflare_dns_update_enabled | default(true) | bool
        - cloudflare_api_token is defined
        - (cloudflare_api_token | default('') | trim) | length > 0
        - inventory_hostname is match('.*\\.home\\.goodkind\\.io$')
      delegate_to: localhost
      block:
        - name: Parse hostname components for Cloudflare
          ansible.builtin.set_fact:
            cf_zone_name: "home.goodkind.io"
            cf_record_name: "{{ inventory_hostname | regex_replace('\\.home\\.goodkind\\.io$', '') }}"
            cf_api_token: "{{ cloudflare_api_token }}"

        - name: Get Cloudflare zone ID
          ansible.builtin.uri:
            url: https://api.cloudflare.com/client/v4/zones?name={{ cf_zone_name }}
            method: GET
            headers:
              Authorization: "Bearer {{ cf_api_token }}"
              Content-Type: application/json
            return_content: true
            status_code: [200]
          register: cf_zone_lookup
          no_log: true

        - name: Extract zone ID
          ansible.builtin.set_fact:
            cf_zone_id: "{{ cf_zone_lookup.json.result[0].id }}"
          when:
            - cf_zone_lookup.json.result is defined
            - (cf_zone_lookup.json.result | length) > 0

        - name: Get existing DNS records for this hostname
          ansible.builtin.uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ cf_zone_id }}/dns_records?name={{-
              inventory_hostname }}
            method: GET
            headers:
              Authorization: "Bearer {{ cf_api_token }}"
              Content-Type: application/json
            return_content: true
            status_code: [200]
          register: cf_existing_records
          no_log: true
          when: cf_zone_id is defined

        - name: Find existing A record ID
          ansible.builtin.set_fact:
            cf_a_record_id: >-
              {{
                (cf_existing_records.json.result | default([])
                | selectattr('type', 'equalto', 'A')
                | list)[0].id | default('')
              }}
          when:
            - cf_existing_records.json.result is defined
            - ansible_default_ipv4.address is defined

        - name: Find existing AAAA record ID
          ansible.builtin.set_fact:
            cf_aaaa_record_id: >-
              {{
                (cf_existing_records.json.result | default([])
                | selectattr('type', 'equalto', 'AAAA')
                | list)[0].id | default('')
              }}
          when:
            - cf_existing_records.json.result is defined
            - ansible_default_ipv6.address is defined

        - name: Create or update A record (IPv4)
          ansible.builtin.uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ cf_zone_id }}/dns_records{{-
              ('/' + cf_a_record_id) if (cf_a_record_id | default('') | trim) | length > 0 else '' }}
            method: "{{ 'PATCH' if (cf_a_record_id | default('') | trim) | length > 0 else 'POST' }}"
            headers:
              Authorization: "Bearer {{ cf_api_token }}"
              Content-Type: application/json
            body_format: json
            body:
              type: A
              name: "{{ inventory_hostname }}"
              content: "{{ ansible_default_ipv4.address }}"
              ttl: 300
              proxied: false
            return_content: true
            status_code: [200]
          register: cf_a_record_result
          no_log: true
          when:
            - cf_zone_id is defined
            - ansible_default_ipv4.address is defined
            - ansible_default_ipv4.address != '127.0.0.1'

        - name: Create or update AAAA record (IPv6)
          ansible.builtin.uri:
            url: >-
              https://api.cloudflare.com/client/v4/zones/{{ cf_zone_id }}/dns_records{{-
              ('/' + cf_aaaa_record_id) if (cf_aaaa_record_id | default('') | trim) | length > 0 else '' }}
            method: "{{ 'PATCH' if (cf_aaaa_record_id | default('') | trim) | length > 0 else 'POST' }}"
            headers:
              Authorization: "Bearer {{ cf_api_token }}"
              Content-Type: application/json
            body_format: json
            body:
              type: AAAA
              name: "{{ inventory_hostname }}"
              content: "{{ ansible_default_ipv6.address }}"
              ttl: 300
              proxied: false
            return_content: true
            status_code: [200]
          register: cf_aaaa_record_result
          no_log: true
          when:
            - cf_zone_id is defined
            - ansible_default_ipv6.address is defined
            - ansible_default_ipv6.address != '::1'
            - not (ansible_default_ipv6.address is match('^fe80:'))

        - name: Display Cloudflare DNS update results
          ansible.builtin.debug:
            msg:
              - "âœ“ Cloudflare DNS updated for {{ inventory_hostname }}"
              - "  A record: {{ ansible_default_ipv4.address | default('(none)') }}"
              - "  AAAA record: {{ ansible_default_ipv6.address | default('(none)') }}"
          when:
            - cf_zone_id is defined
            - (cf_a_record_result is defined and cf_a_record_result.status == 200) or
              (cf_aaaa_record_result is defined and cf_aaaa_record_result.status == 200)

    - name: Update package lists
      ansible.builtin.apt:
        update_cache: true

    - name: Install locales package
      ansible.builtin.apt:
        name: locales
        state: present

    - name: Check if en_US.UTF-8 locale is already uncommented
      ansible.builtin.command: grep -q '^en_US.UTF-8 UTF-8' /etc/locale.gen
      register: locale_uncommented
      changed_when: false
      failed_when: false

    - name: Uncomment en_US.UTF-8 in locale.gen
      ansible.builtin.lineinfile:
        path: /etc/locale.gen
        regexp: '^# *en_US.UTF-8'
        line: 'en_US.UTF-8 UTF-8'
        state: present
      when: not locale_uncommented.rc == 0

    - name: Check if en_US.UTF-8 locale is already generated
      ansible.builtin.shell: |
        set -o pipefail
        locale -a | grep -q '^en_US.utf8$'
      register: locale_generated
      changed_when: false
      failed_when: false

    - name: Generate en_US.UTF-8 locale
      ansible.builtin.command: locale-gen
      changed_when: true
      when: not locale_generated.rc == 0 or locale_uncommented.changed | default(false)

    - name: Check current system locale
      ansible.builtin.shell: |
        set -o pipefail
        (localectl status 2>/dev/null | grep -q 'LANG=en_US.UTF-8') ||
        (grep -q '^LANG=en_US.UTF-8' /etc/default/locale 2>/dev/null)
      register: locale_set
      changed_when: false
      failed_when: false

    - name: Update system locale
      ansible.builtin.command: update-locale LANG=en_US.UTF-8
      changed_when: true
      when: not locale_set.rc == 0

    - name: Add LANG export to .bashrc
      ansible.builtin.lineinfile:
        path: /root/.bashrc
        line: 'export LANG="en_US.UTF-8"'
        state: present

    - name: Add LC_ALL export to .bashrc
      ansible.builtin.lineinfile:
        path: /root/.bashrc
        line: 'export LC_ALL="en_US.UTF-8"'
        state: present

    - name: Update package lists again
      ansible.builtin.apt:
        update_cache: true

    - name: Upgrade all packages
      ansible.builtin.apt:
        upgrade: dist

    - name: Install essential packages
      ansible.builtin.apt:
        name:
          - neovim
          - htop
          - curl
          - wget
          - net-tools
          - gpg
          - rsyslog
          - git
          - gh
          - git-lfs
          - jq
          - ripgrep
          - unzip
          - tree
          - tzdata
          - yq
          - apache2-utils
          - msmtp
          - msmtp-mta
        state: present

    - name: Ensure /opt/scripts exists (git checkout)
      ansible.builtin.git:
        repo: https://github.com/agoodkind/scripts.git
        dest: /opt/scripts
        version: main
        update: true
        force: true

    - name: Ensure /opt/scripts is executable
      ansible.builtin.file:
        path: /opt/scripts
        state: directory
        mode: '0755'
        recurse: true

    - name: Install scripts-updater systemd service
      ansible.builtin.copy:
        dest: /etc/systemd/system/scripts-updater.service
        mode: '0644'
        content: |
          [Unit]
          Description=Update /opt/scripts from git
          After=network-online.target
          Wants=network-online.target

          [Service]
          Type=oneshot
          ExecStart=/usr/bin/git -C /opt/scripts pull --ff-only
          TimeoutStartSec=300

    - name: Install scripts-updater systemd timer
      ansible.builtin.copy:
        dest: /etc/systemd/system/scripts-updater.timer
        mode: '0644'
        content: |
          [Unit]
          Description=Run scripts-updater daily

          [Timer]
          OnCalendar=daily
          RandomizedDelaySec=3600
          Persistent=true

          [Install]
          WantedBy=timers.target

    - name: Ensure /opt/scripts is in system PATH
      ansible.builtin.copy:
        dest: /etc/profile.d/opt-scripts.sh
        mode: '0644'
        content: |
          export PATH="/opt/scripts:$PATH"

    - name: Enable scripts-updater timer
      ansible.builtin.systemd:
        name: scripts-updater.timer
        enabled: true
        state: started
        daemon_reload: true

    - name: Compute SMTP username for this host
      ansible.builtin.set_fact:
        smtp_effective_user: >-
          {{
            (smtp_user | default('') | trim)
            if (smtp_user | default('') | trim) | length > 0
            else (
              'host-' ~
              (
                inventory_hostname
                | lower
                | regex_replace('[^a-z0-9]+','-')
                | regex_replace('(^-+|-+$)','')
              )
            )
          }}
      when: (smtp_enabled | default('1') | string) != '0'

    - name: Generate random SMTP password (used if SMTP2GO API key is set)
      ansible.builtin.set_fact:
        smtp_generated_pass: >-
          {{ lookup('password', '/dev/null length=32 chars=ascii_letters,digits') }}
      when:
        - (smtp_enabled | default('1') | string) != '0'
        - (smtp_pass | default('') | trim) | length == 0
        - (smtp2go_api_key | default('') | trim) | length > 0

    - name: Ensure SMTP2GO SMTP user exists (API add)
      ansible.builtin.uri:
        url: https://api.smtp2go.com/v3/users/smtp/add
        method: POST
        headers:
          Content-Type: application/json
          X-Smtp2go-Api-Key: "{{ smtp2go_api_key }}"
        body_format: json
        body:
          username: "{{ smtp_effective_user }}"
          email_password: "{{ smtp_generated_pass }}"
          description: "Host {{ inventory_hostname }}"
          status: allowed
        return_content: true
        status_code: [200, 400, 409]
      register: smtp2go_add_user
      changed_when: (smtp2go_add_user.status | default(0)) == 200
      failed_when: >-
        (smtp2go_add_user.status | default(0)) not in [200, 400, 409]
        or
        (
          (smtp2go_add_user.status | default(0)) == 400
          and
          (
            (
              (smtp2go_add_user.json.data.error | default('') | lower)
              | regex_search('already have smtp user')
            ) == none
          )
        )
      when:
        - (smtp_enabled | default('1') | string) != '0'
        - (smtp_user | default('') | trim) | length == 0
        - (smtp_pass | default('') | trim) | length == 0
        - (smtp2go_api_key | default('') | trim) | length > 0

    - name: Detect if SMTP2GO SMTP user already exists (API semantics vary)
      ansible.builtin.set_fact:
        smtp2go_user_exists: >-
          {{
            (smtp2go_add_user is defined)
            and
            (
              (smtp2go_add_user.status | default(0)) == 409
              or
              (
                (smtp2go_add_user.status | default(0)) == 400
                and
                (
                  (
                    (smtp2go_add_user.json.data.error | default('') | lower)
                    | regex_search('already have smtp user')
                  ) != none
                )
              )
            )
          }}
      when:
        - (smtp_enabled | default('1') | string) != '0'
        - (smtp_user | default('') | trim) | length == 0
        - (smtp_pass | default('') | trim) | length == 0
        - (smtp2go_api_key | default('') | trim) | length > 0
        - smtp2go_add_user is defined

    - name: Update SMTP2GO SMTP user password if user already exists (API edit)
      ansible.builtin.uri:
        url: https://api.smtp2go.com/v3/users/smtp/edit
        method: POST
        headers:
          Content-Type: application/json
          X-Smtp2go-Api-Key: "{{ smtp2go_api_key }}"
        body_format: json
        body:
          username: "{{ smtp_effective_user }}"
          email_password: "{{ smtp_generated_pass }}"
          status: allowed
        return_content: true
        status_code: [200]
      when:
        - (smtp_enabled | default('1') | string) != '0'
        - (smtp_user | default('') | trim) | length == 0
        - (smtp_pass | default('') | trim) | length == 0
        - (smtp2go_api_key | default('') | trim) | length > 0
        - smtp2go_user_exists | default(false)

    - name: Set effective SMTP password (manual or generated)
      ansible.builtin.set_fact:
        smtp_effective_pass: >-
          {{
            (smtp_pass | trim)
            if (smtp_pass | default('') | trim) | length > 0
            else (smtp_generated_pass | default(''))
          }}
      when: (smtp_enabled | default('1') | string) != '0'

    - name: Compute SMTP From address and sender name (defaults to hostname)
      ansible.builtin.set_fact:
        smtp_effective_from: >-
          {{
            (smtp_from | trim)
            if (smtp_from | default('') | trim) | length > 0
            else (ansible_hostname ~ '@' ~ (smtp_from_domain | default('goodkind.io') | trim))
          }}
        smtp_effective_sender_name: >-
          {{
            (smtp_sender_name | trim)
            if (smtp_sender_name | default('') | trim) | length > 0
            else (ansible_hostname | default(inventory_hostname))
          }}
      when: (smtp_enabled | default('1') | string) != '0'

    - name: Deploy /etc/msmtprc
      ansible.builtin.copy:
        dest: /etc/msmtprc
        mode: '0600'
        content: |
          defaults
          auth           on
          tls            on
          tls_starttls   on
          tls_trust_file /etc/ssl/certs/ca-certificates.crt
          logfile        /var/log/msmtp.log

          account smtp2go
          host {{ smtp_host }}
          port {{ smtp_port }}
          user {{ smtp_effective_user }}
          password {{ smtp_effective_pass }}
          from {{ smtp_effective_from }}

          account default : smtp2go
      when:
        - (smtp_enabled | default('1') | string) != '0'
        - (smtp_effective_user | default('') | trim) | length > 0
        - (smtp_effective_pass | default('') | trim) | length > 0
        - (smtp_effective_from | default('') | trim) | length > 0

    - name: Install qemu-guest-agent (VMs only)
      ansible.builtin.apt:
        name: qemu-guest-agent
        state: present
      when: is_vm | default(false)

    - name: Enable and start qemu-guest-agent (VMs only)
      ansible.builtin.systemd:
        name: qemu-guest-agent
        enabled: true
        state: started
      when: is_vm | default(false)

    - name: Remove unnecessary packages
      ansible.builtin.apt:
        autoremove: true

    - name: Find Python EXTERNALLY-MANAGED files
      ansible.builtin.find:
        paths: /usr/lib
        patterns: "python3.*/EXTERNALLY-MANAGED"
        file_type: file
      register: externally_managed_files

    - name: Remove Python EXTERNALLY-MANAGED block
      ansible.builtin.file:
        path: "{{ item.path }}"
        state: absent
      loop: "{{ externally_managed_files.files }}"
      when: externally_managed_files.files | length > 0

    - name: Disable networkd wait service
      ansible.builtin.systemd:
        name: systemd-networkd-wait-online.service
        enabled: false
        state: stopped
      failed_when: false

    - name: Get host timezone
      ansible.builtin.command: timedatectl show -p Timezone --value
      register: host_timezone
      changed_when: false
      failed_when: false
      delegate_to: localhost

    - name: Get current container timezone
      ansible.builtin.command: timedatectl show -p Timezone --value
      register: container_timezone
      changed_when: false
      failed_when: false

    - name: Set timezone to host timezone
      ansible.builtin.command: timedatectl set-timezone "{{ host_timezone.stdout }}"
      changed_when: true
      when: container_timezone.stdout != host_timezone.stdout

    - name: Configure rsyslog for local time
      ansible.builtin.copy:
        dest: /etc/rsyslog.d/50-default-local.conf
        content: |
          # Use local time instead of UTC
          $ActionFileDefaultTemplate RSYSLOG_TraditionalFileFormat
          $template TraditionalFormatWithLocalTime, >-
            "%timegenerated% %HOSTNAME% %syslogtag%%msg:::drop-last-lf%\n"
          $ActionFileDefaultTemplate TraditionalFormatWithLocalTime
        mode: '0644'
      notify: Restart rsyslog

    - name: Set 256-color terminal for root
      ansible.builtin.lineinfile:
        path: /root/.bashrc
        line: 'export TERM="xterm-256color"'
        state: present

    - name: Remove '[ -z "$PS1" ] && return' from .bashrc
      ansible.builtin.lineinfile:
        path: /root/.bashrc
        regexp: '^\[ -z "\$PS1" \] && return'
        state: absent

    - name: Install login directory helper (service-aware)
      ansible.builtin.copy:
        dest: /etc/profile.d/99-prep-guests-login-dir.sh
        mode: '0644'
        content: |
          # Managed by Ansible (prep-guests.yml)
          #
          # Set a service-oriented default working directory for interactive shells.
          # Override per-container with `login_dir` in the vars file.
          export PREP_CTS_SERVICE="{{ prep_ct_service_effective | default('') | trim }}"
          export PREP_CTS_LOGIN_DIR="{{ login_dir_effective | default('') | trim }}"

          if [ -n "${PS1-}" ] && [ -n "${PREP_CTS_LOGIN_DIR-}" ]; then
            if [ -d "${PREP_CTS_LOGIN_DIR}" ] && [ "${PWD-}" != "${PREP_CTS_LOGIN_DIR}" ]; then
              cd "${PREP_CTS_LOGIN_DIR}" || true
            fi
          fi

    - name: Install debug helper command (service-specific)
      ansible.builtin.template:
        src: "{{ repo_root }}/{{ prep_ct_service_effective | lower }}/debug-{{ prep_ct_service_effective | lower }}.sh.j2"
        dest: /usr/local/bin/debug
        mode: '0755'
      when:
        - prep_ct_service_effective is defined
        - (prep_ct_service_effective | default('') | trim) | length > 0
        - prep_ct_service_effective | lower in ['adguard', 'traefik', 'powerdns']

    - name: Install debug helper command (generic fallback)
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/debug/debug-generic.sh.j2"
        dest: /usr/local/bin/debug
        mode: '0755'
      when: >-
        (prep_ct_service_effective | default('') | trim) | length == 0
        or (prep_ct_service_effective | lower not in ['adguard', 'traefik', 'powerdns'])

    - name: Check if any MOTD script is executable
      ansible.builtin.find:
        paths: /etc/update-motd.d
        file_type: file
        patterns: "*.sh"
      register: motd_scripts
      changed_when: false

    - name: Check executable status of MOTD scripts
      ansible.builtin.stat:
        path: "{{ item.path }}"
      register: motd_script_stats
      loop: "{{ motd_scripts.files | default([]) }}"
      changed_when: false

    - name: Disable default MOTD scripts
      ansible.builtin.file:
        path: /etc/update-motd.d/
        recurse: true
        mode: 'u-x,g-x,o-x'
      when: >
        motd_scripts.files | default([]) | length > 0 and
        (motd_script_stats.results | selectattr('stat.exists') |
         selectattr('stat.mode', 'match', '.*x.*') | list | length > 0)

    - name: Configure auto-login for root (LXC only)
      ansible.builtin.blockinfile:
        path: /etc/systemd/system/container-getty@1.service.d/override.conf
        create: true
        mode: '0644'
        block: |
          [Service]
          ExecStart=
          ExecStart=-/sbin/agetty --autologin root --noclear --keep-baud tty%I 115200,38400,9600 $TERM
      register: configure_auto_login
      when: is_lxc | default(false)
      notify: Restart getty service

    - name: Create systemd system.conf.d directory
      ansible.builtin.file:
        path: /etc/systemd/system.conf.d
        state: directory
        mode: '0755'

    - name: Lower systemctl shutdown timeout to 15 seconds
      ansible.builtin.copy:
        dest: /etc/systemd/system.conf.d/timeout.conf
        content: |
          [Manager]
          DefaultTimeoutStopSec=15s
        mode: '0644'
      register: lower_shutdown_timeout

    - name: Disable SSH password authentication (keys only)
      ansible.builtin.copy:
        dest: /etc/ssh/sshd_config.d/99-ansible-disable-password-auth.conf
        mode: '0644'
        content: |
          # Managed by Ansible (prep-guests.yml)
          #
          # Enforce key-based SSH authentication.
          # Keep root login behavior unchanged; only disable password prompts.
          PasswordAuthentication no
          KbdInteractiveAuthentication no
          ChallengeResponseAuthentication no
      register: sshd_disable_password_auth
      notify: Restart ssh

    - name: Reload systemd daemon (if config changed)
      ansible.builtin.systemd:
        daemon_reload: true
      when: >
        (configure_auto_login.changed | default(false)) or
        (lower_shutdown_timeout.changed | default(false))

  handlers:
    - name: Restart getty service
      ansible.builtin.systemd:
        name: container-getty@1.service
        state: restarted
      when: is_lxc | default(false)

    - name: Restart rsyslog
      ansible.builtin.systemd:
        name: rsyslog
        state: restarted

    - name: Restart ssh
      ansible.builtin.systemd:
        name: ssh
        state: restarted
