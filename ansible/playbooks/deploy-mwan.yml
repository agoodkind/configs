---
# ============================================================================
# MWAN Multi-WAN Load Balancer Deployment
# ============================================================================
# Deploys mwan VM for multi-WAN load balancing with PCI passthrough
#   - X710 VF (trust mode) for AT&T 802.1X authentication
#   - I226-V NIC for Webpass (full passthrough to avoid MAC issues)
#   - Virtio for management and OPNsense link
#
# Required: VF must be created on Proxmox host first (x710-vf-setup.service)
# ============================================================================

- name: Load mwan configuration and setup VM
  hosts: localhost
  gather_facts: false
  vars_files:
    - ../inventory/group_vars/mwan_servers.yml
  tasks:
    - name: Set variables for VM creation
      ansible.builtin.set_fact:
        vm_hostname: "{{ mwan_hostname }}"
        vm_mgmt_bridge: "{{ mwan_mgmt_bridge | default('vmbr0') }}"
        vm_internal_bridge: "{{ mwan_bridge_name | default('mwanbr') }}"
        vm_x710_vf: "{{ pci_x710_vf | default('') }}"
        vm_webpass_nic: "{{ pci_webpass_nic | default('') }}"
        vm_dns_domain: "{{ mwan_dns_domain }}"
        vm_dns_servers: "{{ mwan_dns_servers }}"
        vm_mgmt_ip_config: "{{ mwan_mgmt_ip_config | default('ip=dhcp,ip6=dhcp') }}"

- name: Setup mwan VM
  ansible.builtin.import_playbook: setup-debian-vm.yml
  vars:
    hostname: "{{ hostvars['localhost']['vm_hostname'] }}"
    target_node: vault
    disk_size: "16"
    memory: "2048"
    cores: "2"
    network_interfaces:
      - "{{ hostvars['localhost']['vm_mgmt_bridge'] }}"
      - "{{ hostvars['localhost']['vm_internal_bridge'] }}"
    hostpci_devices:
      - "{{ hostvars['localhost']['vm_x710_vf'] }}"
      - "{{ hostvars['localhost']['vm_webpass_nic'] }}"
    vm_tags: "vm,mwan,network"
    mgmt_ip_config: "{{ hostvars['localhost']['vm_mgmt_ip_config'] }}"
    dns_domain: "{{ hostvars['localhost']['vm_dns_domain'] }}"
    dns_servers: "{{ hostvars['localhost']['vm_dns_servers'] }}"
    enable_serial: true
    serial_only: true  # Use serial console only, no VGA (saves VRAM)
    enable_qemu_agent: true
    enable_dns_registration: false  # MWAN handles DNS via interfaces config

- name: Configure MWAN VM
  hosts: mwan_servers
  become: true

  vars:
    mwan_config_dir: /etc/mwan
    repo_root: "{{ playbook_dir | dirname | dirname }}"

  tasks:
    - name: Wait for VM
      ansible.builtin.wait_for_connection:
        timeout: 60
      register: connection_check
      failed_when: false

    - name: Gather facts
      ansible.builtin.setup:
      when: connection_check.failed is not defined or not connection_check.failed

    - name: Verify Debian
      ansible.builtin.assert:
        that:
          - ansible_os_family == "Debian"
        fail_msg: >-
          This playbook requires Debian.
          Found: {{ ansible_os_family | default('unknown') }}
        success_msg: >-
          ✓ {{ ansible_distribution }}
          {{ ansible_distribution_version }}

    - name: Update apt cache
      ansible.builtin.apt:
        update_cache: true
        cache_valid_time: 3600

    - name: Install required packages
      ansible.builtin.apt:
        name:
          - wpasupplicant
          - dhcpcd5
          - nftables
          - iproute2
          - iptables
          - bash
          - curl
          - vlan
          - bridge-utils
          - ifupdown
        state: present

    - name: Get actual VMID from Proxmox
      delegate_to: vault.home.goodkind.io
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          qm list | awk '$2 == "{{ inventory_hostname }}" {print $1}'
        executable: /bin/bash
      register: vmid_lookup
      changed_when: false
      failed_when: vmid_lookup.stdout | length == 0

    - name: Set actual VMID
      ansible.builtin.set_fact:
        actual_vmid: "{{ vmid_lookup.stdout | trim }}"
        mwan_vmid: "{{ vmid_lookup.stdout | trim }}"  # Override group_vars

    - name: Get VM network config from Proxmox
      delegate_to: vault.home.goodkind.io
      ansible.builtin.command:
        cmd: qm config {{ actual_vmid }}
      register: vm_config
      changed_when: false

    - name: Parse virtio MAC addresses from VM config
      delegate_to: localhost
      ansible.builtin.set_fact:
        mwan_net0_mac: >-
          {{
            vm_config.stdout_lines
            | select('match', '^net0:.*virtio')
            | first
            | regex_search('virtio=([0-9A-Fa-f:]+)', '\1')
            | first
            | lower
          }}
        mwan_net1_mac: >-
          {{
            vm_config.stdout_lines
            | select('match', '^net1:.*virtio')
            | first
            | regex_search('virtio=([0-9A-Fa-f:]+)', '\1')
            | first
            | lower
          }}

    - name: Deploy interface discovery scripts
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/{{ item }}.j2"
        dest: /usr/local/bin/{{ item | replace('.j2', '') }}
        mode: '0755'
      loop:
        - find-interface-by-mac.sh.j2
        - find-interface-by-driver.sh.j2
        - add-interface-altname.sh.j2

    - name: Find interface by MAC (eth0 - management on vmbr0)
      ansible.builtin.command:
        cmd: /usr/local/bin/find-interface-by-mac.sh {{ mwan_net0_mac }}
      register: iface_eth0_result
      changed_when: false
      failed_when: false

    - name: Find interface by MAC (eth3 - internal on mwanbr)
      ansible.builtin.command:
        cmd: /usr/local/bin/find-interface-by-mac.sh {{ mwan_net1_mac }}
      register: iface_eth3_result
      changed_when: false
      failed_when: false

    - name: Find interface by driver (eth1 - X710 VF with iavf)
      ansible.builtin.command:
        cmd: /usr/local/bin/find-interface-by-driver.sh iavf
      register: iface_eth1_result
      changed_when: false
      failed_when: false

    - name: Find interface by driver (eth2 - I226-V with igc)
      ansible.builtin.command:
        cmd: /usr/local/bin/find-interface-by-driver.sh igc
      register: iface_eth2_result
      changed_when: false
      failed_when: false

    - name: Build interface mapping
      ansible.builtin.set_fact:
        interface_mapping:
          eth0: "{{ iface_eth0_result.stdout | default('') }}"
          eth1: "{{ iface_eth1_result.stdout | default('') }}"
          eth2: "{{ iface_eth2_result.stdout | default('') }}"
          eth3: "{{ iface_eth3_result.stdout | default('') }}"
        friendly_name_mapping:
          eth0: mgmt
          eth1: att
          eth2: webpass
          eth3: mwanbr

    - name: Display interface mapping
      ansible.builtin.debug:
        msg: |
          Interface mapping:
            eth0 (mgmt/vmbr0): {{ interface_mapping.eth0 }} ->
              altname: {{ friendly_name_mapping.eth0 }}
            eth1 (AT&T/X710 VF): {{ interface_mapping.eth1 }} ->
              altname: {{ friendly_name_mapping.eth1 }}
            eth2 (Webpass/I226-V): {{ interface_mapping.eth2 }} ->
              altname: {{ friendly_name_mapping.eth2 }}
            eth3 (internal/mwanbr): {{ interface_mapping.eth3 }} ->
              altname: {{ friendly_name_mapping.eth3 }}

    - name: Verify all interfaces were found
      ansible.builtin.assert:
        that:
          - interface_mapping[item] | length > 0
        fail_msg: "Could not find physical interface for {{ item }}"
        success_msg: "{{ item }} mapped to {{ interface_mapping[item] }}"
      loop:
        - eth0
        - eth1
        - eth2
        - eth3

    - name: Check if altnames already exist
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          ip link property show dev "{{ item.value }}" 2>/dev/null |
            grep -q "altname {{ item.key }}"
        executable: /bin/bash
      loop: "{{ interface_mapping | dict2items }}"
      register: altname_check
      changed_when: false
      failed_when: false

    - name: Add altnames to interfaces
      ansible.builtin.command:
        cmd: /usr/local/bin/add-interface-altname.sh "{{ item.item.value }}" "{{ item.item.key }}" true
      loop: "{{ altname_check.results }}"
      when: item.item.value != item.item.key
      changed_when: "'changed' in altname_add_result.stdout"
      failed_when: "'ERROR:' in altname_add_result.stdout"
      register: altname_add_result
      loop_control:
        label: "{{ item.item.key }} -> {{ item.item.value }}"

    - name: Check if friendly altnames already exist
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          ip link property show dev "{{ interface_mapping[item.key] }}" 2>/dev/null |
            grep -q "altname {{ item.value }}"
        executable: /bin/bash
      loop: "{{ friendly_name_mapping | dict2items }}"
      register: friendly_altname_check
      changed_when: false
      failed_when: false

    - name: Add friendly altnames to interfaces
      ansible.builtin.command:
        cmd: /usr/local/bin/add-interface-altname.sh "{{ interface_mapping[item.item.key] }}" "{{ item.item.value }}" false
      loop: "{{ friendly_altname_check.results }}"
      changed_when: "'changed' in friendly_altname_add_result.stdout"
      failed_when: "'ERROR:' in friendly_altname_add_result.stdout"
      register: friendly_altname_add_result
      loop_control:
        label: "{{ item.item.value }} -> {{ interface_mapping[item.item.key] }}"

    - name: Deploy udev rules for persistent interface naming
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/70-mwan-interface-names.rules.j2"
        dest: /etc/udev/rules.d/70-mwan-interface-names.rules
        mode: '0644'
      notify: Reload udev

    - name: Create configuration directories
      ansible.builtin.file:
        path: "{{ item }}"
        state: directory
        mode: '0755'
      loop:
        - "{{ mwan_config_dir }}"
        - /etc/sysctl.d
        - /etc/iproute2
        - /usr/local/bin
        - /etc/wpa_supplicant
        - /etc/dhcp

    - name: Configure dhcpcd to send hostname
      ansible.builtin.lineinfile:
        path: /etc/dhcpcd.conf
        line: "hostname"
        create: true
        mode: '0644'

    - name: Deploy wpa_supplicant config for AT&T 802.1X
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/wpa_supplicant.conf.j2"
        dest: /etc/wpa_supplicant/wpa_supplicant.conf
        mode: '0600'
      notify: Restart wpa_supplicant

    - name: Check for AT&T certificates
      ansible.builtin.stat:
        path: "/etc/wpa_supplicant/{{ item }}"
      loop:
        - ca_cert.pem
        - client_cert.pem
        - private_key.pem
      register: cert_check

    - name: Warn if certificates missing
      ansible.builtin.debug:
        msg: |
          ⚠️  Certificate {{ item.item }} missing!
          Upload after deploy:
          scp agoodkind@router:/conf/opnatt/wpa/*.pem \
            root@{{ inventory_hostname }}:/etc/wpa_supplicant/
          Then restart: systemctl restart wpa_supplicant-mwan
      when: not item.stat.exists
      loop: "{{ cert_check.results }}"

    - name: Deploy wpa_supplicant systemd service
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/wpa_supplicant.service.j2"
        dest: /etc/systemd/system/wpa_supplicant-mwan.service
        mode: '0644'
      notify: Reload systemd

    - name: Enable wpa_supplicant service
      ansible.builtin.systemd:
        name: wpa_supplicant-mwan
        enabled: true
        daemon_reload: true

    - name: Deploy AT&T VLAN bringup script
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/bringup-att-vlan.sh.j2"
        dest: /usr/local/bin/bringup-att-vlan.sh
        mode: '0755'

    - name: Deploy AT&T VLAN bringup systemd service
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/bringup-att-vlan.service.j2"
        dest: /etc/systemd/system/bringup-att-vlan.service
        mode: '0644'
      notify: Reload systemd

    - name: Enable AT&T VLAN bringup service
      ansible.builtin.systemd:
        name: bringup-att-vlan
        enabled: true
        daemon_reload: true

    - name: Get Webpass I226-V hardware MAC address
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          cat /sys/class/net/{{ interface_mapping.eth2 }}/address
        executable: /bin/bash
      register: webpass_hardware_mac
      changed_when: false

    - name: Display Webpass NIC spoofing info
      ansible.builtin.debug:
        msg: |
          Webpass I226-V NIC ({{ interface_mapping.eth2 }}):
            Hardware MAC: {{ webpass_hardware_mac.stdout }}
            Spoofed MAC:  {{ mwan_webpass_mac }}
            DUID:         {{ mwan_webpass_duid }}
            ⚠️  CRITICAL: MAC will be spoofed to {{ mwan_webpass_mac }}
              before interface up
            ⚠️  Webpass will REJECT any other MAC address!

    - name: Deploy dhcpcd config (MUST be before interfaces come up!)
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/dhcpcd.conf.j2"
        dest: /etc/dhcpcd.conf
        mode: '0644'
        backup: true

    - name: Deploy dhcpcd exit hook
      ansible.builtin.copy:
        src: "{{ repo_root }}/mwan/etc/dhcpcd.exit-hook"
        dest: /etc/dhcpcd.exit-hook
        mode: '0755'

    - name: Stop dhcpcd before interface reconfiguration
      ansible.builtin.systemd:
        name: dhcpcd
        state: stopped
      failed_when: false

    - name: Deploy sysctl config
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/sysctl-mwan.conf.j2"
        dest: /etc/sysctl.d/99-mwan.conf
        mode: '0644'
      notify: Apply sysctl

    - name: Deploy routing tables
      ansible.builtin.copy:
        src: "{{ repo_root }}/mwan/etc/iproute2/rt_tables"
        dest: /etc/iproute2/rt_tables
        mode: '0644'

    - name: Deploy network interfaces
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/interfaces.j2"
        dest: /etc/network/interfaces
        mode: '0644'
        backup: true
      notify: Restart networking

    - name: Deploy nftables config
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/nftables.conf.j2"
        dest: /etc/nftables.conf
        mode: '0644'
        backup: true
        vars:
          actual_att_iface: "{{ interface_mapping.eth1 }}"
          actual_webpass_iface: "{{ interface_mapping.eth2 }}"
          actual_internal_iface: "{{ interface_mapping.eth3 }}"
      notify: Reload nftables

    - name: Create systemd override for nftables
      ansible.builtin.file:
        path: /etc/systemd/system/nftables.service.d
        state: directory
        mode: '0755'

    - name: Deploy nftables systemd override
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/nftables.service.d-override.conf.j2"
        dest: /etc/systemd/system/nftables.service.d/override.conf
        mode: '0644'
      notify: Reload systemd

    - name: Deploy templated helper scripts
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/{{ item }}.j2"
        dest: /usr/local/bin/{{ item }}
        mode: '0755'
      loop:
        - update-routes.sh
        - health-check.sh

    - name: Deploy static helper scripts
      ansible.builtin.copy:
        src: "{{ repo_root }}/mwan/usr/local/bin/{{ item }}"
        dest: /usr/local/bin/{{ item }}
        mode: '0755'
      loop:
        - update-npt.sh

    - name: Deploy mwan-health systemd service
      ansible.builtin.template:
        src: "{{ repo_root }}/ansible/templates/mwan/mwan-health.service.j2"
        dest: /etc/systemd/system/mwan-health.service
        mode: '0644'
      notify: Reload systemd

    - name: Verify dhcpcd configuration before interface restart
      ansible.builtin.command:
        cmd: grep -q "^duid {{ mwan_webpass_duid }}" /etc/dhcpcd.conf
      changed_when: false
      register: duid_check
      failed_when: duid_check.rc != 0

    - name: Verify altnames are accessible
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          for iface in eth0 eth1 eth2 eth3; do
            if ! ip link show $iface >/dev/null 2>&1; then
              echo "ERROR: Interface $iface not accessible"
              exit 1
            fi
          done
          for iface in mgmt att webpass mwanbr; do
            if ! ip link show $iface >/dev/null 2>&1; then
              echo "ERROR: Interface $iface not accessible"
              exit 1
            fi
          done
          echo "All altnames accessible"
        executable: /bin/bash
      changed_when: false

    - name: Flush handlers (restarts networking with dhcpcd config in place)
      ansible.builtin.meta: flush_handlers

    - name: Wait for WAN interfaces to settle
      ansible.builtin.pause:
        seconds: 5

    - name: Verify AT&T VLAN interface is up (if certs present)
      ansible.builtin.wait_for:
        path: /sys/class/net/{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}
        state: present
        timeout: 90
      when: cert_check.results | selectattr('stat.exists') | list | length == 3
      failed_when: false
      register: vlan_interface_check

    - name: Check AT&T VLAN interface status
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          vlan_iface="{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}"
          if ip link show "$vlan_iface" 2>/dev/null | \
             grep -q "state UP"; then
            echo "UP"
            ip -4 addr show dev "$vlan_iface" | grep "inet " || \
              echo "No IPv4 yet"
          else
            echo "DOWN or not found"
            exit 1
          fi
        executable: /bin/bash
      when:
        - cert_check.results | selectattr('stat.exists') | list | length == 3
        - vlan_interface_check.failed is not defined or not vlan_interface_check.failed
      register: vlan_status
      changed_when: false
      failed_when: false

    - name: Display AT&T VLAN status
      ansible.builtin.debug:
        msg: |
          AT&T VLAN Interface Status:
          {{ vlan_status.stdout | default(
            'Interface not yet up - may need more time for authentication') }}
      when: cert_check.results | selectattr('stat.exists') | list | length == 3

    - name: Schedule reboot to apply all network changes cleanly
      ansible.builtin.debug:
        msg: |
          ⚠️  IMPORTANT: Network configuration deployed but NOT fully applied
          The VM should be rebooted to apply all changes cleanly:
            - udev rules for persistent interface names
            - Complete network interface configuration
            - MAC spoofing for Webpass
            - AT&T VLAN interface will be automatically brought up
              after 802.1X authentication

          Run: ssh root@mwan.home.goodkind.io reboot

    - name: Verify Webpass MAC spoofing succeeded
      ansible.builtin.shell:
        cmd: |
          set -o pipefail
          cat /sys/class/net/{{ interface_mapping.eth2 }}/address
        executable: /bin/bash
      register: webpass_current_mac
      changed_when: false
      failed_when: webpass_current_mac.stdout != mwan_webpass_mac

    - name: Confirm Webpass MAC spoofing
      ansible.builtin.debug:
        msg: |
          ✅ Webpass MAC spoofing verified:
            Interface: {{ interface_mapping.eth2 }}
            Current MAC: {{ webpass_current_mac.stdout }}
            Expected MAC: {{ mwan_webpass_mac }}
            Status: MATCH - Safe to bring up interface

    - name: Enable services
      ansible.builtin.systemd:
        name: "{{ item }}"
        enabled: true
        daemon_reload: true
      loop:
        - wpa_supplicant-mwan
        - bringup-att-vlan
        - dhcpcd
        - nftables
        - mwan-health

    - name: Start wpa_supplicant (if certs present)
      ansible.builtin.systemd:
        name: wpa_supplicant-mwan
        state: started
      when: cert_check.results | selectattr('stat.exists') | list | length == 3
      failed_when: false

    - name: Start AT&T VLAN bringup service (if certs present)
      ansible.builtin.systemd:
        name: bringup-att-vlan
        state: started
      when: cert_check.results | selectattr('stat.exists') | list | length == 3
      failed_when: false

    - name: Start dhcpcd service (will send hostname via DHCP INFORM)
      ansible.builtin.systemd:
        name: dhcpcd
        state: restarted
      failed_when: false

    - name: Verify dhcpcd is running
      ansible.builtin.systemd:
        name: dhcpcd
        state: started
      register: dhcpcd_status

    - name: Display dhcpcd status
      ansible.builtin.debug:
        msg: "dhcpcd service: {{ dhcpcd_status.status.ActiveState }}"

    - name: Start other services
      ansible.builtin.systemd:
        name: "{{ item }}"
        state: started
      loop:
        - nftables
        - mwan-health
      failed_when: false

    - name: Check health status
      ansible.builtin.command: /usr/local/bin/health-check.sh --status
      register: health_status
      changed_when: false
      failed_when: false

    - name: Display status
      ansible.builtin.debug:
        msg: >-
          {{ health_status.stdout_lines |
          default(['Run /usr/local/bin/health-check.sh --status']) }}

  handlers:
    - name: Reload systemd
      ansible.builtin.systemd:
        daemon_reload: true

    - name: Reload udev
      ansible.builtin.systemd:
        name: systemd-udevd
        state: reloaded

    - name: Restart networking
      ansible.builtin.shell: |
        set -o pipefail
        for iface in eth1 eth2 eth3; do
          if ip link show "$iface" 2>/dev/null | grep -q "state UP"; then
            ifdown "$iface" 2>/dev/null || true
          fi
        done
        sleep 2
        for iface in eth1 eth2 eth3; do
          if ip link show "$iface" 2>/dev/null | \
             grep -q "state DOWN\|state UNKNOWN"; then
            ifup "$iface" 2>/dev/null || true
          fi
        done
      args:
        executable: /bin/bash
      changed_when: true
      failed_when: false
      async: 30
      poll: 0

    - name: Restart wpa_supplicant
      ansible.builtin.systemd:
        name: wpa_supplicant-mwan
        state: restarted

    - name: Apply sysctl
      ansible.builtin.command: sysctl -p /etc/sysctl.d/99-mwan.conf
      changed_when: true

    - name: Restart dhcpcd
      ansible.builtin.systemd:
        name: dhcpcd
        state: restarted

    - name: Reload nftables
      ansible.builtin.systemd:
        name: nftables
        state: reloaded
      failed_when: false
      # nftables will load even if interfaces are DOWN
      # Rules simply won't match until interfaces come up
