#!/usr/sbin/nftables -f
# nftables configuration for mwan multi-WAN load balancer
# Generated by Ansible
#
# NOTE: Interfaces may be DOWN (e.g., cable unplugged) - this is OK.
# Rules will simply not match until interfaces come back up.
# nftables uses actual interface names (not altnames) for reliability.

flush ruleset

# Define variables - use actual kernel interface names
define MGMT_IFACE = "{{ actual_mgmt_iface | default(mwan_mgmt_iface) }}"
define ATT_IFACE = "{{ actual_att_iface | default(mwan_att_iface) }}.{{ mwan_att_vlan_id }}"
define WEBPASS_IFACE = "{{ actual_webpass_iface | default(mwan_webpass_iface) }}"
define INTERNAL_IFACE = "{{ actual_internal_iface | default(mwan_internal_iface) }}"
{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
define MB_IFACE = "{{ mwan_monkeybrains_iface }}"
{% endif %}

# Internal network (mwan <-> OPNsense link)
define INTERNAL_NET = 10.250.250.0/29

table inet filter {
    chain input {
        type filter hook input priority filter; policy drop;
        
        # Allow established/related
        ct state established,related accept
        
        # Allow loopback
        iif lo accept
        
        # Allow ICMP
        ip protocol icmp accept
        ip6 nexthdr icmpv6 accept
        
        # Allow SSH from management network
        iif $MGMT_IFACE tcp dport 22 accept
        # iif $INTERNAL_IFACE tcp dport 22 accept
        
        # Allow DHCP on management interface
        # iif $MGMT_IFACE udp sport 67 udp dport 68 accept
        # iif $MGMT_IFACE udp sport 547 udp dport 546 accept
        
        # Allow DHCP on WAN interfaces
        iif $ATT_IFACE udp sport 67 udp dport 68 accept
        iif $WEBPASS_IFACE udp sport 67 udp dport 68 accept
        iif $ATT_IFACE udp sport 547 udp dport 546 accept
        iif $WEBPASS_IFACE udp sport 547 udp dport 546 accept
{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
        iif $MB_IFACE udp sport 67 udp dport 68 accept
        iif $MB_IFACE udp sport 547 udp dport 546 accept
{% endif %}
        
        # Log dropped packets (rate limited)
        limit rate 1/second log prefix "nftables input drop: " drop
    }
    
    chain forward {
        type filter hook forward priority filter; policy drop;
        
        # Allow established/related
        ct state established,related accept
        
        # Allow forwarding from internal to WANs
        iif $INTERNAL_IFACE oif { $ATT_IFACE, $WEBPASS_IFACE
{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
            , $MB_IFACE
{% endif %}
        } accept
        
        # Allow forwarding from WANs to internal (for inbound services)
        iif { $ATT_IFACE, $WEBPASS_IFACE
{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
            , $MB_IFACE
{% endif %}
        } oif $INTERNAL_IFACE accept
        
        # Log dropped packets (rate limited)
        limit rate 1/second log prefix "nftables forward drop: " drop
    }
    
    chain output {
        type filter hook output priority filter; policy accept;
    }
}

table ip nat {
    # Connection tracking for load balancing
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;
        
        # Mark new connections for load balancing (fwmark)
        ct state new meta mark set numgen random mod 2 map { 0 : 1, 1 : 2 }
    }
    
    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;
        
        # 1:1 NAT for static IPs - AT&T
{% for mapping in mwan_static_mappings.att %}
        oif $ATT_IFACE ip saddr {{ mapping.internal }} snat to {{ mapping.external }}
{% endfor %}
        
        # 1:1 NAT for static IPs - Webpass
{% for mapping in mwan_static_mappings.webpass %}
        oif $WEBPASS_IFACE ip saddr {{ mapping.internal }} snat to {{ mapping.external }}
{% endfor %}
        
        # Default SNAT for other LAN traffic via AT&T (mark 1)
        oif $ATT_IFACE meta mark 1 ip saddr $INTERNAL_NET masquerade
        
        # Default SNAT for other LAN traffic via Webpass (mark 2)
        oif $WEBPASS_IFACE meta mark 2 ip saddr $INTERNAL_NET masquerade
    }
}

table ip6 nat {
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;
        
        # Inbound NPT - translate ISP prefix to internal
        # These will be dynamically set by update-npt.sh when PDs arrive
        # Called by 55-update-npt.sh (networkd-dispatcher hook)
    }
    
    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;
        
        # Outbound NPT / SNAT for IPv6 (programmed at runtime):
        # - LAN {{ mwan_internal_prefix }} -> PD /60 (per mark, via NPT)
        # - Bridge {{ mwan_internal_ipv6 | regex_replace('/64','') }}/64 -> WAN GUA (per mark, via SNAT)
        # Called by 55-update-npt.sh (networkd-dispatcher hook)
    }
}

table inet mangle {
    chain prerouting {
        type filter hook prerouting priority mangle; policy accept;
        
        # Mark traffic from static 1:1 NAT IPs to use specific WAN
        # AT&T static IPs (mark 1 = use AT&T WAN)
{% for mapping in mwan_static_mappings.att %}
        ip saddr {{ mapping.internal }} meta mark set 1
{% endfor %}
        
        # Webpass static IPs (mark 2 = use Webpass WAN)
{% for mapping in mwan_static_mappings.webpass %}
        ip saddr {{ mapping.internal }} meta mark set 2
{% endfor %}
        
        # Pin latency-sensitive traffic to AT&T (mark 1)
        # Failover: If AT&T down, update-routes.sh removes the fwmark rule,
        # and traffic falls through to main table (which uses Webpass)
{% if mwan_att_pinned_dests is defined %}
{% for dest in mwan_att_pinned_dests %}
        ip daddr {{ dest }} meta mark set 1
{% endfor %}
{% endif %}
        
        # Load-balance IPv6 from internal LAN (broader /60 + bridge /64)
        ip6 saddr {{ mwan_internal_prefix }} meta mark set numgen random mod 2 map { 0 : 1, 1 : 2 }
        
        # General traffic (no mark): Uses main table's multipath routing
        # Kernel automatically:
        #   - Load balances 50/50 when both WANs up
        #   - Fails over to single WAN when one is down
        # update-routes.sh manages the multipath route based on health
        
        # Restore mark for established connections (session affinity)
        ct state established,related meta mark set ct mark
    }
    
    chain postrouting {
        type filter hook postrouting priority mangle; policy accept;
        
        # Save mark to conntrack
        ct mark set meta mark
    }
}

