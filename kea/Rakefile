# frozen_string_literal: true

require 'dotenv'
require 'fileutils'
require 'json'
require 'base64'
require 'shellwords'
require_relative '../lib/rake_common'

# Load .env from current directory and parent directory
Dotenv.load('.env', '../.env')

# Include common helpers
# rubocop:disable Style/MixinUsage
extend RakeCommon
# rubocop:enable Style/MixinUsage

ROUTER_USER = ENV.fetch('ROUTER_USER', 'agoodkind')
ROUTER_HOST = ENV.fetch('ROUTER_HOST', '3d06:bad:b01::1')

##
# Format host string for SSH/SCP commands (handles IPv6 properly)
#
# @param host [String] the hostname/IP
# @return [String] properly formatted host string
def format_ssh_host(host)
  # IPv6 addresses need to be enclosed in brackets so SSH/SCP doesn't
  # try to parse colons as hostname separators
  if host.include?(':') && !host.start_with?('[')
    "[#{host}]"
  else
    host
  end
end

##
# Format host string for SSH commands (IPv6 addresses work bare)
#
# @param host [String] the hostname/IP
# @return [String] properly formatted host string for SSH
def format_ssh_host(host)
  host
end

##
# Format host string for SCP commands (IPv6 addresses need brackets)
#
# @param host [String] the hostname/IP
# @return [String] properly formatted host string for SCP
def format_scp_host(host)
  # IPv6 addresses need to be enclosed in brackets for SCP
  if host.include?(':') && !host.start_with?('[')
    "[#{host}]"
  else
    host
  end
end

##
# Execute command on router and return output
#
# @param args [Array] command and arguments
# @return [String] command output
def ssh_router(*)
  ssh_exec("#{ROUTER_USER}@#{format_ssh_host(ROUTER_HOST)}", *)
end

##
# Execute command on router with error handling
#
# @param args [Array] command and arguments
# @return [void]
def ssh_router_sh(*)
  ssh_exec_sh("#{ROUTER_USER}@#{format_ssh_host(ROUTER_HOST)}", *)
end

##
# Upload config file to router home directory
#
# @param config_file [String] local config file path
# @return [void]
def router_upload(config_file)
  scp_to_host(config_file, "#{ROUTER_USER}@#{format_scp_host(ROUTER_HOST)}", '~/')
end

##
# Test config file on router
#
# @param binary [String] full path to kea binary
# @param config_file [String] config file name in home directory
# @return [void]
def router_test(binary, config_file)
  ssh_router_sh('sudo', binary, '-t', "$HOME/#{config_file}")
end

##
# Backup and install config on router
#
# @param config_file [String] config file name
# @param dest_path [String] destination path
# @return [void]
def router_install(config_file, dest_path)
  timestamp = Time.now.strftime('%Y%m%d_%H%M%S')

  # Backup existing file if it exists
  begin
    ssh_router_sh('sudo', 'test', '-f', dest_path)
    ssh_router_sh('sudo', 'cp', dest_path, "#{dest_path}.backup.#{timestamp}")
  rescue StandardError
    # File doesn't exist, skip backup
  end

  # Install new file
  ssh_router_sh('sudo', 'mv', "$HOME/#{config_file}", dest_path)
  ssh_router_sh('sudo', 'chown', 'root:wheel', dest_path)
  ssh_router_sh('sudo', 'chmod', '640', dest_path)
end

KEA_CTRL_URL = 'http://127.0.0.1:8000/'

##
# Call Kea Control Agent on the router (via SSH) and return parsed JSON.
#
# @param payload [Hash] Kea control agent JSON payload
# @return [Array<Hash>] response array from Kea control agent
def kea_api(payload)
  json = JSON.generate(payload)
  b64 = Base64.strict_encode64(json)

  pipeline = "echo #{b64.shellescape} | base64 -d | " \
             "curl -sS -X POST -H 'Content-Type: application/json' --data-binary @- #{KEA_CTRL_URL.shellescape}"

  # IMPORTANT: ssh concatenates arguments with spaces.  We must pass the whole
  # pipeline as a single remote argument to keep it intact for /bin/sh -lc.
  raw = ssh_router("sudo /bin/sh -lc #{pipeline.shellescape}")

  JSON.parse(raw)
end

def kea_ok?(resp)
  resp.is_a?(Array) && resp[0].is_a?(Hash) && resp[0]['result'] == 0
end

def kea_leases(resp)
  return [] unless kea_ok?(resp)

  leases = resp.dig(0, 'arguments', 'leases')
  leases.is_a?(Array) ? leases : []
end

def kea_single_lease(resp)
  return nil unless kea_ok?(resp)

  lease = resp[0]['arguments']
  lease.is_a?(Hash) ? lease : nil
end

def load_reservations4(subnet_id)
  data = JSON.parse(File.read('kea-dhcp4.conf'))
  subnet = data.fetch('Dhcp4').fetch('subnet4').find { |s| s['id'] == subnet_id }
  raise "subnet4 id=#{subnet_id} not found" if subnet.nil?

  (subnet['reservations'] || []).map do |r|
    {
      hwaddr: (r['hw-address'] || '').downcase,
      ip: r['ip-address'],
      hostname: r['hostname']
    }
  end
end

def load_reservations6(subnet_id)
  data = JSON.parse(File.read('kea-dhcp6.conf'))
  subnet = data.fetch('Dhcp6').fetch('subnet6').find { |s| s['id'] == subnet_id }
  raise "subnet6 id=#{subnet_id} not found" if subnet.nil?

  (subnet['reservations'] || []).map do |r|
    ips = r['ip-addresses'] || []
    {
      duid: (r['duid'] || '').downcase,
      ip: ips[0],
      hostname: r['hostname']
    }
  end
end

namespace :router do
  desc 'Push kea-dhcp4.conf to router'
  task :push_dhcp4 do
    puts '‚ñ∂Ô∏è  Uploading DHCP4 config...'
    router_upload('kea-dhcp4.conf')
    puts '‚úÖ Config uploaded'
  end

  desc 'Test kea-dhcp4.conf on router'
  task :test_dhcp4 do
    puts '‚ñ∂Ô∏è  Testing DHCP4 config...'
    router_test('/usr/local/sbin/kea-dhcp4', 'kea-dhcp4.conf')
    puts '‚úÖ Configuration valid'
  end

  desc 'Install kea-dhcp4.conf on router'
  task :install_dhcp4 do
    puts '‚ñ∂Ô∏è  Installing DHCP4 config...'
    router_install('kea-dhcp4.conf', '/usr/local/etc/kea/kea-dhcp4.conf')
    puts '‚úÖ Configuration installed'
  end

  desc 'Deploy kea-dhcp4.conf to router'
  task deploy_dhcp4: %i[push_dhcp4 test_dhcp4 install_dhcp4 restart]

  desc 'Push kea-dhcp6.conf to router'
  task :push_dhcp6 do
    puts '‚ñ∂Ô∏è  Uploading DHCP6 config...'
    router_upload('kea-dhcp6.conf')
    puts '‚úÖ Config uploaded'
  end

  desc 'Test kea-dhcp6.conf on router'
  task :test_dhcp6 do
    puts '‚ñ∂Ô∏è  Testing DHCP6 config...'
    router_test('/usr/local/sbin/kea-dhcp6', 'kea-dhcp6.conf')
    puts '‚úÖ Configuration valid'
  end

  desc 'Install kea-dhcp6.conf on router'
  task :install_dhcp6 do
    puts '‚ñ∂Ô∏è  Installing DHCP6 config...'
    router_install('kea-dhcp6.conf', '/usr/local/etc/kea/kea-dhcp6.conf')
    puts '‚úÖ Configuration installed'
  end

  desc 'Deploy kea-dhcp6.conf to router'
  task deploy_dhcp6: %i[push_dhcp6 test_dhcp6 install_dhcp6 restart]

  desc 'Restart Kea DHCP services on router'
  task :restart do
    puts '‚ñ∂Ô∏è  Restarting Kea services...'
    ssh_router_sh('sudo', 'configctl', 'kea', 'restart')
    puts '‚úÖ Services restarted'
  end

  desc 'Deploy all Kea configs to router'
  task deploy: %i[deploy_dhcp4 deploy_dhcp6 restart] do
    puts ''
    puts '‚úÖ Router deployment complete'
  end
end

namespace :lease do
  desc 'Delete DHCPv4 lease by IP on router (example: rake lease:delete4_by_ip[10.250.0.24])'
  task :delete4_by_ip, [:ip] do |_t, args|
    ip = args[:ip].to_s.strip
    raise 'ip is required' if ip.empty?

    resp = kea_api(
      'command' => 'lease4-del',
      'service' => ['dhcp4'],
      'arguments' => { 'ip-address' => ip }
    )
    puts JSON.pretty_generate(resp)
  end

  desc 'Delete DHCPv6 lease by IP on router (example: rake lease:delete6_by_ip[3d06:bad:b01::28])'
  task :delete6_by_ip, [:ip] do |_t, args|
    ip = args[:ip].to_s.strip
    raise 'ip is required' if ip.empty?

    resp = kea_api(
      'command' => 'lease6-del',
      'service' => ['dhcp6'],
      'arguments' => { 'ip-address' => ip }
    )
    puts JSON.pretty_generate(resp)
  end

  desc 'Enforce DHCPv4+DHCPv6 reservations by deleting conflicting leases (default subnet id: 10)'
  task :enforce_reservations, [:subnet_id] do |_t, args|
    subnet_id = (args[:subnet_id] || '10').to_i

    puts "‚ñ∂Ô∏è  Enforcing reservations for subnet id #{subnet_id} (v4 + v6)"

    # DHCPv4
    r4 = load_reservations4(subnet_id)
    by_hw = r4.to_h { |r| [r[:hwaddr], r] }
    by_ip = r4.to_h { |r| [r[:ip], r] }

    # 1) Remove extra leases per hwaddr that aren't the reserved IP.
    by_hw.each_value do |r|
      next if r[:hwaddr].to_s.empty? || r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease4-get-by-hw-address',
        'service' => ['dhcp4'],
        'arguments' => { 'hw-address' => r[:hwaddr] }
      )
      kea_leases(resp).each do |lease|
        ip = lease['ip-address']
        next if ip == r[:ip]

        puts "üßπ DHCP4: deleting extra lease #{ip} for #{r[:hostname]} (#{r[:hwaddr]})"
        kea_api(
          'command' => 'lease4-del',
          'service' => ['dhcp4'],
          'arguments' => { 'ip-address' => ip }
        )
      end
    end

    # 2) Ensure reserved IP isn't held by the wrong hwaddr.
    by_ip.each_value do |r|
      next if r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease4-get',
        'service' => ['dhcp4'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
      lease = kea_single_lease(resp)
      next if lease.nil?

      got = lease['hw-address'].to_s.downcase
      next if got.empty? || got == r[:hwaddr]

      puts "üßπ DHCP4: deleting conflicting lease #{r[:ip]} held by #{got} (wanted #{r[:hwaddr]} #{r[:hostname]})"
      kea_api(
        'command' => 'lease4-del',
        'service' => ['dhcp4'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
    end

    # DHCPv6
    r6 = load_reservations6(subnet_id)
    by_duid = r6.to_h { |r| [r[:duid], r] }
    by_ip6 = r6.to_h { |r| [r[:ip], r] }

    # 1) Remove extra leases per DUID that aren't the reserved IP.
    by_duid.each_value do |r|
      next if r[:duid].to_s.empty? || r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease6-get-by-duid',
        'service' => ['dhcp6'],
        'arguments' => { 'duid' => r[:duid] }
      )
      kea_leases(resp).each do |lease|
        ip = lease['ip-address']
        next if ip == r[:ip]

        puts "üßπ DHCP6: deleting extra lease #{ip} for #{r[:hostname]} (#{r[:duid]})"
        kea_api(
          'command' => 'lease6-del',
          'service' => ['dhcp6'],
          'arguments' => { 'ip-address' => ip }
        )
      end
    end

    # 2) Ensure reserved IP isn't held by the wrong DUID.
    by_ip6.each_value do |r|
      next if r[:ip].to_s.empty?

      resp = kea_api(
        'command' => 'lease6-get',
        'service' => ['dhcp6'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
      lease = kea_single_lease(resp)
      next if lease.nil?

      got = lease['duid'].to_s.downcase
      next if got.empty? || got == r[:duid]

      puts "üßπ DHCP6: deleting conflicting lease #{r[:ip]} held by #{got} (wanted #{r[:duid]} #{r[:hostname]})"
      kea_api(
        'command' => 'lease6-del',
        'service' => ['dhcp6'],
        'arguments' => { 'ip-address' => r[:ip] }
      )
    end

    puts '‚úÖ Reservation enforcement completed'
    puts 'Next: renew clients (e.g. restart networkd or networkctl renew eth0) on affected containers.'
  end
end

##
# Strip SSH messages and extract JSON from output
#
# @param output [String] raw SSH output that may contain non-JSON prefix
# @return [String] JSON portion of output
def extract_json(output)
  json_start = output.index(/[\[{]/)
  json_start ? output[json_start..] : output
end

namespace :lease do
  ##
  # Execute kea-ctrl-agent command on router
  #
  # @param command [String] command name (e.g., "lease4-del")
  # @param arguments [Hash] command arguments
  # @return [Hash] parsed JSON response
  def kea_ctrl_command(command, arguments = {})
    payload = {
      command: command,
      service: ['dhcp4'],
      arguments: arguments
    }.to_json

    # Use same pattern as kea_api - pass as single shell command to avoid
    # SSH argument quoting issues that cause "Permanent Redirect" errors
    b64 = Base64.strict_encode64(payload)
    pipeline = "echo #{b64.shellescape} | base64 -d | " \
               "curl -sS -X POST -H 'Content-Type: application/json' --data-binary @- #{KEA_CTRL_URL.shellescape}"
    output = ssh_router("sudo /bin/sh -lc #{pipeline.shellescape}")

    result = JSON.parse(output)
    # API returns an array, extract first element
    result.is_a?(Array) ? result[0] : result
  rescue JSON::ParserError, StandardError => e
    puts "   Error: #{e.message}" if verbose?
    { 'result' => 1, 'text' => e.message }
  end

  desc 'Delete IPv4 lease by IP address'
  task :delete_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:delete_by_ip[10.250.0.10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting lease for IP #{ip_address}..."
    result = kea_ctrl_command('lease4-del', { 'ip-address' => ip_address })
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv4 lease by MAC address'
  task :delete_by_mac, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:delete_by_mac[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting lease for MAC #{mac_address} in subnet #{subnet_id}..."
    result = kea_ctrl_command('lease4-del', {
                                'subnet-id' => subnet_id.to_i,
                                'identifier-type' => 'hw-address',
                                'identifier' => mac_address
                              })
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv4 lease by client-id'
  task :delete_by_client_id, [:client_id, :subnet_id] do |_t, args|
    client_id = args[:client_id]
    subnet_id = args[:subnet_id] || '10'

    if client_id.nil? || client_id.empty?
      puts '‚ùå Error: Client ID required'
      puts '   Usage: rake lease:delete_by_client_id[ff:b2:86:34:f1:00:02:00:00:ab:11:ca:fb:28:d4:fd:77:a5:93,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting lease for client-id #{client_id} in subnet #{subnet_id}..."
    result = kea_ctrl_command('lease4-del', {
                                'subnet-id' => subnet_id.to_i,
                                'identifier-type' => 'client-id',
                                'identifier' => client_id
                              })
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Get IPv4 lease by IP address'
  task :get_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:get_by_ip[10.250.0.10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Getting lease for IP #{ip_address}..."
    result = kea_ctrl_command('lease4-get', { 'ip-address' => ip_address })
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      lease = result['arguments']['leases'].first
      if lease
        puts '‚úÖ Lease found:'
        puts "   IP: #{lease['ip-address']}"
        puts "   MAC: #{lease['hw-address']}"
        puts "   Client-ID: #{lease['client-id'] || '(none)'}"
        puts "   Hostname: #{lease['hostname'] || '(none)'}"
        puts "   State: #{lease['state']}"
        puts "   Valid lifetime: #{lease['valid-lft']}s"
      else
        puts '‚ö†Ô∏è  No lease found'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'List all active IPv4 leases for a MAC address'
  task :list_by_mac, [:mac_address] do |_t, args|
    mac_address = args[:mac_address]
    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:list_by_mac[bc:24:11:1d:2c:0f]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Listing leases for MAC #{mac_address}..."
    result = kea_ctrl_command('lease4-get-all', {})
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select { |l| l['hw-address']&.downcase == mac_address.downcase }
      if leases.empty?
        puts "‚ö†Ô∏è  No leases found for MAC #{mac_address}"
      else
        puts "‚úÖ Found #{leases.length} lease(s):"
        leases.each do |lease|
          puts "   IP: #{lease['ip-address']}, State: #{lease['state']}, Client-ID: #{lease['client-id'] || '(none)'}"
        end
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Clean up conflicting leases for a MAC address (keeps only active lease)'
  task :cleanup_conflicts, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:cleanup_conflicts[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Cleaning up conflicting leases for MAC #{mac_address}..."
    result = kea_ctrl_command('lease4-get-all', {})
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['hw-address']&.downcase == mac_address.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "‚úÖ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "‚ö†Ô∏è  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']}..."
          del_result = kea_ctrl_command('lease4-del', { 'ip-address' => lease['ip-address'] })
          if del_result['result'] == 0
            puts "   ‚úÖ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ‚ö†Ô∏è  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '‚úÖ Cleanup complete'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  end

  desc 'Delete IPv6 lease by IP address'
  task :delete6_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:delete6_by_ip[3d06:bad:b01::66]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting IPv6 lease for IP #{ip_address}..."
    payload = {
      command: 'lease6-del',
      service: ['dhcp6'],
      arguments: { 'ip-address' => ip_address }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        KEA_CTRL_URL)
    result = JSON.parse(extract_json(output))
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Delete IPv6 lease by DUID'
  task :delete6_by_duid, [:duid, :subnet_id, :iaid] do |_t, args|
    duid = args[:duid]
    subnet_id = args[:subnet_id] || '10'
    iaid = args[:iaid] || '0'

    if duid.nil? || duid.empty?
      puts '‚ùå Error: DUID required'
      puts '   Usage: rake lease:delete6_by_duid[00:02:00:00:ab:11:87:e8:a6:25:af:c9:82:df,10,0]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Deleting IPv6 lease for DUID #{duid} in subnet #{subnet_id}..."
    payload = {
      command: 'lease6-del',
      service: ['dhcp6'],
      arguments: {
        'subnet-id' => subnet_id.to_i,
        'identifier-type' => 'duid',
        'identifier' => duid,
        'iaid' => iaid.to_i
      }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        KEA_CTRL_URL)
    result = JSON.parse(extract_json(output))
    if result['result'] == 0
      puts "‚úÖ Lease deleted: #{result['text']}"
    elsif result['result'] == 3
      puts "‚ö†Ô∏è  No lease found: #{result['text']}"
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Get IPv6 lease by IP address'
  task :get6_by_ip, [:ip_address] do |_t, args|
    ip_address = args[:ip_address]
    if ip_address.nil? || ip_address.empty?
      puts '‚ùå Error: IP address required'
      puts '   Usage: rake lease:get6_by_ip[3d06:bad:b01::c]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Getting IPv6 lease for IP #{ip_address}..."
    payload = {
      command: 'lease6-get',
      service: ['dhcp6'],
      arguments: { 'ip-address' => ip_address }
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        KEA_CTRL_URL)
    result = JSON.parse(extract_json(output))
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      lease = result['arguments']['leases'].first
      if lease
        puts '‚úÖ Lease found:'
        puts "   IP: #{lease['ip-address']}"
        puts "   DUID: #{lease['duid']}"
        puts "   MAC: #{lease['hw-address'] || '(none)'}"
        puts "   Hostname: #{lease['hostname'] || '(none)'}"
        puts "   State: #{lease['state']}"
        puts "   IAID: #{lease['iaid']}"
      else
        puts '‚ö†Ô∏è  No lease found'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Clean up conflicting IPv6 leases for a DUID (keeps only active lease)'
  task :cleanup6_conflicts, [:duid, :subnet_id] do |_t, args|
    duid = args[:duid]
    subnet_id = args[:subnet_id] || '10'

    if duid.nil? || duid.empty?
      puts '‚ùå Error: DUID required'
      puts '   Usage: rake lease:cleanup6_conflicts[00:02:00:00:ab:11:87:e8:a6:25:af:c9:82:df,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Cleaning up conflicting IPv6 leases for DUID #{duid}..."
    payload = {
      command: 'lease6-get-all',
      service: ['dhcp6'],
      arguments: {}
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        KEA_CTRL_URL)
    result = JSON.parse(extract_json(output))
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['duid']&.downcase == duid.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "‚úÖ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "‚ö†Ô∏è  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']}..."
          del_payload = {
            command: 'lease6-del',
            service: ['dhcp6'],
            arguments: { 'ip-address' => lease['ip-address'] }
          }.to_json
          del_output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                                  '-H', 'Content-Type: application/json',
                                  '-d', del_payload,
                                  KEA_CTRL_URL)
          del_result = JSON.parse(extract_json(del_output))
          if del_result['result'] == 0
            puts "   ‚úÖ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ‚ö†Ô∏è  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '‚úÖ Cleanup complete'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end

  desc 'Clean up conflicting IPv6 leases for a MAC address (keeps only active lease)'
  task :cleanup6_by_mac, [:mac_address, :subnet_id] do |_t, args|
    mac_address = args[:mac_address]
    subnet_id = args[:subnet_id] || '10'

    if mac_address.nil? || mac_address.empty?
      puts '‚ùå Error: MAC address required'
      puts '   Usage: rake lease:cleanup6_by_mac[bc:24:11:1d:2c:0f,10]'
      exit 1
    end

    puts "‚ñ∂Ô∏è  Cleaning up conflicting IPv6 leases for MAC #{mac_address}..."
    payload = {
      command: 'lease6-get-all',
      service: ['dhcp6'],
      arguments: {}
    }.to_json

    output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                        '-H', 'Content-Type: application/json',
                        '-d', payload,
                        KEA_CTRL_URL)
    result = JSON.parse(extract_json(output))
    if result['result'] == 0 && result['arguments'] && result['arguments']['leases']
      leases = result['arguments']['leases'].select do |l|
        l['hw-address']&.downcase == mac_address.downcase &&
          l['subnet-id'] == subnet_id.to_i &&
          l['state'] == 0 # Active leases only
      end

      if leases.length <= 1
        puts "‚úÖ No conflicts found (found #{leases.length} active lease(s))"
      else
        puts "‚ö†Ô∏è  Found #{leases.length} active leases, keeping most recent..."
        # Sort by cltt (client last transmission time) descending
        leases.sort_by! { |l| -(l['cltt'] || 0) }
        leases_to_delete = leases[1..-1] # Keep first (most recent), delete rest

        leases_to_delete.each do |lease|
          puts "   Deleting lease for IP #{lease['ip-address']} (DUID: #{lease['duid']})..."
          del_payload = {
            command: 'lease6-del',
            service: ['dhcp6'],
            arguments: { 'ip-address' => lease['ip-address'] }
          }.to_json
          del_output = ssh_router('sudo', 'curl', '-s', '-X', 'POST',
                                  '-H', 'Content-Type: application/json',
                                  '-d', del_payload,
                                  KEA_CTRL_URL)
          del_result = JSON.parse(extract_json(del_output))
          if del_result['result'] == 0
            puts "   ‚úÖ Deleted lease for #{lease['ip-address']}"
          else
            puts "   ‚ö†Ô∏è  Failed to delete lease for #{lease['ip-address']}: #{del_result['text']}"
          end
        end
        puts '‚úÖ Cleanup complete'
      end
    else
      puts "‚ùå Error: #{result['text']}"
      exit 1
    end
  rescue JSON::ParserError, StandardError => e
    puts "‚ùå Error: #{e.message}"
    exit 1
  end
end

desc 'Show available tasks'
task :help do
  puts 'Available tasks:'
  puts ''
  system('rake --tasks')
end

desc 'Default task - show available tasks'
task default: 'help'
