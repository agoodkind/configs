#!/bin/bash
# Generated by Ansible
#
# What it does (symptoms):
# - Provides a single “operator UX” entrypoint to validate routing/NPT/health and to run trace sessions.
# - Helps confirm fixes with evidence (rules present, routes correct, egress IPs match expectations).
#
# What it does (technical):
# - Runs read-only inspection commands (ip route/rule, nft ruleset, networkctl).
# - Can run `update-routes.sh`, `health-check.sh --check`, and NPT hook invocations with an explicit `MWAN_TRACE_ID`
#   to generate correlated JSON logs in `/var/log/mwan-debug.log`.
#
# Dependency graph:
# - Manual tool only (not used by systemd directly).
# - Calls into: `update-routes.sh`, `health-check.sh`, and the dispatcher hooks for targeted debugging.

set -euo pipefail

IFACES=(
  "{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}"
  "{{ mwan_webpass_iface }}"
)
PING6_TARGETS=("2606:4700:4700::1111" "2620:fe::9")
CURL_TARGETS=("https://ifconfig.co" "https://api.ipify.org")
LB_ITER=${LB_ITER:-6}
PING4_TARGETS=("1.1.1.1" "8.8.8.8")

# Basic color helpers (honor NO_COLOR)
if [ -z "${NO_COLOR:-}" ]; then
  C_BOLD="\033[1m"; C_DIM="\033[2m"; C_RED="\033[31m"
  C_GRN="\033[32m"; C_CYN="\033[36m"; C_RST="\033[0m"
else
  C_BOLD=""; C_DIM=""; C_RED=""; C_GRN=""; C_CYN=""; C_RST=""
fi

usage() {
    cat <<'EOT'
Usage: mwan-debug.sh [command] [args...]
Commands:
  trace-start  Start an end-to-end trace session (prints traceId)
  trace-tail   Tail the JSON debug log (optionally filter by traceId)
  trace-stop   Stop background trace tools started by trace-start
  prefixes     Show PDs (routes + journal)
  routes       Show proto dhcp routes
  npt          Show ip6 nat NPT rules
  status       Show networkctl status for WAN ifaces
  stats        Show link stats for WAN ifaces
  pd-test      Verify PD egress after removing proto dhcp routes
  ping4 [if]   Ping IPv4 targets from iface (default first WAN)
  ping6 [if]   Ping IPv6 targets from iface (default first WAN)
  curl4 [if]   curl -4 from iface to ifconfig.co/api.ipify.org
  curl6 [if]   curl -6 from iface to ifconfig.co/api.ipify.org
  lb4          Curl -4 repeatedly (main table) to show mix of egress
  lb6          Curl -6 repeatedly (main table) to show mix of egress
  lb4-ifaces   Curl -4 alternating WAN ifaces (no mgmt)
  lb6-ifaces   Curl -6 alternating WAN ifaces (no mgmt)
  policy       Show ip rules, WAN tables, and mangle marks
  sim4         Route-get IPv4 from LAN src (incl. marks 1/2)
  sim6         Route-get IPv6 from LAN src (incl. marks 1/2)
EOT
}

trace_id() {
    # short-ish, readable trace ID for correlating events across scripts
    date +"%Y%m%d-%H%M%S-$$"
}

trace_start() {
    local id="${1:-$(trace_id)}"
    export MWAN_TRACE_ID="$id"
    echo "traceId=$MWAN_TRACE_ID"
    echo "Writing JSON lines to /var/log/mwan-debug.log"
    echo
    echo "== snapshot =="
    ip -4 route show default || true
    ip -6 route show default || true
    ip rule show || true
    ip -6 rule show || true
    nft list ruleset | sed -n '1,220p' || true
    echo
    echo "== run helpers (with traceId) =="
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /usr/local/bin/update-routes.sh || true
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /usr/local/bin/health-check.sh --check || true
    # If PD is not discoverable, 55-update-npt.sh has a static-prefix fallback.
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /etc/networkd-dispatcher/routable.d/55-update-npt.sh "{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}" routable || true
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /etc/networkd-dispatcher/routable.d/55-update-npt.sh "{{ mwan_webpass_iface }}" routable || true
    echo
    echo "== hint =="
    echo "mwan trace-tail $MWAN_TRACE_ID"
}

trace_tail() {
    local id="${1:-}"
    if [ -z "$id" ]; then
        tail -n 200 -f /var/log/mwan-debug.log
    else
        tail -n 500 -f /var/log/mwan-debug.log | grep -F "\"traceId\":\"$id\""
    fi
}

trace_stop() {
    # placeholder for future background collectors; keep command for UX consistency
    echo "No background collectors to stop."
}

show_pd() {
    echo "== Proto dhcp routes =="
    ip -6 route show proto dhcp || true
    echo
    echo "== Delegated prefixes from journal (last per iface) =="
    for ifc in "${IFACES[@]}"; do
        pref=$(journalctl -u systemd-networkd -b |
            grep "$ifc: DHCP: received delegated prefix" | tail -1 | awk '{print $NF}')
        echo "$ifc: ${pref:-none}"
    done
}

show_routes() {
    ip -6 route show proto dhcp || true
}

show_nft() {
    nft list table ip6 nat || true
}

show_status() {
    for ifc in "${IFACES[@]}"; do
        echo "== $ifc =="
        networkctl status "$ifc" --no-pager || true
        echo
    done
}

show_stats() {
    for ifc in "${IFACES[@]}"; do
        echo "== $ifc =="
        ip -s link show dev "$ifc" || true
        echo
    done
}

run_ping6() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${PING6_TARGETS[@]}"; do
        echo "Ping6 $tgt via $ifc"
        ping -6 -c 3 -I "$ifc" "$tgt" || true
        echo
    done
}

run_ping4() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${PING4_TARGETS[@]}"; do
        echo "Ping4 $tgt via $ifc"
        ping -c 3 -I "$ifc" "$tgt" || true
        echo
    done
}

run_curl4() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${CURL_TARGETS[@]}"; do
        echo "curl4 $tgt via $ifc"
        CURL_IFACE="$ifc" CURL_IP_VERSION=4 curl -4 --interface "$ifc" -s "$tgt" || true
        echo
    done
}

run_curl6() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${CURL_TARGETS[@]}"; do
        echo "curl6 $tgt via $ifc"
        CURL_IFACE="$ifc" CURL_IP_VERSION=6 curl -6 --interface "$ifc" -s "$tgt" || true
        echo
    done
}

get_pd() {
    local ifc="$1" pd
    pd=$(ip -6 route show proto dhcp dev "$ifc" | awk '{print $1; exit}')
    if [ -z "$pd" ] && [ -f "/var/lib/mwan/pd-$ifc" ]; then
        pd=$(head -1 "/var/lib/mwan/pd-$ifc")
    fi
    if [ -z "$pd" ]; then
        pd=$(journalctl -u systemd-networkd -b |
            grep "$ifc: DHCP: received delegated prefix" | tail -1 | awk '{print $NF}')
    fi
    echo "$pd"
}

confirm_pd_test() {
    echo "WARNING: this test will SPLINTER the PD (temp addrs, drop proto-dhcp"
    echo "routes) and may disrupt downstream IPv6 briefly until renew."
    echo "It also curls a far endpoint to confirm seen IP is in-prefix."
    read -r -p "Proceed? [y/N] " ans
    case "${ans:-n}" in
        y|Y) ;;
        *) echo "Aborted."; exit 1 ;;
    esac
}

run_pd_test() {
    confirm_pd_test

    local tgt="https://ifconfig.co"
    declare -a ADDR_PREFS IFCS PDS EXISTED
    declare -a PING_OK FAR_IP PREFIX_OK
    local sep="────────────────────────────────────────────────────────────"

    echo "╔════════════════════════════════════════════════════════════╗"
    printf "║ %-58s ║\n" "PD EGRESS VERIFICATION (splinters PD; temporary disruption)"
    printf "║ %-58s ║\n" "Target: $tgt"
    echo "╚════════════════════════════════════════════════════════════╝"

    echo "Deleting proto dhcp PD routes to prove PD egress without them."
    echo "(They will reappear on the next DHCPv6 renew.)"
    for r in $(ip -6 route show proto dhcp | awk '{print $1}'); do
        ip -6 route del "$r" proto dhcp || true
    done
    ip -6 route show proto dhcp || true

    for ifc in "${IFACES[@]}"; do
        pd=$(get_pd "$ifc")
        if [ -z "$pd" ]; then
            echo "$ifc: no PD found; skipping"
            continue
        fi
        addr="${pd%/*}2"
        pref="${pd#*/}"
        already=$(ip -6 addr show dev "$ifc" | awk -v a="$addr" '$2 ~ "/" && $2 ~ a"/"{print "yes"}')
        echo "$ifc: PD=$pd addr=$addr/$pref (existing=${already:-no})"
        if [ -z "$already" ]; then
            ip -6 addr add "$addr/$pref" dev "$ifc" nodad || true
        fi
        ADDR_PREFS+=("$addr/$pref")
        IFCS+=("$ifc")
        PDS+=("$pd")
        EXISTED+=("${already:-no}")
    done
    sleep 1

    for i in "${!ADDR_PREFS[@]}"; do
        addr_pref="${ADDR_PREFS[$i]}"
        ifc="${IFCS[$i]}"
        pd="${PDS[$i]}"
        addr="${addr_pref%/*}"
        pref="${addr_pref#*/}"
        echo
        echo "$sep"
        printf "%-11s %s\n" "IFACE" "$ifc"
        printf "%-11s %s\n" "PD" "$pd"
        printf "%-11s %s/%s\n" "TEST ADDR" "$addr" "$pref"
        echo "$sep"
        ip -6 route get 2606:4700:4700::1111 from "$addr" oif "$ifc" || true
        printf "%-11s %s%s%s\n" "PING" "$ifc from " "$addr" ""
        if ping -6 -c 3 -W 5 -I "${addr}%${ifc}" 2606:4700:4700::1111 >/tmp/mwan_ping.$$ 2>&1; then
            PING_OK[$i]="ok"
        elif ping -6 -c 3 -W 5 -I "$ifc" 2606:4700:4700::1111 >/tmp/mwan_ping.$$ 2>&1; then
            PING_OK[$i]="ok"
        else
            PING_OK[$i]="fail"
        fi
        cat /tmp/mwan_ping.$$ || true
        rm -f /tmp/mwan_ping.$$
        resp=$(curl -6 --interface "$ifc" --max-time 8 -s "$tgt" || true)
        printf "%-11s %s\n" "FAR IP" "${resp:-<empty>}"
        FAR_IP[$i]="$resp"
        if [ -n "$resp" ]; then
            tmpres=$(mktemp)
            python3 - "$resp" "$pd" <<'PY' >"$tmpres"
import ipaddress, sys
ip=sys.argv[1]; net=sys.argv[2]
try:
    ok=ipaddress.IPv6Address(ip) in ipaddress.IPv6Network(net, strict=False)
    print(f"In-prefix : {ok}")
    print(f"_RESULT:{ok}")
except Exception as e:
    print(f"in_prefix=error:{e}")
PY
            PREFIX_OK[$i]=$(grep '^_RESULT:' "$tmpres" 2>/dev/null | tail -1)
            grep -v '^_RESULT:' "$tmpres" || true
            rm -f "$tmpres"
        fi
    done

    # Summary table
    echo
    echo "$sep"
    printf "%-11s %-20s %-7s %-7s %-32s\n" "IFACE" "PD" "PING" "PREFIX" "FAR IP"
    echo "$sep"
    for i in "${!IFCS[@]}"; do
        pi="${PING_OK[$i]:-fail}"
        pr="${PREFIX_OK[$i]:-false}"
        far="${FAR_IP[$i]:-<empty>}"
        pd="${PDS[$i]}"
        ifc="${IFCS[$i]}"
        [ "$pi" = "ok" ] && pi="OK" || pi="FAIL"
        [ "$pr" = "_RESULT:True" ] && pr="OK" || pr="FAIL"
        printf "%-11s %-20s %-7s %-7s %-32s\n" "$ifc" "$pd" "$pi" "$pr" "$far"
    done
    echo "$sep"

    echo
    echo "Cleanup: removing temp PD addrs that were added by this test."
    for i in "${!ADDR_PREFS[@]}"; do
        addr_pref="${ADDR_PREFS[$i]}"
        ifc="${IFCS[$i]}"
        existed="${EXISTED[$i]}"
        if [ "$existed" = "no" ]; then
            ip -6 addr del "$addr_pref" dev "$ifc" || true
        fi
    done
    echo "Done."
}

{% raw %}
run_lb4() {
    for i in $(seq 1 "$LB_ITER"); do
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb4 iter $i -> $tgt (no iface hint)"
        curl -4 -s "$tgt" || true
        echo
    done
}

run_lb6() {
    for i in $(seq 1 "$LB_ITER"); do
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb6 iter $i -> $tgt (no iface hint)"
        curl -6 -s "$tgt" || true
        echo
    done
}

run_lb4_ifaces() {
    for i in $(seq 1 "$LB_ITER"); do
        ifc="${IFACES[$(( (i-1) % ${#IFACES[@]} ))]}"
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb4-ifaces iter $i via $ifc -> $tgt"
        curl -4 --interface "$ifc" -s "$tgt" || true
        echo
    done
}

run_lb6_ifaces() {
    for i in $(seq 1 "$LB_ITER"); do
        ifc="${IFACES[$(( (i-1) % ${#IFACES[@]} ))]}"
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb6-ifaces iter $i via $ifc -> $tgt"
        curl -6 --interface "$ifc" -s "$tgt" || true
        echo
    done
}
{% endraw %}

show_policy() {
    echo "== ip rule =="
    ip rule show || true
    echo
    echo "== table 100 (att) v4 =="
    ip route show table 100 || true
    echo "== table 100 (att) v6 =="
    ip -6 route show table 100 || true
    echo
    echo "== table 200 (webpass) v4 =="
    ip route show table 200 || true
    echo "== table 200 (webpass) v6 =="
    ip -6 route show table 200 || true
    echo
    echo "== mangle marks =="
    nft list table inet mangle | grep 'meta mark' || true
}

sim4() {
    echo "== ip route get 1.1.1.1 from LAN =="
    ip route get 1.1.1.1 from 10.250.250.2 || true
    echo "-- mark 1 (att) --"
    ip route get 1.1.1.1 from 10.250.250.2 mark 1 || true
    echo "-- mark 2 (webpass) --"
    ip route get 1.1.1.1 from 10.250.250.2 mark 2 || true
}

sim6() {
    echo "== ip -6 route get 2606:4700:4700::1111 from LAN =="
    ip -6 route get 2606:4700:4700::1111 from 3d06:bad:b01:fe::2 || true
    echo "-- mark 1 (att) --"
    ip -6 route get 2606:4700:4700::1111 from 3d06:bad:b01:fe::2 mark 1 || true
    echo "-- mark 2 (webpass) --"
    ip -6 route get 2606:4700:4700::1111 from 3d06:bad:b01:fe::2 mark 2 || true
}

cmd="${1:-}"
shift || true

case "$cmd" in
    trace-start) trace_start "${1:-}" ;;
    trace-tail) trace_tail "${1:-}" ;;
    trace-stop) trace_stop ;;
    prefixes) show_pd ;;
    routes) show_routes ;;
    npt) show_nft ;;
    status) show_status ;;
    stats) show_stats ;;
    ping4) run_ping4 "${1:-}" ;;
    ping6) run_ping6 "${1:-}" ;;
    curl4) run_curl4 "${1:-}" ;;
    curl6) run_curl6 "${1:-}" ;;
    lb4) run_lb4 ;;
    lb6) run_lb6 ;;
    lb4-ifaces) run_lb4_ifaces ;;
    lb6-ifaces) run_lb6_ifaces ;;
    pd-test) run_pd_test ;;
    policy) show_policy ;;
    sim4) sim4 ;;
    sim6) sim6 ;;
    ""|help|-h|--help) usage ;;
    *)
        echo "Unknown command: $cmd" >&2
        usage
        exit 1
        ;;
esac
