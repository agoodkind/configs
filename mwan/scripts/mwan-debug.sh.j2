#!/bin/bash
# Generated by Ansible
#
# What it does (symptoms):
# - Provides a single “operator UX” entrypoint to validate routing/NPT/health and to run trace sessions.
# - Helps confirm fixes with evidence (rules present, routes correct, egress IPs match expectations).
#
# What it does (technical):
# - Runs read-only inspection commands (ip route/rule, nft ruleset, networkctl).
# - Can run `update-routes.sh`, `health-check.sh --check`, and NPT hook invocations with an explicit `MWAN_TRACE_ID`
#   to generate correlated JSON logs in `/var/log/mwan-debug.log`.
#
# Dependency graph:
# - Manual tool only (not used by systemd directly).
# - Calls into: `update-routes.sh`, `health-check.sh`, and the dispatcher hooks for targeted debugging.

set -euo pipefail

IFACES=(
  "{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}"
  "{{ mwan_webpass_iface }}"
)
PING6_TARGETS=("2606:4700:4700::1111" "2620:fe::9")
CURL_TARGETS=("https://ifconfig.co" "https://api.ipify.org")
LB_ITER=${LB_ITER:-6}
PING4_TARGETS=("1.1.1.1" "8.8.8.8")

# Basic color helpers (honor NO_COLOR)
if [ -z "${NO_COLOR:-}" ]; then
  C_BOLD="\033[1m"; C_DIM="\033[2m"; C_RED="\033[31m"
  C_GRN="\033[32m"; C_CYN="\033[36m"; C_RST="\033[0m"
else
  C_BOLD=""; C_DIM=""; C_RED=""; C_GRN=""; C_CYN=""; C_RST=""
fi

usage() {
    cat <<'EOT'
Usage: mwan-debug.sh [command] [args...]
Commands:
  trace-start  Start an end-to-end trace session (prints traceId)
  trace-tail   Tail the JSON debug log (optionally filter by traceId)
  trace-stop   Stop background trace tools started by trace-start
  prefixes     Show PDs (routes + journal)
  routes       Show proto dhcp routes
  npt          Show ip6 nat NPT rules
  status       Show networkctl status for WAN ifaces
  stats        Show link stats for WAN ifaces
  pd-test      Verify PD egress after removing proto dhcp routes
  ping4 [if]   Ping IPv4 targets from iface (default first WAN)
  ping6 [if]   Ping IPv6 targets from iface (default first WAN)
  curl4 [if]   curl -4 from iface to ifconfig.co/api.ipify.org
  curl6 [if]   curl -6 from iface to ifconfig.co/api.ipify.org
  lb4          Curl -4 repeatedly (main table) to show mix of egress
  lb6          Curl -6 repeatedly (main table) to show mix of egress
  lb4-ifaces   Curl -4 alternating WAN ifaces (no mgmt)
  lb6-ifaces   Curl -6 alternating WAN ifaces (no mgmt)
  policy       Show ip rules, WAN tables, and mangle marks
  sim4         Route-get IPv4 from LAN src (incl. marks 1/2)
  sim6         Route-get IPv6 from LAN src (incl. marks 1/2)
EOT
}

trace_id() {
    # short-ish, readable trace ID for correlating events across scripts
    date +"%Y%m%d-%H%M%S-$$"
}

trace_start() {
    local id="${1:-$(trace_id)}"
    export MWAN_TRACE_ID="$id"
    echo "traceId=$MWAN_TRACE_ID"
    echo "Writing JSON lines to /var/log/mwan-debug.log"
    echo
    echo "== snapshot =="
    ip -4 route show default || true
    ip -6 route show default || true
    ip rule show || true
    ip -6 rule show || true
    nft list ruleset | sed -n '1,220p' || true
    echo
    echo "== run helpers (with traceId) =="
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /usr/local/bin/update-routes.sh || true
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /usr/local/bin/health-check.sh --check || true
    # If PD is not discoverable, 55-update-npt.sh has a static-prefix fallback.
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /etc/networkd-dispatcher/routable.d/55-update-npt.sh "{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}" routable || true
    MWAN_TRACE_ID="$MWAN_TRACE_ID" /etc/networkd-dispatcher/routable.d/55-update-npt.sh "{{ mwan_webpass_iface }}" routable || true
    echo
    echo "== hint =="
    echo "mwan trace-tail $MWAN_TRACE_ID"
}

trace_tail() {
    local id="${1:-}"
    if [ -z "$id" ]; then
        tail -n 200 -f /var/log/mwan-debug.log
    else
        tail -n 500 -f /var/log/mwan-debug.log | grep -F "\"traceId\":\"$id\""
    fi
}

trace_stop() {
    # placeholder for future background collectors; keep command for UX consistency
    echo "No background collectors to stop."
}

show_pd() {
    echo "== Proto dhcp routes =="
    ip -6 route show proto dhcp || true
    echo
    echo "== Delegated prefixes from journal (last per iface) =="
    for ifc in "${IFACES[@]}"; do
        pref=$(journalctl -u systemd-networkd -b |
            grep "$ifc: DHCP: received delegated prefix" | tail -1 | awk '{print $NF}')
        echo "$ifc: ${pref:-none}"
    done
}

show_routes() {
    ip -6 route show proto dhcp || true
}

show_nft() {
    nft list table ip6 nat || true
}

show_status() {
    for ifc in "${IFACES[@]}"; do
        echo "== $ifc =="
        networkctl status "$ifc" --no-pager || true
        echo
    done
}

show_stats() {
    for ifc in "${IFACES[@]}"; do
        echo "== $ifc =="
        ip -s link show dev "$ifc" || true
        echo
    done
}

run_ping6() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${PING6_TARGETS[@]}"; do
        echo "Ping6 $tgt via $ifc"
        ping -6 -c 3 -I "$ifc" "$tgt" || true
        echo
    done
}

run_ping4() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${PING4_TARGETS[@]}"; do
        echo "Ping4 $tgt via $ifc"
        ping -c 3 -I "$ifc" "$tgt" || true
        echo
    done
}

run_curl4() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${CURL_TARGETS[@]}"; do
        echo "curl4 $tgt via $ifc"
        CURL_IFACE="$ifc" CURL_IP_VERSION=4 curl -4 --interface "$ifc" -s "$tgt" || true
        echo
    done
}

run_curl6() {
    local ifc="${1:-${IFACES[0]}}"
    for tgt in "${CURL_TARGETS[@]}"; do
        echo "curl6 $tgt via $ifc"
        CURL_IFACE="$ifc" CURL_IP_VERSION=6 curl -6 --interface "$ifc" -s "$tgt" || true
        echo
    done
}

get_pd() {
    local ifc="$1" pd
    pd=$(ip -6 route show proto dhcp dev "$ifc" | awk '{print $1; exit}')
    if [ -z "$pd" ] && [ -f "/var/lib/mwan/pd-$ifc" ]; then
        pd=$(head -1 "/var/lib/mwan/pd-$ifc")
    fi
    if [ -z "$pd" ]; then
        pd=$(journalctl -u systemd-networkd -b |
            grep "$ifc: DHCP: received delegated prefix" | tail -1 | awk '{print $NF}')
    fi
    echo "$pd"
}

confirm_pd_test() {
    echo "WARNING: this test will SPLINTER the PD (temp addrs, drop proto-dhcp"
    echo "routes) and may disrupt downstream IPv6 briefly until renew."
    echo "It also curls a far endpoint to confirm seen IP is in-prefix."
    read -r -p "Proceed? [y/N] " ans
    case "${ans:-n}" in
        y|Y) ;;
        *) echo "Aborted."; exit 1 ;;
    esac
}

run_pd_test() {
    confirm_pd_test

    local tgt="https://ifconfig.co"
    declare -a IFCS=()
    declare -A PD_BY_IFACE=()
    declare -A ADDR_PREF_BY_IFACE=()
    declare -A EXISTED_BY_IFACE=()
    declare -A PING_OK_BY_IFACE=()
    declare -A FAR_IP_BY_IFACE=()
    declare -A IN_PREFIX_BY_IFACE=()
    local sep="────────────────────────────────────────────────────────────"

    ipv6_in_prefix() {
        # Return "True" if IPv6 address is in IPv6 prefix CIDR; otherwise "False".
        #
        # Uses `ipcalc-ng` JSON output (parsed with jq).
        local ip_in="$1"
        local cidr="$2"

        local ip="${ip_in%%[[:space:]]*}"
        ip="${ip%%\%*}" # drop zone id if any (e.g. fe80::1%eth0)

        [[ "$cidr" == */* ]] || {
            echo "False"
            return 0
        }

        local plen="${cidr##*/}"
        [[ "$plen" =~ ^[0-9]+$ ]] || {
            echo "False"
            return 0
        }
        [ "$plen" -ge 0 ] && [ "$plen" -le 128 ] || {
            echo "False"
            return 0
        }

        local net_of_cidr net_of_ip
        net_of_cidr="$(
            ipcalc-ng --all-info -j "$cidr" 2>/dev/null |
                jq -r '.NETWORK // empty' 2>/dev/null || true
        )"
        net_of_ip="$(
            ipcalc-ng --all-info -j "$ip/$plen" 2>/dev/null |
                jq -r '.NETWORK // empty' 2>/dev/null || true
        )"

        if [ -n "$net_of_cidr" ] && [ -n "$net_of_ip" ] && [ "$net_of_cidr" = "$net_of_ip" ]; then
            echo "True"
        else
            echo "False"
        fi
    }

    ensure_test_addr() {
        local ifc="$1"
        local pd="$2"

        local addr="${pd%/*}2"
        local pref="${pd#*/}"
        local addr_pref="$addr/$pref"

        local existed="no"
        if ip -6 addr show dev "$ifc" | awk -v a="$addr" '$2 ~ "/" && $2 ~ a"/"{print "yes"; exit}' >/dev/null; then
            existed="yes"
        fi

        echo "$ifc: PD=$pd addr=$addr_pref (existing=$existed)"
        if [ "$existed" = "no" ]; then
            ip -6 addr add "$addr_pref" dev "$ifc" nodad || true
        fi

        IFCS+=("$ifc")
        PD_BY_IFACE["$ifc"]="$pd"
        ADDR_PREF_BY_IFACE["$ifc"]="$addr_pref"
        EXISTED_BY_IFACE["$ifc"]="$existed"
    }

    ping6_probe() {
        # Print ping output; return 0 on success, 1 on failure.
        local ifc="$1"
        local src_addr="$2"
        local dst="$3"

        local out=""
        if out="$(ping -6 -c 3 -W 5 -I "${src_addr}%${ifc}" "$dst" 2>&1)"; then
            printf '%s\n' "$out"
            return 0
        fi
        if out="$(ping -6 -c 3 -W 5 -I "$ifc" "$dst" 2>&1)"; then
            printf '%s\n' "$out"
            return 0
        fi
        printf '%s\n' "$out"
        return 1
    }

    print_pd_test_header() {
        local ifc="$1"
        local pd="$2"
        local addr_pref="$3"
        local addr="${addr_pref%/*}"
        local pref="${addr_pref#*/}"

        echo
        echo "$sep"
        printf "%-11s %s\n" "IFACE" "$ifc"
        printf "%-11s %s\n" "PD" "$pd"
        printf "%-11s %s/%s\n" "TEST ADDR" "$addr" "$pref"
        echo "$sep"
    }

    print_pd_test_summary() {
        echo
        echo "$sep"
        printf "%-11s %-20s %-7s %-7s %-32s\n" "IFACE" "PD" "PING" "PREFIX" "FAR IP"
        echo "$sep"
        for ifc in "${IFCS[@]}"; do
            local pd="${PD_BY_IFACE[$ifc]}"
            local ping_ok="${PING_OK_BY_IFACE[$ifc]:-fail}"
            local in_prefix="${IN_PREFIX_BY_IFACE[$ifc]:-False}"
            local far="${FAR_IP_BY_IFACE[$ifc]:-<empty>}"

            [ "$ping_ok" = "ok" ] && ping_ok="OK" || ping_ok="FAIL"
            [ "$in_prefix" = "True" ] && in_prefix="OK" || in_prefix="FAIL"

            printf "%-11s %-20s %-7s %-7s %-32s\n" "$ifc" "$pd" "$ping_ok" "$in_prefix" "$far"
        done
        echo "$sep"
    }

    cleanup_pd_test_addrs() {
        echo
        echo "Cleanup: removing temp PD addrs that were added by this test."
        for ifc in "${IFCS[@]}"; do
            if [ "${EXISTED_BY_IFACE[$ifc]:-no}" = "no" ]; then
                ip -6 addr del "${ADDR_PREF_BY_IFACE[$ifc]}" dev "$ifc" || true
            fi
        done
        echo "Done."
    }

    echo "╔════════════════════════════════════════════════════════════╗"
    printf "║ %-58s ║\n" "PD EGRESS VERIFICATION (splinters PD; temporary disruption)"
    printf "║ %-58s ║\n" "Target: $tgt"
    echo "╚════════════════════════════════════════════════════════════╝"

    echo "Deleting proto dhcp PD routes to prove PD egress without them."
    echo "(They will reappear on the next DHCPv6 renew.)"
    for r in $(ip -6 route show proto dhcp | awk '{print $1}'); do
        ip -6 route del "$r" proto dhcp || true
    done
    ip -6 route show proto dhcp || true

    for ifc in "${IFACES[@]}"; do
        pd="$(get_pd "$ifc")"
        if [ -z "$pd" ]; then
            echo "$ifc: no PD found; skipping"
            continue
        fi
        ensure_test_addr "$ifc" "$pd"
    done
    sleep 1

    for ifc in "${IFCS[@]}"; do
        pd="${PD_BY_IFACE[$ifc]}"
        addr_pref="${ADDR_PREF_BY_IFACE[$ifc]}"
        addr="${addr_pref%/*}"

        print_pd_test_header "$ifc" "$pd" "$addr_pref"
        ip -6 route get 2606:4700:4700::1111 from "$addr" oif "$ifc" || true
        printf "%-11s %s%s%s\n" "PING" "$ifc from " "$addr" ""

        if ping6_probe "$ifc" "$addr" 2606:4700:4700::1111; then
            PING_OK_BY_IFACE["$ifc"]="ok"
        else
            PING_OK_BY_IFACE["$ifc"]="fail"
        fi

        resp=$(curl -6 --interface "$ifc" --max-time 8 -s "$tgt" || true)
        printf "%-11s %s\n" "FAR IP" "${resp:-<empty>}"
        FAR_IP_BY_IFACE["$ifc"]="$resp"
        if [ -n "$resp" ]; then
            ok="$(ipv6_in_prefix "$resp" "$pd" 2>/dev/null || echo "False")"
            printf "In-prefix : %s\n" "$ok"
            IN_PREFIX_BY_IFACE["$ifc"]="$ok"
        fi
    done

    print_pd_test_summary
    cleanup_pd_test_addrs
}

{% raw %}
run_lb4() {
    for i in $(seq 1 "$LB_ITER"); do
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb4 iter $i -> $tgt (no iface hint)"
        curl -4 -s "$tgt" || true
        echo
    done
}

run_lb6() {
    for i in $(seq 1 "$LB_ITER"); do
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb6 iter $i -> $tgt (no iface hint)"
        curl -6 -s "$tgt" || true
        echo
    done
}

run_lb4_ifaces() {
    for i in $(seq 1 "$LB_ITER"); do
        ifc="${IFACES[$(( (i-1) % ${#IFACES[@]} ))]}"
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb4-ifaces iter $i via $ifc -> $tgt"
        curl -4 --interface "$ifc" -s "$tgt" || true
        echo
    done
}

run_lb6_ifaces() {
    for i in $(seq 1 "$LB_ITER"); do
        ifc="${IFACES[$(( (i-1) % ${#IFACES[@]} ))]}"
        tgt="${CURL_TARGETS[$(( (i-1) % ${#CURL_TARGETS[@]} ))]}"
        echo "lb6-ifaces iter $i via $ifc -> $tgt"
        curl -6 --interface "$ifc" -s "$tgt" || true
        echo
    done
}
{% endraw %}

show_policy() {
    echo "== ip rule =="
    ip rule show || true
    echo
    echo "== table 100 (att) v4 =="
    ip route show table 100 || true
    echo "== table 100 (att) v6 =="
    ip -6 route show table 100 || true
    echo
    echo "== table 200 (webpass) v4 =="
    ip route show table 200 || true
    echo "== table 200 (webpass) v6 =="
    ip -6 route show table 200 || true
    echo
    echo "== mangle marks =="
    nft list table inet mangle | grep 'meta mark' || true
}

sim4() {
    echo "== ip route get 1.1.1.1 from LAN =="
    ip route get 1.1.1.1 from 10.250.250.2 || true
    echo "-- mark 1 (att) --"
    ip route get 1.1.1.1 from 10.250.250.2 mark 1 || true
    echo "-- mark 2 (webpass) --"
    ip route get 1.1.1.1 from 10.250.250.2 mark 2 || true
}

sim6() {
    echo "== ip -6 route get 2606:4700:4700::1111 from LAN =="
    ip -6 route get 2606:4700:4700::1111 from 3d06:bad:b01:fe::2 || true
    echo "-- mark 1 (att) --"
    ip -6 route get 2606:4700:4700::1111 from 3d06:bad:b01:fe::2 mark 1 || true
    echo "-- mark 2 (webpass) --"
    ip -6 route get 2606:4700:4700::1111 from 3d06:bad:b01:fe::2 mark 2 || true
}

cmd="${1:-}"
shift || true

case "$cmd" in
    trace-start) trace_start "${1:-}" ;;
    trace-tail) trace_tail "${1:-}" ;;
    trace-stop) trace_stop ;;
    prefixes) show_pd ;;
    routes) show_routes ;;
    npt) show_nft ;;
    status) show_status ;;
    stats) show_stats ;;
    ping4) run_ping4 "${1:-}" ;;
    ping6) run_ping6 "${1:-}" ;;
    curl4) run_curl4 "${1:-}" ;;
    curl6) run_curl6 "${1:-}" ;;
    lb4) run_lb4 ;;
    lb6) run_lb6 ;;
    lb4-ifaces) run_lb4_ifaces ;;
    lb6-ifaces) run_lb6_ifaces ;;
    pd-test) run_pd_test ;;
    policy) show_policy ;;
    sim4) sim4 ;;
    sim6) sim6 ;;
    ""|help|-h|--help) usage ;;
    *)
        echo "Unknown command: $cmd" >&2
        usage
        exit 1
        ;;
esac
