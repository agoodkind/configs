#!/bin/bash
# Generated by Ansible
#
# What it does (symptoms):
# - Makes outbound IPv6 from internal `3d06:bad:b01::/60` work by translating it onto a WAN delegated prefix.
# - Makes inbound IPv6 to the WAN PD space reach OPNsense by applying reverse translation (DNPT/DNAT).
# - If this does not run (or rules were flushed), `nft list table ip6 nat` will be empty and IPv6 services break.
#
# What it does (technical):
# - Programs runtime rules into `nft table ip6 nat`:
#   - postrouting: SNAT `3d06:bad:b01::/60` -> WAN /60, plus SNAT guards for hairpinned flows.
#   - prerouting: DNAT WAN /60 -> internal /60 and WAN `::1/128` -> OPNsense edge address.
# - Ensures each WAN has its PD `::1/128` address present on the interface.
# - For Monkeybrains, can derive a /60 from a delegated /56 (or use a configured static /60).
#
# Dependency graph:
# - Event-driven: `networkd-dispatcher` hook `55-update-npt.sh` (runs when WAN becomes `routable`).
# - Boot/deploy safety net: `mwan-update-npt.service` (reapplies after boot and after `nftables` reload).
# - Requires: base `nft table ip6 nat` exists (nftables loaded) and the WAN interface exists.

set -euo pipefail

WAN_IFACE="$1"
DELEGATED_PREFIX="$2"
DEBUG="{{ mwan_debug_logging | default(false) | ternary('1','0') }}"
DEBUG_LOG="/var/log/mwan-debug.log"
TRACE_FILE="/run/mwan-trace-id"
MWAN_TRACE_ID="${MWAN_TRACE_ID:-}"
if [ -z "${MWAN_TRACE_ID:-}" ] && [ -r "$TRACE_FILE" ]; then
    MWAN_TRACE_ID="$(cat "$TRACE_FILE" 2>/dev/null || true)"
fi

if [ -z "$WAN_IFACE" ] || [ -z "$DELEGATED_PREFIX" ]; then
    echo "Usage: $(basename "$0") <wan_iface> <delegated_prefix>"
    echo "Example: $(basename "$0") {{ mwan_att_iface }}.{{ mwan_att_vlan_id }} 2600:1700:2f71:c80::/60"
    exit 1
fi

# Serialize updates to avoid concurrent partial nftables state.
# This script edits shared chains (`ip6 nat`), so use a global lock.
LOCK_FILE="/run/mwan-update-npt.lock"
exec 9>"$LOCK_FILE"
flock 9

readonly INTERNAL_PREFIX="{{ mwan_internal_prefix }}"
readonly OPNSENSE_EDGE_V6="{{ mwan_opnsense_edge_ipv6 | default('3d06:bad:b01:fe::2') }}"
readonly MWAN_EDGE_V6="{{ mwan_mwanbr_edge_ipv6 }}"
readonly MB_STATIC_PREFIX="{{ mwan_npt_monkeybrains_prefix | default('') }}"

first_60_of_prefix() {
    # Given an IPv6 prefix like 2607:f598:d3e0:131::/56, return the first /60 inside it.
    local cidr="$1"
    local plen="${cidr##*/}"
    [[ "$plen" =~ ^[0-9]+$ ]] || return 1
    [ "$plen" -le 60 ] || return 1

    local base net60
    base="$(ipcalc-ng --all-info -j "$cidr" 2>/dev/null | jq -r '.NETWORK // empty' 2>/dev/null)"
    [ -n "$base" ] || return 1
    net60="$(ipcalc-ng --all-info -j "$base/60" 2>/dev/null | jq -r '.NETWORK // empty' 2>/dev/null)"
    [ -n "$net60" ] || return 1
    printf '%s/60\n' "$net60"
}

log() {
    local msg="$1"
    local prefix=""
    [ -n "${MWAN_TRACE_ID:-}" ] && prefix="traceId=${MWAN_TRACE_ID} "
    logger -t update-npt "${prefix}${msg}"
    echo "[update-npt] ${prefix}${msg}"
}

debug_json() {
    [ "$DEBUG" = "1" ] || return 0
    local loc="$1"; shift
    local msg="$1"; shift
    local data="${1:-{}}"; shift || true
    jq -cn \
      --arg traceId "${MWAN_TRACE_ID:-}" \
      --arg component "update-npt" \
      --arg location "$loc" \
      --arg message "$msg" \
      --arg data "${data:-{}}" \
      --argjson timestamp "$(date +%s%3N)" \
      '{
        traceId: $traceId,
        component: $component,
        location: $location,
        message: $message,
        data: (try ($data | fromjson) catch {}),
        timestamp: $timestamp
      }' >> "$DEBUG_LOG"
}

log "Updating NPT rules for $WAN_IFACE"
log "  Delegated prefix: $DELEGATED_PREFIX"

# Collect existing per-iface rule handles (we delete them in the same nft batch as we add replacements).
POST_HANDLES="$(
  nft -a list chain ip6 nat postrouting 2>/dev/null |
    awk -v ifc="$WAN_IFACE" '
      $0 ~ ("oif \\\"" ifc "\\\"") && $0 ~ /# handle/ { print $NF }
    '
)"
PRE_HANDLES="$(
  nft -a list chain ip6 nat prerouting 2>/dev/null |
    awk -v ifc="$WAN_IFACE" '
      $0 ~ ("iif \\\"" ifc "\\\"") && $0 ~ /# handle/ { print $NF }
    '
)"

# Decide target /60 for this iface.
# NOTE: NPT is stateless and requires internal/external prefixes to be the same length (/60 here).
case "$WAN_IFACE" in
    "{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}")
        TARGET_PREFIX="{{ mwan_npt_att_prefix }}"
        ;;
    "{{ mwan_webpass_iface }}")
        TARGET_PREFIX="{{ mwan_npt_webpass_prefix }}"
        ;;
    "{{ mwan_monkeybrains_iface }}")
        if [ -n "$MB_STATIC_PREFIX" ]; then
            TARGET_PREFIX="$MB_STATIC_PREFIX"
        else
            # Monkeybrains may delegate a /56; pick the first /60 from the delegated prefix.
            TARGET_PREFIX="$(first_60_of_prefix "$DELEGATED_PREFIX" 2>/dev/null || true)"
            if [ -z "$TARGET_PREFIX" ]; then
                log "Delegated prefix $DELEGATED_PREFIX is not usable for /60 NPT; skipping"
                exit 0
            fi
        fi
        ;;
    *)
        log "Unknown WAN iface $WAN_IFACE; skipping"
        exit 0
        ;;
esac

[ "$DEBUG" = "1" ] && debug_json "SELECT" "target_prefix_selected" "$(jq -cn \
  --arg iface "$WAN_IFACE" \
  --arg delegated "$DELEGATED_PREFIX" \
  --arg target "$TARGET_PREFIX" \
  '{
    iface: $iface,
    delegated: $delegated,
    target: $target
  }')"

# Postrouting: 
# - SNAT specific /128s (fe::1, fe::2) to PD ::1
# - NPT broader /60 to PD /60
# Add PD ::1 address to interface first
ip -6 addr replace "${TARGET_PREFIX%/*}1/128" dev "$WAN_IFACE" nodad || true

# Apply nftables changes in a single `nft -f` batch to avoid partial state.
tmp="$(mktemp)"
{
    for h in $POST_HANDLES; do
        echo "delete rule ip6 nat postrouting handle $h"
    done
    for h in $PRE_HANDLES; do
        echo "delete rule ip6 nat prerouting handle $h"
    done

    # If this packet is part of a DNAT'd flow to the OPNsense edge address, do NOT clobber
    # conntrack's reverse-NAT with an unconditional SNAT rule.
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $OPNSENSE_EDGE_V6/128 ct status dnat return"
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $OPNSENSE_EDGE_V6/128 snat to ${TARGET_PREFIX%/*}1"
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $MWAN_EDGE_V6/128 snat to ${TARGET_PREFIX%/*}1"
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $INTERNAL_PREFIX snat ip6 prefix to $TARGET_PREFIX"

    # Prerouting:
    echo "add rule ip6 nat prerouting iif \"$WAN_IFACE\" ip6 daddr ${TARGET_PREFIX%/*}1/128 dnat to $OPNSENSE_EDGE_V6"
    echo "add rule ip6 nat prerouting iif \"$WAN_IFACE\" ip6 daddr $TARGET_PREFIX dnat ip6 prefix to $INTERNAL_PREFIX"

    # Also DNAT any other global /128 address currently assigned to the WAN interface back to OPNsense.
    while read -r ip6_cidr; do
        [ -n "$ip6_cidr" ] || continue
        [ "${ip6_cidr#*/}" = "128" ] || continue
        [ "$ip6_cidr" = "${TARGET_PREFIX%/*}1/128" ] && continue
        ip6_addr="${ip6_cidr%/*}"
        [ -n "$ip6_addr" ] || continue
        echo "add rule ip6 nat prerouting iif \"$WAN_IFACE\" ip6 daddr $ip6_addr/128 dnat to $OPNSENSE_EDGE_V6"
    done < <(ip -6 addr show dev "$WAN_IFACE" scope global | awk '/inet6/{print $2}' || true)
} >"$tmp"
nft -f "$tmp"
rm -f "$tmp"

# Save current nftables config
nft list ruleset > /etc/nftables.conf.dynamic

[ "$DEBUG" = "1" ] && debug_json "NFT" "ip6_nat_chains" "$(jq -cn \
  --arg prerouting "$(nft -a list chain ip6 nat prerouting 2>/dev/null || true)" \
  --arg postrouting "$(nft -a list chain ip6 nat postrouting 2>/dev/null || true)" \
  '{
    prerouting: $prerouting,
    postrouting: $postrouting
  }')"

log "NPT update complete for $WAN_IFACE"
