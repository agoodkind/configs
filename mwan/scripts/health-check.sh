#!/usr/bin/env bash
# Generated by Ansible
#
# What it does (symptoms):
# - Detects “soft failures” (link is UP but WAN connectivity is broken) and triggers failover for new flows.
# - Ensures the system converges back to primary WANs when they recover (even if Monkeybrains was usable first).
#
# What it does (technical):
# - Periodically probes each WAN interface with ping/ping6 and optional HTTP checks (IPv6 preferred).
# - Maintains hysteresis counters to avoid flapping (failure_threshold / recovery_threshold).
# - Writes health state to `/var/run/mwan-health.state` using `healthy|unhealthy|unknown`.
# - Calls `/usr/local/bin/update-routes.sh` on health transitions to rebuild policy routing tables.
#
# Dependency graph:
# - Runs as: `mwan-health.service` (long-running daemon; Restart=always).
# - Called by: systemd only (daemon mode) or operators (one-shot `--check`/`--status`).
# - Calls into: `update-routes.sh` (routing convergence).
# - Requires: basic networking, `ping`/`ping6`/`curl` binaries, and that WAN interfaces exist.

set -euo pipefail

STATE_FILE="/var/run/mwan-health.state"
LOG_FILE="/var/log/mwan-health.log"

# shellcheck disable=SC1091
. /etc/mwan/mwan.env

DEBUG="${MWAN_DEBUG_LOGGING:-0}"
DEBUG_LOG="${MWAN_DEBUG_LOG:-/var/log/mwan-debug.log}"
TRACE_FILE="${MWAN_TRACE_FILE:-/run/mwan-trace-id}"
MWAN_TRACE_ID="${MWAN_TRACE_ID:-}"
if [ -z "${MWAN_TRACE_ID:-}" ] && [ -r "$TRACE_FILE" ]; then
    MWAN_TRACE_ID="$(cat "$TRACE_FILE")"
fi

debug_json() {
    [ "$DEBUG" = "1" ] || return 0
    local loc="$1"; shift
    local msg="$1"; shift
    local data="${1:-{}}"; shift || true
    jq -cn \
      --arg traceId "${MWAN_TRACE_ID:-}" \
      --arg component "mwan-health" \
      --arg location "$loc" \
      --arg message "$msg" \
      --arg data "${data:-{}}" \
      --argjson timestamp "$(date +%s%3N)" \
      '{
        traceId: $traceId,
        component: $component,
        location: $location,
        message: $message,
        data: (try ($data | fromjson) catch {}),
        timestamp: $timestamp
      }' >> "$DEBUG_LOG"
}

# Hysteresis counters (persist across daemon iterations)
declare -gA FAIL_COUNTS=()
declare -gA OK_COUNTS=()

# WAN health check configuration (via /etc/mwan/mwan.env)
# Format: wan_name:interface:ping_count:success_threshold:interval:failure_threshold:recovery_threshold
ATT_IFACE="${MWAN_ATT_VLAN_IFACE:-}"
WEBPASS_IFACE="${MWAN_WEBPASS_IFACE:-}"
MB_IFACE="${MWAN_MONKEYBRAINS_IFACE:-}"

WAN_CONFIGS=(
    "att:${ATT_IFACE}:${MWAN_HEALTH_ATT_PING_COUNT:-3}:${MWAN_HEALTH_ATT_SUCCESS_THRESHOLD:-2}:${MWAN_HEALTH_ATT_CHECK_INTERVAL:-10}:${MWAN_HEALTH_ATT_FAILURE_THRESHOLD:-2}:${MWAN_HEALTH_ATT_RECOVERY_THRESHOLD:-2}"
    "webpass:${WEBPASS_IFACE}:${MWAN_HEALTH_WEBPASS_PING_COUNT:-3}:${MWAN_HEALTH_WEBPASS_SUCCESS_THRESHOLD:-2}:${MWAN_HEALTH_WEBPASS_CHECK_INTERVAL:-10}:${MWAN_HEALTH_WEBPASS_FAILURE_THRESHOLD:-2}:${MWAN_HEALTH_WEBPASS_RECOVERY_THRESHOLD:-2}"
    "monkeybrains:${MB_IFACE}:${MWAN_HEALTH_MONKEYBRAINS_PING_COUNT:-5}:${MWAN_HEALTH_MONKEYBRAINS_SUCCESS_THRESHOLD:-1}:${MWAN_HEALTH_MONKEYBRAINS_CHECK_INTERVAL:-30}:${MWAN_HEALTH_MONKEYBRAINS_FAILURE_THRESHOLD:-5}:${MWAN_HEALTH_MONKEYBRAINS_RECOVERY_THRESHOLD:-3}"
)

ATT_TARGETS_V4=()
ATT_TARGETS_V6=()
ATT_HTTP_TARGETS=()
WEBPASS_TARGETS_V4=()
WEBPASS_TARGETS_V6=()
WEBPASS_HTTP_TARGETS=()
MB_TARGETS_V4=()
MB_TARGETS_V6=()
MB_HTTP_TARGETS=()

# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_ATT_TARGETS_V4:-}" ] && ATT_TARGETS_V4=(${MWAN_HEALTH_ATT_TARGETS_V4})
# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_ATT_TARGETS_V6:-}" ] && ATT_TARGETS_V6=(${MWAN_HEALTH_ATT_TARGETS_V6})
# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_ATT_HTTP_TARGETS:-}" ] && ATT_HTTP_TARGETS=(${MWAN_HEALTH_ATT_HTTP_TARGETS})

# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_WEBPASS_TARGETS_V4:-}" ] && WEBPASS_TARGETS_V4=(${MWAN_HEALTH_WEBPASS_TARGETS_V4})
# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_WEBPASS_TARGETS_V6:-}" ] && WEBPASS_TARGETS_V6=(${MWAN_HEALTH_WEBPASS_TARGETS_V6})
# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_WEBPASS_HTTP_TARGETS:-}" ] && WEBPASS_HTTP_TARGETS=(${MWAN_HEALTH_WEBPASS_HTTP_TARGETS})

# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_MONKEYBRAINS_TARGETS_V4:-}" ] && MB_TARGETS_V4=(${MWAN_HEALTH_MONKEYBRAINS_TARGETS_V4})
# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_MONKEYBRAINS_TARGETS_V6:-}" ] && MB_TARGETS_V6=(${MWAN_HEALTH_MONKEYBRAINS_TARGETS_V6})
# shellcheck disable=SC2206
[ -n "${MWAN_HEALTH_MONKEYBRAINS_HTTP_TARGETS:-}" ] && MB_HTTP_TARGETS=(${MWAN_HEALTH_MONKEYBRAINS_HTTP_TARGETS})

log() {
    local prefix=""
    [ -n "${MWAN_TRACE_ID:-}" ] && prefix="traceId=${MWAN_TRACE_ID} "
    local msg
    msg="[$(date '+%Y-%m-%d %H:%M:%S')] ${prefix}$1"
    echo "$msg" | tee -a "$LOG_FILE"
    logger -t mwan-health "${prefix}$1"
}

send_email_notification() {
    [ "${MWAN_EMAIL_ENABLED:-0}" = "1" ] || return 0
    [ -n "${MWAN_EMAIL_RECIPIENT:-}" ] || return 0
    [ -n "${MWAN_EMAIL_SCRIPT:-}" ] || return 0
    [ -x "${MWAN_EMAIL_SCRIPT:-}" ] || return 0

    local subject="$1"
    local message="$2"

    local -a args
    args=(-t "${MWAN_EMAIL_RECIPIENT}" -s "${subject}" -m "${message}")
    [ -n "${MWAN_EMAIL_FROM:-}" ] && args+=(-f "${MWAN_EMAIL_FROM}")
    [ -n "${MWAN_EMAIL_SENDER_NAME:-}" ] && args+=(-n "${MWAN_EMAIL_SENDER_NAME}")

    if ! "${MWAN_EMAIL_SCRIPT}" "${args[@]}" >/dev/null 2>&1; then
        log "Email notification failed (subject=${subject})"
    fi
}

get_health() {
    local wan="$1"
    grep "^${wan}:" "$STATE_FILE" 2>/dev/null | cut -d: -f2 || echo "unknown"
}

set_health() {
    local wan="$1"
    local health="$2"
    
    # Remove old state
    sed -i "/^${wan}:/d" "$STATE_FILE"
    
    # Add new state
    echo "${wan}:${health}" >> "$STATE_FILE"
}

check_wan_health() {
    local wan_name="$1"
    local interface="$2"
    local ping_count="$3"
    local success_threshold="$4"
    
    local success_v4=0
    local success_v6=0
    local success_http4=0
    local success_http6=0

    local -a targets_v4
    local -a targets_v6
    local -a http_targets

    case "$wan_name" in
        att)
            targets_v4=("${ATT_TARGETS_V4[@]}")
            targets_v6=("${ATT_TARGETS_V6[@]}")
            http_targets=("${ATT_HTTP_TARGETS[@]}")
            ;;
        webpass)
            targets_v4=("${WEBPASS_TARGETS_V4[@]}")
            targets_v6=("${WEBPASS_TARGETS_V6[@]}")
            http_targets=("${WEBPASS_HTTP_TARGETS[@]}")
            ;;
        monkeybrains)
            targets_v4=("${MB_TARGETS_V4[@]}")
            targets_v6=("${MB_TARGETS_V6[@]}")
            http_targets=("${MB_HTTP_TARGETS[@]}")
            ;;
        *)
            targets_v4=()
            targets_v6=()
            http_targets=()
            ;;
    esac
    
    # Check if interface exists and is up
    if ! ip link show "$interface" >/dev/null 2>&1; then
        return 1
    fi
    
    if ! ip link show "$interface" | grep -q "state UP"; then
        return 1
    fi
    
    # IPv6 health check FIRST (P0 priority)
    if ip -6 addr show dev "$interface" | grep -q "scope global"; then
        for target in "${targets_v6[@]}"; do
            [ -n "$target" ] || continue
            if ping6 -c "$ping_count" -W 2 -I "$interface" "$target" >/dev/null 2>&1; then
                success_v6=$((success_v6 + 1))
            fi
        done
        for url in "${http_targets[@]}"; do
            [ -n "$url" ] || continue
            if curl -6 -sS --connect-timeout 2 --max-time 5 --interface "$interface" "$url" >/dev/null 2>&1; then
                success_http6=$((success_http6 + 1))
            fi
        done
    fi
    
    # IPv4 health check (secondary)
    for target in "${targets_v4[@]}"; do
        [ -n "$target" ] || continue
        if ping -c "$ping_count" -W 2 -I "$interface" "$target" >/dev/null 2>&1; then
            success_v4=$((success_v4 + 1))
        fi
    done
    for url in "${http_targets[@]}"; do
        [ -n "$url" ] || continue
        if curl -4 -sS --connect-timeout 2 --max-time 5 --interface "$interface" "$url" >/dev/null 2>&1; then
            success_http4=$((success_http4 + 1))
        fi
    done
    
    [ "$DEBUG" = "1" ] && debug_json "CHECK" "probe_results" "$(jq -cn \
      --arg wan "$wan_name" \
      --arg iface "$interface" \
      --argjson success_v6 "$success_v6" \
      --argjson success_http6 "$success_http6" \
      --argjson success_v4 "$success_v4" \
      --argjson success_http4 "$success_http4" \
      --argjson threshold "$success_threshold" \
      '{
        wan: $wan,
        iface: $iface,
        success_v6: $success_v6,
        success_http6: $success_http6,
        success_v4: $success_v4,
        success_http4: $success_http4,
        threshold: $threshold
      }')"

    # WAN is healthy if IPv6 meets threshold (preferred)
    # or IPv4 meets threshold (fallback)
    # IPv6 is checked first and preferred
    if [ $success_v6 -ge "$success_threshold" ] || [ $success_http6 -ge 1 ]; then
        [ "$DEBUG" = "1" ] && debug_json "DECISION" "wan_healthy" "$(jq -cn \
          --arg wan "$wan_name" \
          --arg iface "$interface" \
          --arg reason "v6" \
          '{
            wan: $wan,
            iface: $iface,
            reason: $reason
          }')"
        return 0
    elif [ $success_v4 -ge "$success_threshold" ] || [ $success_http4 -ge 1 ]; then
        [ "$DEBUG" = "1" ] && debug_json "DECISION" "wan_healthy" "$(jq -cn \
          --arg wan "$wan_name" \
          --arg iface "$interface" \
          --arg reason "v4" \
          '{
            wan: $wan,
            iface: $iface,
            reason: $reason
          }')"
        return 0
    else
        [ "$DEBUG" = "1" ] && debug_json "DECISION" "wan_unhealthy" "$(jq -cn \
          --arg wan "$wan_name" \
          --arg iface "$interface" \
          '{
            wan: $wan,
            iface: $iface
          }')"
        return 1
    fi
}

handle_wan_failure() {
    local wan_name="$1"
    
    log "WAN $wan_name failed health check"
    
    local old_state
    old_state=$(get_health "$wan_name")
    
    if [ "$old_state" != "unhealthy" ]; then
        set_health "$wan_name" "unhealthy"
        log "Marking $wan_name as UNHEALTHY (was $old_state)"
        
        # Update routing to remove failed WAN
        /usr/local/bin/update-routes.sh
        
        send_email_notification \
          "MWAN: ${wan_name} UNHEALTHY" \
          "WAN ${wan_name} became UNHEALTHY (was ${old_state}).\n\nHost: $(hostname)\nTime: $(date)\nTraceId: ${MWAN_TRACE_ID:-}\n"
    fi
}

handle_wan_recovery() {
    local wan_name="$1"
    
    local old_state
    old_state=$(get_health "$wan_name")
    
    if [ "$old_state" != "healthy" ]; then
        log "WAN $wan_name health check passed"
        set_health "$wan_name" "healthy"
        log "Marking $wan_name as HEALTHY (was $old_state)"
        
        # Update routing to add recovered WAN
        /usr/local/bin/update-routes.sh
        
        send_email_notification \
          "MWAN: ${wan_name} HEALTHY" \
          "WAN ${wan_name} became HEALTHY (was ${old_state}).\n\nHost: $(hostname)\nTime: $(date)\nTraceId: ${MWAN_TRACE_ID:-}\n"
    fi
}

run_health_checks() {
    local min_interval=999999

    # Ensure the state file exists even in one-shot mode.
    if [ ! -f "$STATE_FILE" ]; then
        : > "$STATE_FILE"
        for config in "${WAN_CONFIGS[@]}"; do
            [[ "$config" =~ ^[[:space:]]*# ]] && continue
            IFS=':' read -r wan_name _ _ _ _ _ _ <<< "$config"
            [ -n "${wan_name:-}" ] || continue
            echo "${wan_name}:unknown" >> "$STATE_FILE"
        done
    fi

    for config in "${WAN_CONFIGS[@]}"; do
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        IFS=':' read -r _ _ _ _ interval _ _ <<< "$config"
        if [ -n "$interval" ] && [ "$interval" -lt "$min_interval" ]; then
            min_interval="$interval"
        fi
    done

    for config in "${WAN_CONFIGS[@]}"; do
        # Skip commented configs
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        
        IFS=':' read -r wan_name interface ping_count success_threshold interval failure_threshold recovery_threshold <<< "$config"
        recovery_threshold="${recovery_threshold:-2}"

        FAIL_COUNTS["$wan_name"]="${FAIL_COUNTS["$wan_name"]:-0}"
        OK_COUNTS["$wan_name"]="${OK_COUNTS["$wan_name"]:-0}"
        
        if check_wan_health "$wan_name" "$interface" "$ping_count" "$success_threshold"; then
            OK_COUNTS["$wan_name"]=$((OK_COUNTS["$wan_name"] + 1))
            FAIL_COUNTS["$wan_name"]=0
            
            # Need N consecutive successes to mark as up (prevents flapping)
            if [ "${OK_COUNTS["$wan_name"]}" -ge "$recovery_threshold" ]; then
                handle_wan_recovery "$wan_name"
            fi
        else
            FAIL_COUNTS["$wan_name"]=$((FAIL_COUNTS["$wan_name"] + 1))
            OK_COUNTS["$wan_name"]=0
            
            if [ "${FAIL_COUNTS["$wan_name"]}" -ge "$failure_threshold" ]; then
                handle_wan_failure "$wan_name"
            fi
        fi
    done

    # Store computed minimum interval for daemon sleep
    echo "$min_interval" > /var/run/mwan-health.interval
}

daemon_loop() {
    log "Starting mwan-health daemon"
    
    # Initialize state file
    : > "$STATE_FILE"
    # Write initial states so other components never see an empty file.
    for config in "${WAN_CONFIGS[@]}"; do
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        IFS=':' read -r wan_name _ _ _ _ _ _ <<< "$config"
        [ -n "${wan_name:-}" ] || continue
        echo "${wan_name}:unknown" >> "$STATE_FILE"
    done
    
    while true; do
        run_health_checks
        
        # Sleep interval (use minimum interval from configs)
        interval="$(cat /var/run/mwan-health.interval 2>/dev/null || echo 10)"
        sleep "${interval:-10}"
    done
}

show_status() {
    echo "=== MWAN Health Status ==="
    echo ""
    
    if [ ! -f "$STATE_FILE" ]; then
        echo "No state file found. Daemon may not be running."
        exit 1
    fi
    
    for config in "${WAN_CONFIGS[@]}"; do
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        
        IFS=':' read -r wan_name interface _ _ _ _ <<< "$config"
        
        local health
        health=$(get_health "$wan_name")
        
        printf "%-15s %-15s %s\n" "$wan_name" "$interface" "$health"
    done
    
    echo ""
    echo "=== Recent Log Entries ==="
    tail -20 "$LOG_FILE" 2>/dev/null || echo "(no log entries)"
}

# Parse arguments
case "${1:-}" in
    --daemon)
        daemon_loop
        ;;
    --status)
        show_status
        ;;
    --check)
        run_health_checks
        ;;
    --help|-h)
        echo "Usage: $0 [--daemon|--status|--check|--help]"
        echo ""
        echo "Options:"
        echo "  --daemon    Run in daemon mode (background monitoring)"
        echo "  --status    Show current WAN status"
        echo "  --check     Run one health check cycle"
        echo "  --help      Show this help message"
        exit 0
        ;;
    *)
        echo "Usage: $0 [--daemon|--status|--check|--help]"
        exit 1
        ;;
esac

