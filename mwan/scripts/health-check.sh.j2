#!/bin/bash
# Generated by Ansible
#
# What it does (symptoms):
# - Detects “soft failures” (link is UP but WAN connectivity is broken) and triggers failover for new flows.
# - Ensures the system converges back to primary WANs when they recover (even if Monkeybrains was usable first).
#
# What it does (technical):
# - Periodically probes each WAN interface with ping/ping6 and optional HTTP checks (IPv6 preferred).
# - Maintains hysteresis counters to avoid flapping (failure_threshold / recovery_threshold).
# - Writes health state to `/var/run/mwan-health.state` using `healthy|unhealthy|unknown`.
# - Calls `/usr/local/bin/update-routes.sh` on health transitions to rebuild policy routing tables.
#
# Dependency graph:
# - Runs as: `mwan-health.service` (long-running daemon; Restart=always).
# - Called by: systemd only (daemon mode) or operators (one-shot `--check`/`--status`).
# - Calls into: `update-routes.sh` (routing convergence).
# - Requires: basic networking, `ping`/`ping6`/`curl` binaries, and that WAN interfaces exist.

set -e

STATE_FILE="/var/run/mwan-health.state"
LOG_FILE="/var/log/mwan-health.log"
DAEMON_MODE=false
DEBUG="{{ mwan_debug_logging | default(false) | ternary('1','0') }}"
DEBUG_LOG="/var/log/mwan-debug.log"
TRACE_FILE="/run/mwan-trace-id"
MWAN_TRACE_ID="${MWAN_TRACE_ID:-}"
if [ -z "${MWAN_TRACE_ID:-}" ] && [ -r "$TRACE_FILE" ]; then
    MWAN_TRACE_ID="$(cat "$TRACE_FILE" 2>/dev/null || true)"
fi

debug_json() {
    [ "$DEBUG" = "1" ] || return 0
    local loc="$1"; shift
    local msg="$1"; shift
    local data="${1:-{}}"; shift || true
    printf '{"traceId":"%s","component":"mwan-health","location":"%s","message":"%s","data":%s,"timestamp":%s}\n' \
        "${MWAN_TRACE_ID:-}" "$loc" "$msg" "$data" "$(date +%s%3N)" >> "$DEBUG_LOG"
}

# Hysteresis counters (persist across daemon iterations)
declare -gA FAIL_COUNTS=()
declare -gA OK_COUNTS=()

# WAN health check configuration from Ansible group_vars
# Format: wan_name:interface:ping_count:success_threshold:interval:failure_threshold
WAN_CONFIGS=(
    "att:{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}:{{ mwan_health_checks.att.ping_count }}:{{ mwan_health_checks.att.success_threshold }}:{{ mwan_health_checks.att.check_interval }}:{{ mwan_health_checks.att.failure_threshold }}"
    "webpass:{{ mwan_webpass_iface }}:{{ mwan_health_checks.webpass.ping_count }}:{{ mwan_health_checks.webpass.success_threshold }}:{{ mwan_health_checks.webpass.check_interval }}:{{ mwan_health_checks.webpass.failure_threshold }}"
{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
    "monkeybrains:{{ mwan_monkeybrains_iface }}:{{ mwan_health_checks.monkeybrains.ping_count }}:{{ mwan_health_checks.monkeybrains.success_threshold }}:{{ mwan_health_checks.monkeybrains.check_interval }}:{{ mwan_health_checks.monkeybrains.failure_threshold }}"
{% endif %}
)

# Health check targets from group_vars
ATT_TARGETS_V4=(
{% for target in mwan_health_checks.att.targets_v4 | default([]) %}
    "{{ target }}"
{% endfor %}
{% for target in mwan_health_checks.att.targets | default([]) %}
{% if ':' not in target %}
    "{{ target }}"
{% endif %}
{% endfor %}
)

ATT_TARGETS_V6=(
{% for target in mwan_health_checks.att.targets_v6 | default([]) %}
    "{{ target }}"
{% endfor %}
{% for target in mwan_health_checks.att.targets | default([]) %}
{% if ':' in target %}
    "{{ target }}"
{% endif %}
{% endfor %}
)

ATT_HTTP_TARGETS=(
{% for target in mwan_health_checks.att.http_targets | default([]) %}
    "{{ target }}"
{% endfor %}
)

WEBPASS_TARGETS_V4=(
{% for target in mwan_health_checks.webpass.targets_v4 | default([]) %}
    "{{ target }}"
{% endfor %}
{% for target in mwan_health_checks.webpass.targets | default([]) %}
{% if ':' not in target %}
    "{{ target }}"
{% endif %}
{% endfor %}
)

WEBPASS_TARGETS_V6=(
{% for target in mwan_health_checks.webpass.targets_v6 | default([]) %}
    "{{ target }}"
{% endfor %}
{% for target in mwan_health_checks.webpass.targets | default([]) %}
{% if ':' in target %}
    "{{ target }}"
{% endif %}
{% endfor %}
)

WEBPASS_HTTP_TARGETS=(
{% for target in mwan_health_checks.webpass.http_targets | default([]) %}
    "{{ target }}"
{% endfor %}
)

{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
MB_TARGETS_V4=(
{% for target in mwan_health_checks.monkeybrains.targets_v4 | default([]) %}
    "{{ target }}"
{% endfor %}
{% for target in mwan_health_checks.monkeybrains.targets | default([]) %}
{% if ':' not in target %}
    "{{ target }}"
{% endif %}
{% endfor %}
)

MB_TARGETS_V6=(
{% for target in mwan_health_checks.monkeybrains.targets_v6 | default([]) %}
    "{{ target }}"
{% endfor %}
{% for target in mwan_health_checks.monkeybrains.targets | default([]) %}
{% if ':' in target %}
    "{{ target }}"
{% endif %}
{% endfor %}
)

MB_HTTP_TARGETS=(
{% for target in mwan_health_checks.monkeybrains.http_targets | default([]) %}
    "{{ target }}"
{% endfor %}
)
{% endif %}

log() {
    local prefix=""
    [ -n "${MWAN_TRACE_ID:-}" ] && prefix="traceId=${MWAN_TRACE_ID} "
    local msg="[$(date '+%Y-%m-%d %H:%M:%S')] ${prefix}$1"
    echo "$msg" | tee -a "$LOG_FILE"
    logger -t mwan-health "${prefix}$1"
}

get_health() {
    local wan="$1"
    grep "^${wan}:" "$STATE_FILE" 2>/dev/null | cut -d: -f2 || echo "unknown"
}

set_health() {
    local wan="$1"
    local health="$2"
    
    # Remove old state
    sed -i "/^${wan}:/d" "$STATE_FILE" 2>/dev/null || true
    
    # Add new state
    echo "${wan}:${health}" >> "$STATE_FILE"
}

check_wan_health() {
    local wan_name="$1"
    local interface="$2"
    local ping_count="$3"
    local success_threshold="$4"
    
    local success_v4=0
    local success_v6=0
    local success_http4=0
    local success_http6=0

    local -a targets_v4
    local -a targets_v6
    local -a http_targets

    case "$wan_name" in
        att)
            targets_v4=("${ATT_TARGETS_V4[@]}")
            targets_v6=("${ATT_TARGETS_V6[@]}")
            http_targets=("${ATT_HTTP_TARGETS[@]}")
            ;;
        webpass)
            targets_v4=("${WEBPASS_TARGETS_V4[@]}")
            targets_v6=("${WEBPASS_TARGETS_V6[@]}")
            http_targets=("${WEBPASS_HTTP_TARGETS[@]}")
            ;;
{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
        monkeybrains)
            targets_v4=("${MB_TARGETS_V4[@]}")
            targets_v6=("${MB_TARGETS_V6[@]}")
            http_targets=("${MB_HTTP_TARGETS[@]}")
            ;;
{% endif %}
        *)
            targets_v4=()
            targets_v6=()
            http_targets=()
            ;;
    esac
    
    # Check if interface exists and is up
    if ! ip link show "$interface" >/dev/null 2>&1; then
        return 1
    fi
    
    if ! ip link show "$interface" | grep -q "state UP"; then
        return 1
    fi
    
    # IPv6 health check FIRST (P0 priority)
    local has_ipv6=false
    if ip -6 addr show dev "$interface" | grep -q "scope global"; then
        has_ipv6=true
        for target in "${targets_v6[@]}"; do
            [ -n "$target" ] || continue
            if ping6 -c "$ping_count" -W 2 -I "$interface" "$target" >/dev/null 2>&1; then
                success_v6=$((success_v6 + 1))
            fi
        done
        for url in "${http_targets[@]}"; do
            [ -n "$url" ] || continue
            if curl -6 -sS --connect-timeout 2 --max-time 5 --interface "$interface" "$url" >/dev/null 2>&1; then
                success_http6=$((success_http6 + 1))
            fi
        done
    fi
    
    # IPv4 health check (secondary)
    for target in "${targets_v4[@]}"; do
        [ -n "$target" ] || continue
        if ping -c "$ping_count" -W 2 -I "$interface" "$target" >/dev/null 2>&1; then
            success_v4=$((success_v4 + 1))
        fi
    done
    for url in "${http_targets[@]}"; do
        [ -n "$url" ] || continue
        if curl -4 -sS --connect-timeout 2 --max-time 5 --interface "$interface" "$url" >/dev/null 2>&1; then
            success_http4=$((success_http4 + 1))
        fi
    done
    
    [ "$DEBUG" = "1" ] && debug_json "CHECK" "probe_results" "$(python3 - <<'PY'
import json,os
print(json.dumps({
  "wan": os.environ.get("wan_name",""),
  "iface": os.environ.get("interface",""),
  "success_v6": os.environ.get("success_v6",""),
  "success_http6": os.environ.get("success_http6",""),
  "success_v4": os.environ.get("success_v4",""),
  "success_http4": os.environ.get("success_http4",""),
  "threshold": os.environ.get("success_threshold",""),
}))
PY
)"

    # WAN is healthy if IPv6 meets threshold (preferred)
    # or IPv4 meets threshold (fallback)
    # IPv6 is checked first and preferred
    if [ $success_v6 -ge $success_threshold ] || [ $success_http6 -ge 1 ]; then
        [ "$DEBUG" = "1" ] && debug_json "DECISION" "wan_up" "{\"wan\":\"$wan_name\",\"iface\":\"$interface\",\"reason\":\"v6\"}"
        return 0
    elif [ $success_v4 -ge $success_threshold ] || [ $success_http4 -ge 1 ]; then
        [ "$DEBUG" = "1" ] && debug_json "DECISION" "wan_up" "{\"wan\":\"$wan_name\",\"iface\":\"$interface\",\"reason\":\"v4\"}"
        return 0
    else
        [ "$DEBUG" = "1" ] && debug_json "DECISION" "wan_down" "{\"wan\":\"$wan_name\",\"iface\":\"$interface\"}"
        return 1
    fi
}

handle_wan_failure() {
    local wan_name="$1"
    
    log "WAN $wan_name failed health check"
    
    local old_state
    old_state=$(get_health "$wan_name")
    
    if [ "$old_state" != "unhealthy" ]; then
        set_health "$wan_name" "unhealthy"
        log "Marking $wan_name as UNHEALTHY (was $old_state)"
        
        # Update routing to remove failed WAN
        /usr/local/bin/update-routes.sh
        
        # Send notification if configured
        # send_notification "$wan_name" "down"
    fi
}

handle_wan_recovery() {
    local wan_name="$1"
    
    local old_state
    old_state=$(get_health "$wan_name")
    
    if [ "$old_state" != "healthy" ]; then
        log "WAN $wan_name health check passed"
        set_health "$wan_name" "healthy"
        log "Marking $wan_name as HEALTHY (was $old_state)"
        
        # Update routing to add recovered WAN
        /usr/local/bin/update-routes.sh
        
        # Send notification if configured
        # send_notification "$wan_name" "up"
    fi
}

run_health_checks() {
    local min_interval=999999

    # Ensure the state file exists even in one-shot mode.
    if [ ! -f "$STATE_FILE" ]; then
        : > "$STATE_FILE"
        for config in "${WAN_CONFIGS[@]}"; do
            [[ "$config" =~ ^[[:space:]]*# ]] && continue
            IFS=':' read -r wan_name _ _ _ _ _ <<< "$config"
            [ -n "${wan_name:-}" ] || continue
            echo "${wan_name}:unknown" >> "$STATE_FILE"
        done
    fi

    for config in "${WAN_CONFIGS[@]}"; do
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        IFS=':' read -r _ _ _ _ interval _ <<< "$config"
        if [ -n "$interval" ] && [ "$interval" -lt "$min_interval" ]; then
            min_interval="$interval"
        fi
    done

    for config in "${WAN_CONFIGS[@]}"; do
        # Skip commented configs
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        
        IFS=':' read -r wan_name interface ping_count success_threshold interval failure_threshold <<< "$config"
        local recovery_threshold=2

        # Pull per-WAN recovery_threshold from group_vars (fallback 2)
        case "$wan_name" in
            att) recovery_threshold={{ mwan_health_checks.att.recovery_threshold | default(2) }} ;;
            webpass) recovery_threshold={{ mwan_health_checks.webpass.recovery_threshold | default(2) }} ;;
{% if mwan_health_checks.monkeybrains.enabled | default(false) %}
            monkeybrains) recovery_threshold={{ mwan_health_checks.monkeybrains.recovery_threshold | default(2) }} ;;
{% endif %}
            *) recovery_threshold=2 ;;
        esac

        FAIL_COUNTS["$wan_name"]="${FAIL_COUNTS["$wan_name"]:-0}"
        OK_COUNTS["$wan_name"]="${OK_COUNTS["$wan_name"]:-0}"
        
        if check_wan_health "$wan_name" "$interface" "$ping_count" "$success_threshold"; then
            OK_COUNTS["$wan_name"]=$((OK_COUNTS["$wan_name"] + 1))
            FAIL_COUNTS["$wan_name"]=0
            
            # Need N consecutive successes to mark as up (prevents flapping)
            if [ "${OK_COUNTS["$wan_name"]}" -ge "$recovery_threshold" ]; then
                handle_wan_recovery "$wan_name"
            fi
        else
            FAIL_COUNTS["$wan_name"]=$((FAIL_COUNTS["$wan_name"] + 1))
            OK_COUNTS["$wan_name"]=0
            
            if [ "${FAIL_COUNTS["$wan_name"]}" -ge "$failure_threshold" ]; then
                handle_wan_failure "$wan_name"
            fi
        fi
    done

    # Store computed minimum interval for daemon sleep
    echo "$min_interval" > /var/run/mwan-health.interval 2>/dev/null || true
}

daemon_loop() {
    log "Starting mwan-health daemon"
    
    # Initialize state file
    : > "$STATE_FILE"
    # Write initial states so other components never see an empty file.
    for config in "${WAN_CONFIGS[@]}"; do
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        IFS=':' read -r wan_name _ _ _ _ _ <<< "$config"
        [ -n "${wan_name:-}" ] || continue
        echo "${wan_name}:unknown" >> "$STATE_FILE"
    done
    
    while true; do
        run_health_checks
        
        # Sleep interval (use minimum interval from configs)
        interval="$(cat /var/run/mwan-health.interval 2>/dev/null || echo 10)"
        sleep "${interval:-10}"
    done
}

show_status() {
    echo "=== MWAN Health Status ==="
    echo ""
    
    if [ ! -f "$STATE_FILE" ]; then
        echo "No state file found. Daemon may not be running."
        exit 1
    fi
    
    for config in "${WAN_CONFIGS[@]}"; do
        [[ "$config" =~ ^[[:space:]]*# ]] && continue
        
        IFS=':' read -r wan_name interface _ _ _ _ <<< "$config"
        
        local health
        health=$(get_health "$wan_name")
        
        printf "%-15s %-15s %s\n" "$wan_name" "$interface" "$health"
    done
    
    echo ""
    echo "=== Recent Log Entries ==="
    tail -20 "$LOG_FILE" 2>/dev/null || echo "(no log entries)"
}

# Parse arguments
case "${1:-}" in
    --daemon)
        DAEMON_MODE=true
        daemon_loop
        ;;
    --status)
        show_status
        ;;
    --check)
        run_health_checks
        ;;
    --help|-h)
        echo "Usage: $0 [--daemon|--status|--check|--help]"
        echo ""
        echo "Options:"
        echo "  --daemon    Run in daemon mode (background monitoring)"
        echo "  --status    Show current WAN status"
        echo "  --check     Run one health check cycle"
        echo "  --help      Show this help message"
        exit 0
        ;;
    *)
        echo "Usage: $0 [--daemon|--status|--check|--help]"
        exit 1
        ;;
esac

