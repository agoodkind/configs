#!/usr/bin/env bash
# Generated by Ansible
#
# What it does (symptoms):
# - Makes outbound IPv6 from internal `3d06:bad:b01::/60` work by translating it onto a WAN delegated prefix.
# - Makes inbound IPv6 to the WAN PD space reach OPNsense by applying reverse translation (DNPT/DNAT).
# - If this does not run (or rules were flushed), `nft list table ip6 nat` will be empty and IPv6 services break.
#
# What it does (technical):
# - Programs runtime rules into `nft table ip6 nat`:
#   - postrouting: SNAT `3d06:bad:b01::/60` -> WAN /60, plus SNAT guards for hairpinned flows.
#   - prerouting: DNAT WAN /60 -> internal /60 and WAN `::1/128` -> OPNsense edge address.
# - Ensures each WAN has its PD `::1/128` address present on the interface.
# - For Monkeybrains, can derive a /60 from a delegated /56 (or use a configured static /60).
#
# Dependency graph:
# - Event-driven: `networkd-dispatcher` hook `55-update-npt.sh` (runs when WAN becomes `routable`).
# - Boot/deploy safety net: `mwan-update-npt.service` (reapplies after boot and after `nftables` reload).
# - Requires: base `nft table ip6 nat` exists (nftables loaded) and the WAN interface exists.

set -euo pipefail

WAN_IFACE="$1"
DELEGATED_PREFIX="$2"

# shellcheck disable=SC1091
. /etc/mwan/mwan.env

DEBUG="${MWAN_DEBUG_LOGGING:-0}"
DEBUG_LOG="${MWAN_DEBUG_LOG:-/var/log/mwan-debug.log}"
TRACE_FILE="${MWAN_TRACE_FILE:-/run/mwan-trace-id}"
MWAN_TRACE_ID="${MWAN_TRACE_ID:-}"
if [ -z "${MWAN_TRACE_ID:-}" ] && [ -r "$TRACE_FILE" ]; then
    MWAN_TRACE_ID="$(cat "$TRACE_FILE")"
fi

if [ -z "$WAN_IFACE" ] || [ -z "$DELEGATED_PREFIX" ]; then
    echo "Usage: $(basename "$0") <wan_iface> <delegated_prefix>"
    echo "Example: $(basename "$0") enatt0.3242 2600:1700:2f71:c80::/60"
    exit 1
fi

# Serialize updates to avoid concurrent partial nftables state.
# This script edits shared chains (`ip6 nat`), so use a global lock.
LOCK_FILE="/run/mwan-update-npt.lock"
exec 9>"$LOCK_FILE"
flock 9

readonly INTERNAL_PREFIX="${MWAN_INTERNAL_PREFIX:-}"
readonly OPNSENSE_EDGE_V6="${MWAN_OPNSENSE_EDGE_IPV6:-}"
readonly MWANBR_EDGE_V6="${MWAN_MWANBR_EDGE_IPV6:-}"
readonly MB_STATIC_PREFIX="${MWAN_NPT_MONKEYBRAINS_PREFIX:-}"

ipcalc_field() {
    local cidr="$1"
    local field="$2" # e.g. .NETWORK
    local out

    out="$(ipcalc-ng --all-info -j "$cidr" 2>/dev/null)" || return 0
    jq -r "${field} // empty" <<<"$out" 2>/dev/null || return 0
}

first_60_of_prefix() {
    # Given an IPv6 prefix like 2607:f598:d3e0:131::/56, return the first /60 inside it.
    local cidr="$1"
    local plen="${cidr##*/}"
    [[ "$plen" =~ ^[0-9]+$ ]] || return 1
    [ "$plen" -le 60 ] || return 1

    local base net60
    base="$(ipcalc_field "$cidr" '.NETWORK')"
    [ -n "$base" ] || return 1
    net60="$(ipcalc_field "$base/60" '.NETWORK')"
    [ -n "$net60" ] || return 1
    printf '%s/60\n' "$net60"
}

log() {
    local msg="$1"
    local prefix=""
    [ -n "${MWAN_TRACE_ID:-}" ] && prefix="traceId=${MWAN_TRACE_ID} "
    logger -t update-npt "${prefix}${msg}"
    echo "[update-npt] ${prefix}${msg}"
}

debug_json() {
    [ "$DEBUG" = "1" ] || return 0
    local loc="$1"; shift
    local msg="$1"; shift
    local data="${1:-{}}"; shift || true
    exec 9>>"$DEBUG_LOG"
    flock -w 2 9 || true

    jq -cn \
      --arg traceId "${MWAN_TRACE_ID:-}" \
      --arg component "update-npt" \
      --arg location "$loc" \
      --arg message "$msg" \
      --arg data "${data:-{}}" \
      --argjson timestamp "$(date +%s%3N)" \
      '
      def parsed($s): (try ($s | fromjson) catch null);
      def p: parsed($data);
      {
        traceId: $traceId,
        component: $component,
        location: $location,
        message: $message,
        data: (p // {}),
        dataParseError: (p == null),
        dataRaw: (if (p == null) then $data else null end),
        timestamp: $timestamp
      }' >&9

    flock -u 9 || true
    exec 9>&-
}

log "Updating NPT rules for $WAN_IFACE"
log "  Delegated prefix: $DELEGATED_PREFIX"

# Collect existing per-iface rule handles (we delete them in the same nft batch as we add replacements).
POST_HANDLES="$(
  nft -a list chain ip6 nat postrouting 2>/dev/null |
    awk -v ifc="$WAN_IFACE" '
      $0 ~ ("oif \\\"" ifc "\\\"") && $0 ~ /# handle/ { print $NF }
    '
)"
PRE_HANDLES="$(
  nft -a list chain ip6 nat prerouting 2>/dev/null |
    awk -v ifc="$WAN_IFACE" '
      $0 ~ ("iif \\\"" ifc "\\\"") && $0 ~ /# handle/ { print $NF }
    '
)"

# Decide target /60 for this iface.
# NOTE: NPT is stateless and requires internal/external prefixes to be the same length (/60 here).
case "$WAN_IFACE" in
    "${MWAN_ATT_VLAN_IFACE:-}")
        TARGET_PREFIX="${MWAN_NPT_ATT_PREFIX:-}"
        ;;
    "${MWAN_WEBPASS_IFACE:-}")
        TARGET_PREFIX="${MWAN_NPT_WEBPASS_PREFIX:-}"
        ;;
    "${MWAN_MONKEYBRAINS_IFACE:-}")
        if [ -n "$MB_STATIC_PREFIX" ]; then
            TARGET_PREFIX="$MB_STATIC_PREFIX"
        else
            # Monkeybrains may delegate a /56; pick the first /60 from the delegated prefix.
            TARGET_PREFIX="$(first_60_of_prefix "$DELEGATED_PREFIX" || true)"
            if [ -z "$TARGET_PREFIX" ]; then
                log "Delegated prefix $DELEGATED_PREFIX is not usable for /60 NPT; skipping"
                exit 0
            fi
        fi
        ;;
    *)
        log "Unknown WAN iface $WAN_IFACE; skipping"
        exit 0
        ;;
esac

[ "$DEBUG" = "1" ] && debug_json "SELECT" "target_prefix_selected" "$(jq -cn \
  --arg iface "$WAN_IFACE" \
  --arg delegated "$DELEGATED_PREFIX" \
  --arg target "$TARGET_PREFIX" \
  '{
    iface: $iface,
    delegated: $delegated,
    target: $target
  }')"

# Postrouting:
# - SNAT specific /128s (fe::1, fe::2) to PD ::1
# - NPT broader /60 to PD /60
# Add PD ::1 address to interface first
ip -6 addr replace "${TARGET_PREFIX%/*}1/128" dev "$WAN_IFACE" nodad || true

# Apply nftables changes in a single `nft -f` batch to avoid partial state.
tmp="$(mktemp)"
{
    for h in $POST_HANDLES; do
        echo "delete rule ip6 nat postrouting handle $h"
    done
    for h in $PRE_HANDLES; do
        echo "delete rule ip6 nat prerouting handle $h"
    done

    # If this packet is part of a DNAT'd flow to the OPNsense edge address, do NOT clobber
    # conntrack's reverse-NAT with an unconditional SNAT rule.
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $OPNSENSE_EDGE_V6/128 ct status dnat return"
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $OPNSENSE_EDGE_V6/128 snat to ${TARGET_PREFIX%/*}1"
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $MWANBR_EDGE_V6/128 snat to ${TARGET_PREFIX%/*}1"
    echo "add rule ip6 nat postrouting oif \"$WAN_IFACE\" ip6 saddr $INTERNAL_PREFIX snat ip6 prefix to $TARGET_PREFIX"

    # Prerouting:
    echo "add rule ip6 nat prerouting iif \"$WAN_IFACE\" ip6 daddr ${TARGET_PREFIX%/*}1/128 dnat to $OPNSENSE_EDGE_V6"
    echo "add rule ip6 nat prerouting iif \"$WAN_IFACE\" ip6 daddr $TARGET_PREFIX dnat ip6 prefix to $INTERNAL_PREFIX"

    # Also DNAT any other global /128 address currently assigned to the WAN interface back to OPNsense.
    emit_extra_prerouting_dnat_rules() {
        # For any additional global /128s on the WAN interface (besides PD ::1),
        # DNAT them to the OPNsense edge so inbound traffic doesn't terminate on MWAN.
        local ifc="$1"
        local keep_cidr="$2" # e.g. "<pd>::1/128"

        ip -6 addr show dev "$ifc" scope global 2>/dev/null \
          | awk '
                $1 == "inet6" { print $2 }
            ' \
          | awk -v keep="$keep_cidr" '
                $0 ~ /\/128$/ && $0 != keep { sub(/\/128$/, "", $0); print }
            ' \
          | while read -r ip6_addr; do
                [ -n "${ip6_addr:-}" ] || continue
                echo "add rule ip6 nat prerouting iif \"$ifc\" ip6 daddr ${ip6_addr}/128 dnat to $OPNSENSE_EDGE_V6"
            done
    }

    emit_extra_prerouting_dnat_rules "$WAN_IFACE" "${TARGET_PREFIX%/*}1/128" || true
} >"$tmp"
nft -f "$tmp"
rm -f "$tmp"

# Save current nftables config
nft list ruleset > /etc/nftables.conf.dynamic

if [ "$DEBUG" = "1" ]; then
    prerouting_chain="$(nft -a list chain ip6 nat prerouting || true)"
    postrouting_chain="$(nft -a list chain ip6 nat postrouting || true)"

    debug_json "NFT" "ip6_nat_chains" "$(
        jq -cn \
            --arg prerouting "$prerouting_chain" \
            --arg postrouting "$postrouting_chain" \
            '{
              prerouting: $prerouting,
              postrouting: $postrouting
            }'
    )"
fi

log "NPT update complete for $WAN_IFACE"
