#!/usr/bin/env bash
# Generated by Ansible
#
# What it does (symptoms):
# - Prints the DHCPv6-PD delegated prefixes currently associated with a WAN interface.
# - Avoids brittle “scrape journald” logic when networkd already has the prefixes in memory.
#
# What it does (technical):
# - Tries multiple discovery methods in priority order and emits one or more IPv6 CIDRs.
# - Prefers `org.freedesktop.network1.Link.Describe()` which returns JSON including
#   DHCPv6-PD prefixes tracked on the in-memory `sd_dhcp6_lease`.
#
# Methods (in priority order):
#  1) systemd-networkd D-Bus: Link.Describe JSON (preferred)
#  2) networkctl --json=short (best-effort; version-dependent)
#  3) proto-dhcp routes for dev (coarse; may be empty/misleading)
#  4) journald (fallback): last "DHCP: received delegated prefix" line for iface
#  5) cached state file: /var/lib/mwan/pd-<iface> (optional last-known)
#
# Dependency graph:
# - Called by: `mwan` debug helper and `networkd-dispatcher` hooks.
# - Inputs: systemd-networkd state via D-Bus / networkctl / kernel routes / journald.
#
# Output:
# - Default: prints one CIDR per line (canonicalized via ipcalc-ng; e.g. 2600:1700:2f71:c80::/60)
# - --one: prints only the first CIDR (or nothing)

set -euo pipefail

IFACE="${1:-}"
MODE="${2:-}" # optional: --one

[ -n "$IFACE" ] || {
    echo "usage: find-pd-prefixes.sh <iface> [--one]" >&2
    exit 2
}

STATE_FILE="/var/lib/mwan/pd-$IFACE"

bytes16_to_ipv6() {
    # Convert 16 decimal bytes to an IPv6 string (8 hextets).
    #
    # Input: 16 decimal bytes as args (0-255)
    # Output: expanded IPv6 (8 hextets), suitable for feeding into ipcalc-ng.
    local -a b=("$@")
    local hex

    [ "${#b[@]}" -eq 16 ] || return 1

    hex="$(printf '%02x' "${b[@]}")"
    printf '%s:%s:%s:%s:%s:%s:%s:%s\n' \
        "${hex:0:4}"  "${hex:4:4}"  "${hex:8:4}"  "${hex:12:4}" \
        "${hex:16:4}" "${hex:20:4}" "${hex:24:4}" "${hex:28:4}"
}

ipcalc6_field() {
    local cidr="$1"
    local field="$2" # e.g. .NETWORK or .PREFIX
    local out

    out="$(ipcalc-ng --all-info -j -6 "$cidr" 2>/dev/null)" || return 0
    jq -r "${field} // empty" <<<"$out" 2>/dev/null || return 0
}

normalize_ipv6_cidr() {
    # Emit a canonical CIDR for any valid IPv6 CIDR input.
    #
    # Note: ipcalc-ng's JSON provides both NETWORK and PREFIX fields. We rebuild
    # "<network>/<prefix>" so callers get a consistent CIDR output.
    local cidr="$1" net pref
    net="$(ipcalc6_field "$cidr" '.NETWORK')"
    pref="$(ipcalc6_field "$cidr" '.PREFIX')"
    [ -n "$net" ] || return 1
    [ -n "$pref" ] || return 1
    echo "${net}/${pref}"
}

emit_first_if_requested() {
    if [ "$MODE" = "--one" ]; then
        head -n 1 || true
        exit 0
    fi
    cat
}

from_describe() {
    local path
    path="$(
        busctl -j --no-pager --system call \
            org.freedesktop.network1 \
            /org/freedesktop/network1 \
            org.freedesktop.network1.Manager \
            GetLinkByName s "$IFACE" 2>/dev/null \
          | jq -r '.data[1] // empty' 2>/dev/null \
          || true
    )"
    [ -n "$path" ] || return 1

    # Describe returns a JSON string inside .data[0]
    busctl -j --no-pager --system call \
        org.freedesktop.network1 \
        "$path" \
        org.freedesktop.network1.Link \
        Describe 2>/dev/null \
      | jq -r '.data[0] // empty' 2>/dev/null \
      | jq -r '
          try (.DHCPv6Client.Prefixes // []) catch []
          | .[]
          | "\(.Prefix | map(tostring) | join(" "))|\(.PrefixLength // empty)"
        ' 2>/dev/null \
      | while IFS='|' read -r bytes plen; do
            [ -n "${bytes:-}" ] || continue
            [ -n "${plen:-}" ] || continue

            # shellcheck disable=SC2206
            b=($bytes)
            ip=""
            if ip="$(bytes16_to_ipv6 "${b[@]}" 2>/dev/null)"; then
                [ -n "${ip:-}" ] || continue
            else
                continue
            fi

            normalize_ipv6_cidr "${ip}/${plen}" || true
        done
}

from_networkctl_json() {
    networkctl status "$IFACE" --json=short --no-pager 2>/dev/null \
      | jq -r '
          [
            (.. | objects | .DelegatedPrefixes? // empty),
            (.. | objects | .DelegatedPrefix? // empty),

            # Fallback: any IPv6 CIDR-ish strings; keep <= /60 to avoid pulling on-link /64s.
            (.. | strings
              | select(test("^[0-9A-Fa-f:]+::?/[0-9]{1,3}$"))
              | select((split("/")[1] | tonumber) <= 60))
          ]
          | flatten
          | map(select(type=="string"))
          | unique
          | .[]
        ' 2>/dev/null
}

from_proto_dhcp_routes() {
    ip -j -6 route show proto dhcp dev "$IFACE" 2>/dev/null \
      | jq -r '.[].dst // empty' 2>/dev/null
}

from_journal() {
    journalctl -u systemd-networkd -b 2>/dev/null \
      | grep "$IFACE: DHCP: received delegated prefix" \
      | tail -1 \
      | awk '{print $NF}' \
      | awk 'NF{print}'
}

from_state_file() {
    [ -f "$STATE_FILE" ] || return 1
    awk 'NF{print}' "$STATE_FILE" 2>/dev/null
}

normalize_unique_ipv6_cidrs() {
    # Read CIDRs on stdin, normalize, drop empties, unique-sort.
    while read -r c; do
        [ -n "${c:-}" ] || continue
        normalize_ipv6_cidr "$c" || true
    done | awk 'NF{print}' | sort -u
}

main() {
    local out=""

    out="$(
        from_describe 2>/dev/null \
          | awk 'NF{print}' \
          | sort -u \
          || true
    )"
    if [ -n "$out" ]; then
        printf "%s\n" "$out" | emit_first_if_requested
        exit 0
    fi

    out="$(
        from_networkctl_json 2>/dev/null \
          | normalize_unique_ipv6_cidrs \
          || true
    )"
    if [ -n "$out" ]; then
        printf "%s\n" "$out" | emit_first_if_requested
        exit 0
    fi

    out="$(
        from_proto_dhcp_routes 2>/dev/null \
          | normalize_unique_ipv6_cidrs \
          || true
    )"
    if [ -n "$out" ]; then
        printf "%s\n" "$out" | emit_first_if_requested
        exit 0
    fi

    out="$(
        from_journal 2>/dev/null \
          | normalize_unique_ipv6_cidrs \
          || true
    )"
    if [ -n "$out" ]; then
        printf "%s\n" "$out" | emit_first_if_requested
        exit 0
    fi

    out="$(
        from_state_file 2>/dev/null \
          | normalize_unique_ipv6_cidrs \
          || true
    )"
    if [ -n "$out" ]; then
        printf "%s\n" "$out" | emit_first_if_requested
        exit 0
    fi

    exit 0
}

main

