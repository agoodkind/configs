#!/bin/bash
# Update policy routing tables for multi-WAN
# Generated by Ansible

set -e

log() {
    local msg="$1"
    local prefix=""
    [ -n "${MWAN_TRACE_ID:-}" ] && prefix="traceId=${MWAN_TRACE_ID} "
    echo "[update-routes] ${prefix}${msg}"
    logger -t update-routes "${prefix}${msg}" || true
}

DEBUG="{{ mwan_debug_logging | default(false) | ternary('1','0') }}"
DEBUG_LOG="/var/log/mwan-debug.log"
TRACE_FILE="/run/mwan-trace-id"
MWAN_TRACE_ID="${MWAN_TRACE_ID:-}"
if [ -z "${MWAN_TRACE_ID:-}" ] && [ -r "$TRACE_FILE" ]; then
    MWAN_TRACE_ID="$(cat "$TRACE_FILE" 2>/dev/null || true)"
fi

debug_json() {
    [ "$DEBUG" = "1" ] || return 0
    local loc="$1"; shift
    local msg="$1"; shift
    local data="${1:-{}}"; shift || true
    jq -cn \
      --arg traceId "${MWAN_TRACE_ID:-}" \
      --arg component "update-routes" \
      --arg location "$loc" \
      --arg message "$msg" \
      --arg data "${data:-{}}" \
      --argjson timestamp "$(date +%s%3N)" \
      '{
        traceId: $traceId,
        component: $component,
        location: $location,
        message: $message,
        data: (try ($data | fromjson) catch {}),
        timestamp: $timestamp
      }' >> "$DEBUG_LOG"
}

log "Updating policy routing tables"

# Interface names from Ansible template
MGMT_IFACE="{{ mwan_mgmt_iface }}"
ATT_IFACE="{{ mwan_att_iface }}.{{ mwan_att_vlan_id }}"  # AT&T uses VLAN subinterface
WEBPASS_IFACE="{{ mwan_webpass_iface }}"
MB_IFACE="{{ mwan_monkeybrains_iface | default('enmbrains0') }}"
INTERNAL_IFACE="{{ mwan_internal_iface }}"
OPNSENSE_WAN_LL="{{ mwan_opnsense_wan_ll }}"
OPNSENSE_EDGE_V6="{{ mwan_opnsense_edge_ipv6 | default('3d06:bad:b01:fe::2') }}"

# Health state (soft failures) from mwan-health
# Format: wan_name:state (e.g. "att:up", "webpass:down")
STATE_FILE="/var/run/mwan-health.state"
wan_state() {
    local wan="$1"
    [ -r "$STATE_FILE" ] || { echo "unknown"; return 0; }
    grep "^${wan}:" "$STATE_FILE" 2>/dev/null | tail -n1 | cut -d: -f2 || echo "unknown"
}
# Treat unknown as up to avoid cutting traffic during daemon warmup.
wan_is_up() {
    [ "$(wan_state "$1")" != "down" ]
}

# Get gateways
get_gw4() {
    ip -4 route show dev "$1" | sed -n 's/^default via \([^ ]*\).*/\1/p' | head -1
}

get_gw6() {
    # Extract v6 gateway for a specific dev from `ip -6 route show default`.
    #
    # Handles:
    # - default via fe80::... dev <if>
    # - default nhid <id> via fe80::... dev <if> ...
    # - default
    #     nexthop via fe80::... dev <if> weight 1
    ip -6 route show default 2>/dev/null | awk -v dev="$1" '
        $1=="default" {
            gw=""; d="";
            for (i=1; i<=NF; i++) {
                if ($i=="via") gw=$(i+1);
                if ($i=="dev") d=$(i+1);
            }
            if (d==dev && gw!="") { print gw; exit }
        }
        $1=="nexthop" && $2=="via" {
            gw=$3;
            for (i=1; i<=NF; i++) if ($i=="dev") d=$(i+1);
            if (d==dev && gw!="") { print gw; exit }
        }
    '
}

defaults_json() {
  jq -cn \
    --arg v4 "$(ip -4 route show default || true)" \
    --arg v6 "$(ip -6 route show default || true)" \
    '{v4:$v4, v6:$v6}'
}

[ "$DEBUG" = "1" ] && debug_json "DEFAULTS" "ip_default_routes" "$(defaults_json)"

[ -n "$ATT_IFACE" ] && ATT_GW4="$(get_gw4 "$ATT_IFACE")"
[ -n "$WEBPASS_IFACE" ] && WEBPASS_GW4="$(get_gw4 "$WEBPASS_IFACE")"
[ -n "$MB_IFACE" ] && MB_GW4="$(get_gw4 "$MB_IFACE")"
[ -n "$ATT_IFACE" ] && ATT_GW6="$(get_gw6 "$ATT_IFACE")"
[ -n "$WEBPASS_IFACE" ] && WEBPASS_GW6="$(get_gw6 "$WEBPASS_IFACE")"
[ -n "$MB_IFACE" ] && MB_GW6="$(get_gw6 "$MB_IFACE")"

log "AT&T: $ATT_IFACE (v6: $ATT_GW6, v4: $ATT_GW4)"
log "Webpass: $WEBPASS_IFACE (v6: $WEBPASS_GW6, v4: $WEBPASS_GW4)"
log "Monkeybrains: $MB_IFACE (v6: $MB_GW6, v4: $MB_GW4)"

gateways_json() {
  jq -cn \
    --arg att_iface "${ATT_IFACE:-}" \
    --arg webpass_iface "${WEBPASS_IFACE:-}" \
    --arg mb_iface "${MB_IFACE:-}" \
    --arg att_gw4 "${ATT_GW4:-}" \
    --arg webpass_gw4 "${WEBPASS_GW4:-}" \
    --arg mb_gw4 "${MB_GW4:-}" \
    --arg att_gw6 "${ATT_GW6:-}" \
    --arg webpass_gw6 "${WEBPASS_GW6:-}" \
    --arg mb_gw6 "${MB_GW6:-}" \
    --arg att_state "$(wan_state att)" \
    --arg webpass_state "$(wan_state webpass)" \
    --arg mb_state "$(wan_state monkeybrains)" \
    '{
      att_iface: $att_iface,
      webpass_iface: $webpass_iface,
      mb_iface: $mb_iface,
      att_gw4: $att_gw4,
      webpass_gw4: $webpass_gw4,
      mb_gw4: $mb_gw4,
      att_gw6: $att_gw6,
      webpass_gw6: $webpass_gw6,
      mb_gw6: $mb_gw6,
      health: {att: $att_state, webpass: $webpass_state, monkeybrains: $mb_state}
    }'
}

[ "$DEBUG" = "1" ] && debug_json "GW" "parsed_gateways" "$(gateways_json)"

# Clear existing policy routing rules (except main table)
ip rule del table {{ mwan_rt_tables.att }} 2>/dev/null || true
ip rule del table {{ mwan_rt_tables.webpass }} 2>/dev/null || true
ip rule del table {{ mwan_rt_tables.monkeybrains }} 2>/dev/null || true
ip -6 rule del table {{ mwan_rt_tables.att }} 2>/dev/null || true
ip -6 rule del table {{ mwan_rt_tables.webpass }} 2>/dev/null || true
ip -6 rule del table {{ mwan_rt_tables.monkeybrains }} 2>/dev/null || true

# Flush routing tables
ip route flush table {{ mwan_rt_tables.att }} 2>/dev/null || true
ip route flush table {{ mwan_rt_tables.webpass }} 2>/dev/null || true
ip route flush table {{ mwan_rt_tables.monkeybrains }} 2>/dev/null || true
ip -6 route flush table {{ mwan_rt_tables.att }} 2>/dev/null || true
ip -6 route flush table {{ mwan_rt_tables.webpass }} 2>/dev/null || true
ip -6 route flush table {{ mwan_rt_tables.monkeybrains }} 2>/dev/null || true

# Set up AT&T routing table (table {{ mwan_rt_tables.att }}) - IPv6 FIRST (P0 priority)
if wan_is_up att && [ -n "$ATT_IFACE" ] && [ -n "$ATT_GW6" ]; then
    log "Setting up AT&T IPv6 routing table (priority)"
    ip -6 route replace default \
        via "$ATT_GW6" dev "$ATT_IFACE" table {{ mwan_rt_tables.att }}
    ip -6 rule add fwmark 1 table {{ mwan_rt_tables.att }} priority 100
else
    [ "$DEBUG" = "1" ] && debug_json "ATT" "skipped_ipv6_table" "$(jq -cn \
      --arg iface "${ATT_IFACE:-}" \
      --arg gw6 "${ATT_GW6:-}" \
      '{iface:$iface, gw6:$gw6}')"
fi

if wan_is_up att && [ -n "$ATT_IFACE" ] && [ -n "$ATT_GW4" ]; then
    log "Setting up AT&T IPv4 routing table"
    ip route replace default \
        via "$ATT_GW4" dev "$ATT_IFACE" table {{ mwan_rt_tables.att }}
    ip rule add fwmark 1 table {{ mwan_rt_tables.att }} priority 100
fi

# Set up Webpass routing table (table {{ mwan_rt_tables.webpass }}) - IPv6 FIRST
if wan_is_up webpass && [ -n "$WEBPASS_IFACE" ] && [ -n "$WEBPASS_GW6" ]; then
    log "Setting up Webpass IPv6 routing table (priority)"
    ip -6 route replace default \
        via "$WEBPASS_GW6" dev "$WEBPASS_IFACE" \
        table {{ mwan_rt_tables.webpass }}
    ip -6 rule add fwmark 2 table {{ mwan_rt_tables.webpass }} priority 200
else
    [ "$DEBUG" = "1" ] && debug_json "WEBPASS" "skipped_ipv6_table" "$(jq -cn \
      --arg iface "${WEBPASS_IFACE:-}" \
      --arg gw6 "${WEBPASS_GW6:-}" \
      '{iface:$iface, gw6:$gw6}')"
fi

if wan_is_up webpass && [ -n "$WEBPASS_IFACE" ] && [ -n "$WEBPASS_GW4" ]; then
    log "Setting up Webpass IPv4 routing table"
    ip route replace default \
        via "$WEBPASS_GW4" dev "$WEBPASS_IFACE" \
        table {{ mwan_rt_tables.webpass }}
    ip rule add fwmark 2 table {{ mwan_rt_tables.webpass }} priority 200
fi

# Set up Monkeybrains routing table (table {{ mwan_rt_tables.monkeybrains }}) - fallback only
if wan_is_up monkeybrains && [ -n "$MB_IFACE" ] && [ -n "$MB_GW6" ]; then
    log "Setting up Monkeybrains IPv6 routing table (fallback)"
    ip -6 route replace default \
        via "$MB_GW6" dev "$MB_IFACE" table {{ mwan_rt_tables.monkeybrains }}
    ip -6 rule add fwmark 3 table {{ mwan_rt_tables.monkeybrains }} priority 300
fi
if wan_is_up monkeybrains && [ -n "$MB_IFACE" ] && [ -n "$MB_GW4" ]; then
    log "Setting up Monkeybrains IPv4 routing table (fallback)"
    ip route replace default \
        via "$MB_GW4" dev "$MB_IFACE" table {{ mwan_rt_tables.monkeybrains }}
    ip rule add fwmark 3 table {{ mwan_rt_tables.monkeybrains }} priority 300
fi

# Main table is intentionally untouched to avoid disrupting management

# Add internal network routes to all tables (so WANs can reach internal subnets)
for table in {{ mwan_rt_tables.att }} {{ mwan_rt_tables.webpass }} {{ mwan_rt_tables.monkeybrains }}; do
    ip route add 10.250.250.0/29 dev "$INTERNAL_IFACE" table $table 2>/dev/null || true

    # Hairpin DNAT targets (e.g. WAN /128 interface addresses) are forwarded to OPNsense over the MWAN link.
    # Inbound flows are fwmarked by ingress WAN; without an explicit route in the policy tables, the fwmark
    # default route would try to send these packets back out the WAN instead of toward OPNsense.
    ip -6 route replace "$OPNSENSE_EDGE_V6/128" dev "$INTERNAL_IFACE" table $table 2>/dev/null || true

    # IMPORTANT:
    # The internal IPv6 prefix is routed *behind* OPNsense. Using "dev $INTERNAL_IFACE"
    # causes MWAN to attempt neighbor discovery for each internal host and will break
    # stateless return traffic (e.g. ICMPv6 echo replies) because those packets won't
    # reliably use conntrack marks.
    ip -6 route replace {{ mwan_internal_prefix }} via "$OPNSENSE_WAN_LL" dev "$INTERNAL_IFACE" table $table 2>/dev/null || true
done

# Ensure the main table can also reach the internal IPv6 /60 (for locally-generated traffic).
ip -6 route replace {{ mwan_internal_prefix }} via "$OPNSENSE_WAN_LL" dev "$INTERNAL_IFACE" metric 1024 2>/dev/null || true

# Deterministic fallback: if BOTH primary WANs are health-down and Monkeybrains is up,
# route forwarded traffic (coming from OPNsense) via Monkeybrains table for new flows.
if ! wan_is_up att && ! wan_is_up webpass && wan_is_up monkeybrains; then
    [ -n "${MB_GW4:-}" ] && ip rule add iif "$INTERNAL_IFACE" table {{ mwan_rt_tables.monkeybrains }} priority 50 2>/dev/null || true
    [ -n "${MB_GW6:-}" ] && ip -6 rule add iif "$INTERNAL_IFACE" table {{ mwan_rt_tables.monkeybrains }} priority 50 2>/dev/null || true
fi

# Management interface should use main routing table only (not policy routed)
# This ensures SSH access works regardless of WAN state

log "Policy routing update complete"

final_json() {
  jq -cn \
    --arg ip_rule "$(ip rule show || true)" \
    --arg ip6_rule "$(ip -6 rule show || true)" \
    --arg t100_v4 "$(ip route show table {{ mwan_rt_tables.att }} || true)" \
    --arg t200_v4 "$(ip route show table {{ mwan_rt_tables.webpass }} || true)" \
    --arg t100_v6 "$(ip -6 route show table {{ mwan_rt_tables.att }} || true)" \
    --arg t200_v6 "$(ip -6 route show table {{ mwan_rt_tables.webpass }} || true)" \
    '{
      ip_rule: $ip_rule,
      ip6_rule: $ip6_rule,
      t100_v4: $t100_v4,
      t200_v4: $t200_v4,
      t100_v6: $t100_v6,
      t200_v6: $t200_v6
    }'
}

[ "$DEBUG" = "1" ] && debug_json "FINAL" "rules_and_routes" "$(final_json)"

