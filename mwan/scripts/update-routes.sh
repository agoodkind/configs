#!/usr/bin/env bash
# Generated by Ansible
#
# What it does (symptoms):
# - Makes forwarded traffic from OPNsense reliably egress a WAN (and fail over) when primary WANs flap.
# - Prevents “wrong WAN” return-path issues by ensuring fwmark-based policy routing tables exist.
#
# What it does (technical):
# - Discovers per-interface IPv4/IPv6 gateways.
# - (Re)builds `ip rule` + per-WAN routing tables (100=AT&T, 200=Webpass, 300=Monkeybrains).
# - Adds internal-link routes (10.250.250.0/29, 3d06:bad:b01::/60, and OPNsense edge /128) into each table.
# - Uses `/var/run/mwan-health.state` (healthy/unhealthy/unknown) to include/exclude WANs.
#
# Dependency graph:
# - Boot safety net: `mwan-update-routes.service` (runs this once the WAN gateways are present).
# - Event-driven: `networkd-dispatcher` hook `50-update-routes.sh` (runs when WAN becomes `routable`).
# - Continuous convergence: `mwan-health` calls this on WAN health transitions.
# - Requires: WAN interfaces exist, gateways are discoverable, and nftables marking rules exist for fwmarks to matter.

set -euo pipefail

# shellcheck disable=SC1091
. /etc/mwan/mwan.env

# Serialize all invocations (boot safety net, dispatcher hooks, health daemon).
# This prevents concurrent `ip rule`/`ip route` edits from racing and leaving partial state.
LOCK_FILE="/run/mwan-update-routes.lock"
exec 9>"$LOCK_FILE"
flock 9

log() {
    local msg="$1"
    local prefix=""
    [ -n "${MWAN_TRACE_ID:-}" ] && prefix="traceId=${MWAN_TRACE_ID} "
    echo "[update-routes] ${prefix}${msg}"
    logger -t update-routes "${prefix}${msg}" || true
}

DEBUG="${MWAN_DEBUG_LOGGING:-0}"
DEBUG_LOG="${MWAN_DEBUG_LOG:-/var/log/mwan-debug.log}"
TRACE_FILE="${MWAN_TRACE_FILE:-/run/mwan-trace-id}"
MWAN_TRACE_ID="${MWAN_TRACE_ID:-}"
if [ -z "${MWAN_TRACE_ID:-}" ] && [ -r "$TRACE_FILE" ]; then
    MWAN_TRACE_ID="$(cat "$TRACE_FILE")"
fi

debug_json() {
    [ "$DEBUG" = "1" ] || return 0
    local loc="$1"; shift
    local msg="$1"; shift
    local data="${1:-{}}"; shift || true
    jq -cn \
      --arg traceId "${MWAN_TRACE_ID:-}" \
      --arg component "update-routes" \
      --arg location "$loc" \
      --arg message "$msg" \
      --arg data "${data:-{}}" \
      --argjson timestamp "$(date +%s%3N)" \
      '{
        traceId: $traceId,
        component: $component,
        location: $location,
        message: $message,
        data: (try ($data | fromjson) catch {}),
        timestamp: $timestamp
      }' >> "$DEBUG_LOG"
}

log "Updating policy routing tables"

# Interface names + routing table IDs
MGMT_IFACE="${MWAN_MGMT_IFACE:-}"
ATT_IFACE="${MWAN_ATT_VLAN_IFACE:-}"  # AT&T uses VLAN subinterface
WEBPASS_IFACE="${MWAN_WEBPASS_IFACE:-}"
MB_IFACE="${MWAN_MONKEYBRAINS_IFACE:-enmbrains0}"
INTERNAL_IFACE="${MWAN_INTERNAL_IFACE:-}"
OPNSENSE_WAN_LL="${MWAN_OPNSENSE_WAN_LL:-}"
OPNSENSE_EDGE_V6="${MWAN_OPNSENSE_EDGE_IPV6:-}"
INTERNAL_PREFIX="${MWAN_INTERNAL_PREFIX:-}"
ATT_TABLE="${MWAN_RT_ATT:-100}"
WEBPASS_TABLE="${MWAN_RT_WEBPASS:-200}"
MB_TABLE="${MWAN_RT_MONKEYBRAINS:-300}"
CLOUDFLARED_TABLE="${MWAN_RT_CLOUDFLARED:-400}"

# Health state (soft failures) from mwan-health
# Format: wan_name:health (e.g. "att:healthy", "webpass:unhealthy")
STATE_FILE="/var/run/mwan-health.state"
wan_health_state() {
    local wan="$1"
    [ -r "$STATE_FILE" ] || { echo "unknown"; return 0; }
    grep "^${wan}:" "$STATE_FILE" 2>/dev/null | tail -n1 | cut -d: -f2 || echo "unknown"
}
# Treat unknown as healthy to avoid cutting traffic during daemon warmup.
wan_is_healthy() {
    [ "$(wan_health_state "$1")" != "unhealthy" ]
}

# Get gateways
get_gw4() {
    local dev="$1"
    ip -j -4 route show default 2>/dev/null | jq -r --arg dev "$dev" '
      [
        .[] |
        if (.dev? == $dev and (.gateway? != null) and (.gateway? != "")) then
          .gateway
        elif (.nexthops? != null) then
          (.nexthops[]? | select(.dev? == $dev) | .gateway? // empty)
        else
          empty
        end
      ] | map(select(. != "")) | .[0] // empty
    '
}

get_gw6() {
    local dev="$1"
    ip -j -6 route show default 2>/dev/null | jq -r --arg dev "$dev" '
      [
        .[] |
        if (.dev? == $dev and (.gateway? != null) and (.gateway? != "")) then
          .gateway
        elif (.nexthops? != null) then
          (.nexthops[]? | select(.dev? == $dev) | .gateway? // empty)
        else
          empty
        end
      ] | map(select(. != "")) | .[0] // empty
    '
}

defaults_json() {
  jq -cn \
    --arg v4 "$(ip -4 route show default || true)" \
    --arg v6 "$(ip -6 route show default || true)" \
    '{
      "v4": $v4,
      "v6": $v6
    }'
}

[ "$DEBUG" = "1" ] && debug_json "DEFAULTS" "ip_default_routes" "$(defaults_json)"

[ -n "$ATT_IFACE" ] && ATT_GW4="$(get_gw4 "$ATT_IFACE")"
[ -n "$WEBPASS_IFACE" ] && WEBPASS_GW4="$(get_gw4 "$WEBPASS_IFACE")"
[ -n "$MB_IFACE" ] && MB_GW4="$(get_gw4 "$MB_IFACE")"
[ -n "$ATT_IFACE" ] && ATT_GW6="$(get_gw6 "$ATT_IFACE")"
[ -n "$WEBPASS_IFACE" ] && WEBPASS_GW6="$(get_gw6 "$WEBPASS_IFACE")"
[ -n "$MB_IFACE" ] && MB_GW6="$(get_gw6 "$MB_IFACE")"

log "AT&T: $ATT_IFACE (v6: $ATT_GW6, v4: $ATT_GW4)"
log "Webpass: $WEBPASS_IFACE (v6: $WEBPASS_GW6, v4: $WEBPASS_GW4)"
log "Monkeybrains: $MB_IFACE (v6: $MB_GW6, v4: $MB_GW4)"

gateways_json() {
  jq -cn \
    --arg att_iface "${ATT_IFACE:-}" \
    --arg webpass_iface "${WEBPASS_IFACE:-}" \
    --arg mb_iface "${MB_IFACE:-}" \
    --arg att_gw4 "${ATT_GW4:-}" \
    --arg webpass_gw4 "${WEBPASS_GW4:-}" \
    --arg mb_gw4 "${MB_GW4:-}" \
    --arg att_gw6 "${ATT_GW6:-}" \
    --arg webpass_gw6 "${WEBPASS_GW6:-}" \
    --arg mb_gw6 "${MB_GW6:-}" \
    --arg att_state "$(wan_health_state att)" \
    --arg webpass_state "$(wan_health_state webpass)" \
    --arg mb_state "$(wan_health_state monkeybrains)" \
    '{
      att_iface: $att_iface,
      webpass_iface: $webpass_iface,
      mb_iface: $mb_iface,
      att_gw4: $att_gw4,
      webpass_gw4: $webpass_gw4,
      mb_gw4: $mb_gw4,
      att_gw6: $att_gw6,
      webpass_gw6: $webpass_gw6,
      mb_gw6: $mb_gw6,
      health: {
        "att": $att_state,
        "webpass": $webpass_state,
        "monkeybrains": $mb_state
        }
    }'
}

[ "$DEBUG" = "1" ] && debug_json "GW" "parsed_gateways" "$(gateways_json)"

del_rule_v4() {
    # Best-effort targeted deletes (avoid nuking unrelated rules such as networkd "from" rules)
    ip rule del "$@" || true
}
del_rule_v6() {
    ip -6 rule del "$@" || true
}
ensure_uid_rule_v4() {
    local uid="$1" table="$2" prio="$3" enable="$4"
    del_rule_v4 priority "$prio" uidrange "${uid}-${uid}" table "$table"
    [ "$enable" = "1" ] && ip rule add priority "$prio" uidrange "${uid}-${uid}" table "$table" || true
}
ensure_uid_rule_v6() {
    local uid="$1" table="$2" prio="$3" enable="$4"
    del_rule_v6 priority "$prio" uidrange "${uid}-${uid}" table "$table"
    [ "$enable" = "1" ] && ip -6 rule add priority "$prio" uidrange "${uid}-${uid}" table "$table" || true
}
ensure_fwmark_rule_v4() {
    local mark="$1" table="$2" prio="$3" enable="$4"
    del_rule_v4 priority "$prio" fwmark "$mark" table "$table"
    [ "$enable" = "1" ] && ip rule add priority "$prio" fwmark "$mark" table "$table" || true
}
ensure_fwmark_rule_v6() {
    local mark="$1" table="$2" prio="$3" enable="$4"
    del_rule_v6 priority "$prio" fwmark "$mark" table "$table"
    [ "$enable" = "1" ] && ip -6 rule add priority "$prio" fwmark "$mark" table "$table" || true
}
ensure_iif_fallback_v4() {
    local table="$1" prio="$2" enable="$3"
    del_rule_v4 priority "$prio" iif "$INTERNAL_IFACE" table "$table"
    [ "$enable" = "1" ] && ip rule add priority "$prio" iif "$INTERNAL_IFACE" table "$table" || true
}
ensure_iif_fallback_v6() {
    local table="$1" prio="$2" enable="$3"
    del_rule_v6 priority "$prio" iif "$INTERNAL_IFACE" table "$table"
    [ "$enable" = "1" ] && ip -6 rule add priority "$prio" iif "$INTERNAL_IFACE" table "$table" || true
}

# Populate per-WAN routing tables first (non-destructive; do not flush).
if [ -n "${ATT_GW6:-}" ]; then
    ip -6 route replace default via "$ATT_GW6" dev "$ATT_IFACE" table "$ATT_TABLE"
fi
if [ -n "${ATT_GW4:-}" ]; then
    ip route replace default via "$ATT_GW4" dev "$ATT_IFACE" table "$ATT_TABLE"
fi
if [ -n "${WEBPASS_GW6:-}" ]; then
    ip -6 route replace default via "$WEBPASS_GW6" dev "$WEBPASS_IFACE" table "$WEBPASS_TABLE"
fi
if [ -n "${WEBPASS_GW4:-}" ]; then
    ip route replace default via "$WEBPASS_GW4" dev "$WEBPASS_IFACE" table "$WEBPASS_TABLE"
fi
if [ -n "${MB_GW6:-}" ]; then
    ip -6 route replace default via "$MB_GW6" dev "$MB_IFACE" table "$MB_TABLE"
fi
if [ -n "${MB_GW4:-}" ]; then
    ip route replace default via "$MB_GW4" dev "$MB_IFACE" table "$MB_TABLE"
fi

# Main table is intentionally untouched to avoid disrupting management

# Add internal network routes to all tables (so WANs can reach internal subnets)
for table in "$ATT_TABLE" "$WEBPASS_TABLE" "$MB_TABLE"; do
    ip route replace 10.250.250.0/29 dev "$INTERNAL_IFACE" table "$table" || true

    # Hairpin DNAT targets (e.g. WAN /128 interface addresses) are forwarded to OPNsense over the MWAN link.
    # Inbound flows are fwmarked by ingress WAN; without an explicit route in the policy tables, the fwmark
    # default route would try to send these packets back out the WAN instead of toward OPNsense.
    ip -6 route replace "$OPNSENSE_EDGE_V6/128" dev "$INTERNAL_IFACE" table "$table" || true

    # IMPORTANT:
    # The internal IPv6 prefix is routed *behind* OPNsense. Using "dev $INTERNAL_IFACE"
    # causes MWAN to attempt neighbor discovery for each internal host and will break
    # stateless return traffic (e.g. ICMPv6 echo replies) because those packets won't
    # reliably use conntrack marks.
    ip -6 route replace "$INTERNAL_PREFIX" via "$OPNSENSE_WAN_LL" dev "$INTERNAL_IFACE" table "$table" || true
done

# Ensure the main table can also reach the internal IPv6 /60 (for locally-generated traffic).
ip -6 route replace "$INTERNAL_PREFIX" via "$OPNSENSE_WAN_LL" dev "$INTERNAL_IFACE" metric 1024 || true

# Ensure cloudflared can always reach management/DNS networks even when its default is a WAN.
ip route replace 10.250.0.0/24 dev "$MGMT_IFACE" table "$CLOUDFLARED_TABLE" || true
ip -6 route replace 3d06:bad:b01::/64 dev "$MGMT_IFACE" table "$CLOUDFLARED_TABLE" || true

# Finally, enable/disable the policy rules we own based on health + gateway presence.
att_v4_enable=0; att_v6_enable=0
web_v4_enable=0; web_v6_enable=0
mb_v4_enable=0; mb_v6_enable=0

[ -n "${ATT_GW4:-}" ] && wan_is_healthy att && att_v4_enable=1
[ -n "${ATT_GW6:-}" ] && wan_is_healthy att && att_v6_enable=1
[ -n "${WEBPASS_GW4:-}" ] && wan_is_healthy webpass && web_v4_enable=1
[ -n "${WEBPASS_GW6:-}" ] && wan_is_healthy webpass && web_v6_enable=1
[ -n "${MB_GW4:-}" ] && wan_is_healthy monkeybrains && mb_v4_enable=1
[ -n "${MB_GW6:-}" ] && wan_is_healthy monkeybrains && mb_v6_enable=1

ensure_fwmark_rule_v4 1 "$ATT_TABLE" 100 "$att_v4_enable"
ensure_fwmark_rule_v6 1 "$ATT_TABLE" 100 "$att_v6_enable"
ensure_fwmark_rule_v4 2 "$WEBPASS_TABLE" 200 "$web_v4_enable"
ensure_fwmark_rule_v6 2 "$WEBPASS_TABLE" 200 "$web_v6_enable"
ensure_fwmark_rule_v4 3 "$MB_TABLE" 300 "$mb_v4_enable"
ensure_fwmark_rule_v6 3 "$MB_TABLE" 300 "$mb_v6_enable"

# Cloudflared carve-out:
# - Route cloudflared traffic via a dedicated table that prefers AT&T, then Webpass, then Monkeybrains.
# - Scoped by UID (does not interfere with fwmark-based forwarding logic).
cloudflared_uid=""
if id -u cloudflared >/dev/null 2>&1; then
    cloudflared_uid="$(id -u cloudflared)"
fi

cloud_v4_enable=0
cloud_v6_enable=0
cloud_gw4=""
cloud_if4=""
cloud_gw6=""
cloud_if6=""

if [ -n "$cloudflared_uid" ]; then
    if [ "$att_v4_enable" = "1" ]; then
        cloud_v4_enable=1; cloud_gw4="$ATT_GW4"; cloud_if4="$ATT_IFACE"
    elif [ "$web_v4_enable" = "1" ]; then
        cloud_v4_enable=1; cloud_gw4="$WEBPASS_GW4"; cloud_if4="$WEBPASS_IFACE"
    elif [ "$mb_v4_enable" = "1" ]; then
        cloud_v4_enable=1; cloud_gw4="$MB_GW4"; cloud_if4="$MB_IFACE"
    fi

    if [ "$att_v6_enable" = "1" ]; then
        cloud_v6_enable=1; cloud_gw6="$ATT_GW6"; cloud_if6="$ATT_IFACE"
    elif [ "$web_v6_enable" = "1" ]; then
        cloud_v6_enable=1; cloud_gw6="$WEBPASS_GW6"; cloud_if6="$WEBPASS_IFACE"
    elif [ "$mb_v6_enable" = "1" ]; then
        cloud_v6_enable=1; cloud_gw6="$MB_GW6"; cloud_if6="$MB_IFACE"
    fi

    if [ "$cloud_v4_enable" = "1" ]; then
        ip route replace default via "$cloud_gw4" dev "$cloud_if4" table "$CLOUDFLARED_TABLE" || true
    else
        ip route del default table "$CLOUDFLARED_TABLE" || true
    fi

    if [ "$cloud_v6_enable" = "1" ]; then
        ip -6 route replace default via "$cloud_gw6" dev "$cloud_if6" table "$CLOUDFLARED_TABLE" || true
    else
        ip -6 route del default table "$CLOUDFLARED_TABLE" || true
    fi

    ensure_uid_rule_v4 "$cloudflared_uid" "$CLOUDFLARED_TABLE" 10 "$cloud_v4_enable"
    ensure_uid_rule_v6 "$cloudflared_uid" "$CLOUDFLARED_TABLE" 10 "$cloud_v6_enable"
else
    # If cloudflared isn't installed on this host, don't install uid-based rules.
    del_rule_v4 priority 10 table "$CLOUDFLARED_TABLE"
    del_rule_v6 priority 10 table "$CLOUDFLARED_TABLE"
    ip route del default table "$CLOUDFLARED_TABLE" || true
    ip -6 route del default table "$CLOUDFLARED_TABLE" || true
fi

# Deterministic fallback: if BOTH primary WANs are unhealthy and Monkeybrains is healthy,
# route forwarded traffic (coming from OPNsense) via Monkeybrains table for new flows.
fallback_enable=0
if ! wan_is_healthy att && ! wan_is_healthy webpass && wan_is_healthy monkeybrains; then
    fallback_enable=1
fi
ensure_iif_fallback_v4 "$MB_TABLE" 50 "$fallback_enable"
ensure_iif_fallback_v6 "$MB_TABLE" 50 "$fallback_enable"

# Management interface should use main routing table only (not policy routed)
# This ensures SSH access works regardless of WAN state

log "Policy routing update complete"

final_json() {
  jq -cn \
    --arg ip_rule "$(ip rule show || true)" \
    --arg ip6_rule "$(ip -6 rule show || true)" \
    --arg t100_v4 "$(ip route show table "$ATT_TABLE" || true)" \
    --arg t200_v4 "$(ip route show table "$WEBPASS_TABLE" || true)" \
    --arg t100_v6 "$(ip -6 route show table "$ATT_TABLE" || true)" \
    --arg t200_v6 "$(ip -6 route show table "$WEBPASS_TABLE" || true)" \
    '{
      ip_rule: $ip_rule,
      ip6_rule: $ip6_rule,
      t100_v4: $t100_v4,
      t200_v4: $t200_v4,
      t100_v6: $t100_v6,
      t200_v6: $t200_v6
    }'
}

[ "$DEBUG" = "1" ] && debug_json "FINAL" "rules_and_routes" "$(final_json)"

