#!/usr/bin/env bash
# Generated by Ansible
#
# Refresh the nftables sets `inet mangle att_pinned_v4` and `att_pinned_v6`:
# - seeds static CIDRs from `/etc/mwan/mwan.env`
# - resolves configured FQDNs to A and AAAA records
# - optionally pulls Zoom published IPv4 prefixes (MWAN_ZOOM_IPRANGES_URL)
#
# Notes:
# - Serialized with a lockfile to avoid overlapping timer/manual runs.
# - Applied as a single `nft -f` transaction (atomic).

set -euo pipefail

# shellcheck disable=SC1091
. /etc/mwan/mwan.env

TABLE="inet"
NFT_TABLE="mangle"
SET_V4="att_pinned_v4"
SET_V6="att_pinned_v6"

DEBUG="${MWAN_DEBUG_LOGGING:-0}"
DEBUG_LOG="${MWAN_DEBUG_LOG:-/var/log/mwan-debug.log}"
TRACE_FILE="${MWAN_TRACE_FILE:-/run/mwan-trace-id}"
MWAN_TRACE_ID="${MWAN_TRACE_ID:-}"
if [ -z "${MWAN_TRACE_ID:-}" ] && [ -r "$TRACE_FILE" ]; then
    MWAN_TRACE_ID="$(cat "$TRACE_FILE")"
fi

LOCK_FILE="/run/mwan-update-att-pinned.lock"
exec 9>"$LOCK_FILE"
flock 9

log() {
    local prefix=""
    [ -n "${MWAN_TRACE_ID:-}" ] && prefix="traceId=${MWAN_TRACE_ID} "
    logger -t update-att-pinned "${prefix}$*" || true
    echo "[update-att-pinned] ${prefix}$*"
}

debug_json() {
    [ "$DEBUG" = "1" ] || return 0
    local loc="$1"; shift
    local msg="$1"; shift
    local data="${1:-{}}"; shift || true
    exec 9>>"$DEBUG_LOG"
    flock -w 2 9 || true

    jq -cn \
      --arg traceId "${MWAN_TRACE_ID:-}" \
      --arg component "update-att-pinned" \
      --arg location "$loc" \
      --arg message "$msg" \
      --arg data "${data:-{}}" \
      --argjson timestamp "$(date +%s%3N)" \
      '
      def parsed($s): (try ($s | fromjson) catch null);
      def p: parsed($data);
      {
        traceId: $traceId,
        component: $component,
        location: $location,
        message: $message,
        data: (p // {}),
        dataParseError: (p == null),
        dataRaw: (if (p == null) then $data else null end),
        timestamp: $timestamp
      }' >&9

    flock -u 9 || true
    exec 9>&-
}

ensure_sets_exist() {
    local missing=0
    if ! nft list set $TABLE $NFT_TABLE $SET_V4 >/dev/null 2>&1; then
        log "nft set missing: $TABLE $NFT_TABLE $SET_V4"
        missing=1
    fi
    if ! nft list set $TABLE $NFT_TABLE $SET_V6 >/dev/null 2>&1; then
        log "nft set missing: $TABLE $NFT_TABLE $SET_V6"
        missing=1
    fi
    return $missing
}

resolve_v4() {
    local name="$1"
    # Use getent for portability.
    getent ahostsv4 "$name" 2>/dev/null | awk '{print $1}' | sort -u
}

resolve_v6() {
    local name="$1"
    # Use getent for portability.
    getent ahostsv6 "$name" 2>/dev/null | awk '{print $1}' | sort -u
}

# IPv4 helpers
append_seed_cidrs_v4() {
    local tmp="$1"
    local cidr

    for cidr in ${MWAN_ATT_PINNED_V4_SEED_CIDRS:-}; do
        [ -n "$cidr" ] || continue
        echo "$cidr" >>"$tmp"
    done
}

append_fqdn_v4() {
    local tmp="$1"
    local fqdn ip

    for fqdn in ${MWAN_ATT_PINNED_V4_FQDNS:-}; do
        [ -n "$fqdn" ] || continue
        while read -r ip; do
            [ -n "$ip" ] || continue
            echo "$ip/32" >>"$tmp"
        done < <(resolve_v4 "$fqdn" || true)
    done
}

zoom_v4_prefixes() {
    local url="${MWAN_ZOOM_IPRANGES_URL:-}"
    [ -n "$url" ] || return 0

    # Prefer parsing Zoom's plain-text prefix lists (one prefix per line), but also support the
    # older JSON format (ip_prefix fields) if you swap the URL back.
    if echo "$url" | grep -qiE '\\.json($|\\?)'; then
        curl -fsSL "$url" 2>/dev/null \
          | jq -r '.. | .ip_prefix? // empty' 2>/dev/null \
          | awk '/^[0-9]+\\./{print}' \
          | sort -u
    else
        curl -fsSL "$url" 2>/dev/null \
          | awk '/^[0-9]+\\./{print}' \
          | sort -u
    fi
}

# IPv6 helpers
append_seed_cidrs_v6() {
    local tmp="$1"
    local cidr

    for cidr in ${MWAN_ATT_PINNED_V6_SEED_CIDRS:-}; do
        [ -n "$cidr" ] || continue
        echo "$cidr" >>"$tmp"
    done
}

append_fqdn_v6() {
    local tmp="$1"
    local fqdn ip

    for fqdn in ${MWAN_ATT_PINNED_V6_FQDNS:-}; do
        [ -n "$fqdn" ] || continue
        while read -r ip; do
            [ -n "$ip" ] || continue
            echo "$ip/128" >>"$tmp"
        done < <(resolve_v6 "$fqdn" || true)
    done
}

main() {
    if ! ensure_sets_exist; then
        exit 1
    fi

    # Build element lists for both protocols
    tmp_v4="$(mktemp)"
    tmp_v6="$(mktemp)"
    tmp_nft="$(mktemp)"
    trap 'rm -f "$tmp_v4" "$tmp_v6" "$tmp_nft"' EXIT

    # Build IPv4 elements
    append_seed_cidrs_v4 "$tmp_v4"
    append_fqdn_v4 "$tmp_v4"

    # Zoom feed (optional, IPv4 only)
    while read -r cidr; do
        [ -n "$cidr" ] || continue
        echo "$cidr" >>"$tmp_v4"
    done < <(zoom_v4_prefixes || true)

    # Build IPv6 elements
    append_seed_cidrs_v6 "$tmp_v6"
    append_fqdn_v6 "$tmp_v6"

    # Build single atomic nft transaction for both sets
    count_v4=0
    count_v6=0
    {
        echo "flush set $TABLE $NFT_TABLE $SET_V4"
        sort -u "$tmp_v4" | while read -r elem; do
            [ -n "$elem" ] || continue
            echo "add element $TABLE $NFT_TABLE $SET_V4 { $elem }"
            count_v4=$((count_v4 + 1))
        done

        echo "flush set $TABLE $NFT_TABLE $SET_V6"
        sort -u "$tmp_v6" | while read -r elem; do
            [ -n "$elem" ] || continue
            echo "add element $TABLE $NFT_TABLE $SET_V6 { $elem }"
            count_v6=$((count_v6 + 1))
        done
    } >"$tmp_nft"

    # Count elements (since subshells don't update parent vars)
    count_v4=$(sort -u "$tmp_v4" | grep -c . || echo 0)
    count_v6=$(sort -u "$tmp_v6" | grep -c . || echo 0)

    nft -f "$tmp_nft"

    [ "$DEBUG" = "1" ] && debug_json "APPLY" "elements_applied" \
        "$(jq -cn --argjson v4 "$count_v4" --argjson v6 "$count_v6" '{v4: $v4, v6: $v6}')"

    log "Pinned sets updated (v4: $count_v4, v6: $count_v6)"
}

main "$@"
