#!/usr/sbin/nftables -f
# nftables configuration for mwan multi-WAN load balancer
# Generated by Ansible
#
# NOTE: Interfaces may be DOWN (e.g., cable unplugged) - this is OK.
# Rules will simply not match until interfaces come back up.
# nftables uses actual interface names (not altnames) for reliability.

flush ruleset

# Define variables - use actual kernel interface names
define MGMT_IFACE = "{{ actual_mgmt_iface | default(mwan_mgmt_iface) }}"
define ATT_IFACE = "{{ actual_att_iface | default(mwan_att_iface) }}.{{ mwan_att_vlan_id }}"
define WEBPASS_IFACE = "{{ actual_webpass_iface | default(mwan_webpass_iface) }}"
define INTERNAL_IFACE = "{{ actual_internal_iface | default(mwan_internal_iface) }}"
define MB_IFACE = "{{ mwan_monkeybrains_iface }}"

# Internal network (mwan <-> OPNsense link)
define INTERNAL_NET = 10.250.250.0/29

table inet filter {
    chain input {
        type filter hook input priority filter; policy drop;

        # Allow established/related
        ct state established,related accept

        # Allow loopback
        iif lo accept

        # Allow ICMP
        ip protocol icmp accept
        ip6 nexthdr icmpv6 accept

        # Allow SSH from management network
        iifname $MGMT_IFACE tcp dport 22 accept
        # iif $INTERNAL_IFACE tcp dport 22 accept

        # Allow DHCP on management interface
        # iif $MGMT_IFACE udp sport 67 udp dport 68 accept
        # iif $MGMT_IFACE udp sport 547 udp dport 546 accept

        # Allow DHCP on WAN interfaces
        iifname $ATT_IFACE udp sport 67 udp dport 68 accept
        iifname $WEBPASS_IFACE udp sport 67 udp dport 68 accept
        iifname $ATT_IFACE udp sport 547 udp dport 546 accept
        iifname $WEBPASS_IFACE udp sport 547 udp dport 546 accept
        iifname $MB_IFACE udp sport 67 udp dport 68 accept
        iifname $MB_IFACE udp sport 547 udp dport 546 accept

        # Log dropped packets (rate limited)
        limit rate 1/second log prefix "nftables input drop: " drop
    }

    chain forward {
        type filter hook forward priority filter; policy drop;

        # Allow established/related
        ct state established,related accept

        # Allow forwarding from internal to WANs
        iifname $INTERNAL_IFACE oifname { $ATT_IFACE, $WEBPASS_IFACE
            , $MB_IFACE
        } accept

        # Allow forwarding from WANs to internal (for inbound services)
        iifname { $ATT_IFACE, $WEBPASS_IFACE
            , $MB_IFACE
        } oifname $INTERNAL_IFACE accept

        # Log dropped packets (rate limited)
        limit rate 1/second log prefix "nftables forward drop: " drop
    }

    chain output {
        type filter hook output priority filter; policy accept;
    }
}

table ip nat {
    # Connection tracking for load balancing
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # Mark new connections for load balancing (fwmark)
        iifname $INTERNAL_IFACE ip saddr $INTERNAL_NET ct state new meta mark set numgen random mod 2 map { 0 : 1, 1 : 2 }

        # Inbound 1:1 NAT (DNAT) for static IPs
        # Map external /29s back to the internal /29 so OPNsense (and downstream) can receive inbound traffic.
{% for mapping in mwan_static_mappings.att %}
        iifname $ATT_IFACE ip daddr {{ mapping.external }} dnat to {{ mapping.internal }}
{% endfor %}
{% for mapping in mwan_static_mappings.webpass %}
        iifname $WEBPASS_IFACE ip daddr {{ mapping.external }} dnat to {{ mapping.internal }}
{% endfor %}
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # 1:1 NAT for static IPs - AT&T
{% for mapping in mwan_static_mappings.att %}
        oifname $ATT_IFACE ip saddr {{ mapping.internal }} snat to {{ mapping.external }}
{% endfor %}

        # 1:1 NAT for static IPs - Webpass
{% for mapping in mwan_static_mappings.webpass %}
        oifname $WEBPASS_IFACE ip saddr {{ mapping.internal }} snat to {{ mapping.external }}
{% endfor %}

        # Default SNAT for other LAN traffic via AT&T (mark 1)
        oifname $ATT_IFACE meta mark 1 ip saddr $INTERNAL_NET masquerade

        # Default SNAT for other LAN traffic via Webpass (mark 2)
        oifname $WEBPASS_IFACE meta mark 2 ip saddr $INTERNAL_NET masquerade

        # Emergency fallback SNAT via Monkeybrains (mark 3 or any mark if routed out MB)
        oifname $MB_IFACE ip saddr $INTERNAL_NET masquerade
    }
}

table ip6 nat {
    chain prerouting {
        type nat hook prerouting priority dstnat; policy accept;

        # Inbound NPT - translate ISP prefix to internal
        # These will be dynamically set by update-npt.sh when PDs arrive
        # Called by 55-update-npt.sh (networkd-dispatcher hook)
    }

    chain postrouting {
        type nat hook postrouting priority srcnat; policy accept;

        # Outbound NPT for IPv6 (programmed at runtime):
        # - /60 NPT to PD /60
        # Called by update-npt.sh via 55-update-npt.sh hook

        # NOTE:
        # Avoid NAT66 on Monkeybrains. IPv6 should use the same /60 NPT mechanism as other WANs
        # (programmed at runtime by update-npt.sh). Keeping a static masquerade here can override
        # the NPT rules due to rule order.
    }
}

table inet mangle {
    set att_pinned_v4 {
        type ipv4_addr;
        flags interval;
        auto-merge;
        elements = {
{% for cidr in mwan_att_pinned_v4_seed_cidrs | default([]) %}
            {{ cidr }}{% if not loop.last %},{% endif %}
{% endfor %}
        }
    }

    set att_pinned_v6 {
        type ipv6_addr;
        flags interval;
        auto-merge;
        elements = {
{% for cidr in mwan_att_pinned_v6_seed_cidrs | default([]) %}
            {{ cidr }}{% if not loop.last %},{% endif %}
{% endfor %}
        }
    }

    chain prerouting {
        type filter hook prerouting priority mangle; policy accept;

        # Mark inbound NEW flows by ingress WAN (keeps replies symmetric via policy routing tables)
        iifname $ATT_IFACE ct state new meta mark set 1
        iifname $WEBPASS_IFACE ct state new meta mark set 2
        iifname $MB_IFACE ct state new meta mark set 3

        # NOTE: IPv4 load balancing is driven by the per-flow random mark in `table ip nat prerouting`.
        # Do NOT override marks for 10.250.250.2-10.250.250.6 here, or IPv4 will pin to one WAN.

        # Pin latency-sensitive traffic to AT&T (mark 1)
        # Failover: If AT&T down, update-routes.sh removes the fwmark rule,
        # and traffic falls through to main table (which uses Webpass)
        ip daddr @att_pinned_v4 meta mark set 1
        ip6 daddr @att_pinned_v6 meta mark set 1

        # Load-balance outbound IPv6 from OPNsense-edge /128 as well.
        #
        # Why:
        # - Hairpinned inbound flows DNAT to OPNsense at {{ mwan_opnsense_edge_ipv6 }}.
        # - Replies sourced from that address MUST be marked so policy routing sends them
        #   back out the same WAN (and so postrouting SNAT selects the correct WAN ::1).
        ip6 saddr {{ mwan_opnsense_edge_ipv6 | default('3d06:bad:b01:fe::2') }}/128 ct state new meta mark set numgen random mod 2 map { 0 : 1, 1 : 2 }

        # Load-balance IPv6 from internal /60 prefix
        ip6 saddr {{ mwan_internal_prefix }} ct state new meta mark set numgen random mod 2 map { 0 : 1, 1 : 2 }

        # General traffic (no mark): Uses main table's multipath routing
        # Kernel automatically:
        #   - Load balances 50/50 when both WANs up
        #   - Fails over to single WAN when one is down
        # update-routes.sh manages the multipath route based on health

        # Restore mark for established connections (session affinity)
        ct state established,related meta mark set ct mark
    }

    chain postrouting {
        type filter hook postrouting priority mangle; policy accept;

        # Save mark to conntrack
        ct mark set meta mark
    }
}
